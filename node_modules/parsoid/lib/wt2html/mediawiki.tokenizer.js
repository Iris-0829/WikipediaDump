( function () {

"use strict";
/*
 * Generated by WikiPEG
 */



function peg$subclass(child, parent) {
  function ctor() { this.constructor = child; }
  ctor.prototype = parent.prototype;
  child.prototype = new ctor();
}

function peg$SyntaxError(message, expected, found, location) {
  this.message  = message;
  this.expected = expected;
  this.found    = found;
  this.location = location;

  this.name     = "SyntaxError";
}

peg$subclass(peg$SyntaxError, Error);

function peg$Reference(value) {
  this.value = value;
}

peg$Reference.prototype = {
  get: function() {
    return this.value;
  },
  set: function(value) {
    this.value = value;
  }
};

function peg$DefaultTracer() {
  this.indentLevel = 0;
}

peg$DefaultTracer.prototype.trace = function(event) {
  var that = this;

  function log(event) {
    function repeat(string, n) {
      var result = "", i;

      for (i = 0; i < n; i++) {
        result += string;
      }

      return result;
    }

    function pad(string, length) {
      return string + repeat(" ", length - string.length);
    }

    function formatArgs(argMap) {
      var argParts = [];
      for (let argName in argMap) {
        if (argName === 'silence') {
          continue;
        }
        if (argName === 'boolParams') {
          argParts.push('0x' + argMap[argName].toString(16));
        } else {
          let displayName = argName.replace(/^param_/, '');
          if (typeof argMap[argName] === 'object' && argMap[argName].value !== undefined) {
            argParts.push(displayName + "=&" + JSON.stringify(argMap[argName].value));
          } else {
            argParts.push(displayName + "=" + argMap[argName]);
          }
        }
      }
      if (argParts.length) {
        return ' <' + argParts.join(', ') + '>';
      } else {
        return '';
      }
    }

    console.log(
      pad(
        event.location.start.line + ":" + event.location.start.column + "-"
        + event.location.end.line + ":" + event.location.end.column + " ",
        20
      )
      + pad(event.type, 10) + " "
      + repeat("  ", that.indentLevel) + event.rule
      + formatArgs(event.args)
    );
  }

  switch (event.type) {
    case "rule.enter":
      log(event);
      this.indentLevel++;
      break;

    case "rule.match":
      this.indentLevel--;
      log(event);
      break;

    case "rule.fail":
      this.indentLevel--;
      log(event);
      break;

    default:
      throw new Error("Invalid event type: " + event.type + ".");
  }
};

function peg$parse(input, options = {}) {
  var parser = this,
      peg$currPos = 0,
      peg$savedPos = 0,
      peg$FAILED = {},
      peg$startRule = options.startRule || '(DEFAULT)',
      peg$result;

  function text() {
    return input.substring(peg$savedPos, peg$currPos);
  }

  function location() {
    return peg$computeLocation(peg$savedPos, peg$currPos);
  }

  function expected(description) {
    throw peg$buildException(
      null,
      [{ type: "other", description: description }],
      input.substring(peg$savedPos, peg$currPos),
      peg$computeLocation(peg$savedPos, peg$currPos)
    );
  }

  function error(message) {
    throw peg$buildException(
      message,
      null,
      input.substring(peg$savedPos, peg$currPos),
      peg$computeLocation(peg$savedPos, peg$currPos)
    );
  }

  var peg$posDetailsCache  = [{ line: 1, column: 1, seenCR: false }],
      peg$maxFailPos       = 0,
      peg$maxFailExpected  = [];

  function peg$computePosDetails(pos) {
    var details = peg$posDetailsCache[pos],
      p, ch;

    if (details) {
      return details;
    } else {
      p = pos - 1;
      while (!peg$posDetailsCache[p]) {
        p--;
      }

      details = peg$posDetailsCache[p];
      details = {
        line:   details.line,
        column: details.column,
        seenCR: details.seenCR
      };

      while (p < pos) {
        ch = input.charAt(p);
        if (ch === "\n") {
          if (!details.seenCR) { details.line++; }
          details.column = 1;
          details.seenCR = false;
        } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
          details.line++;
          details.column = 1;
          details.seenCR = true;
        } else {
          details.column++;
          details.seenCR = false;
        }

        p++;
      }

      peg$posDetailsCache[pos] = details;
      return details;
    }
  }

  function peg$computeLocation(startPos, endPos) {
    if (endPos > input.length) {
      endPos--;
    }
    var startPosDetails = peg$computePosDetails(startPos),
      endPosDetails   = peg$computePosDetails(endPos);

    return {
      start: {
        offset: startPos,
        line:   startPosDetails.line,
        column: startPosDetails.column
      },
      end: {
        offset: endPos,
        line:   endPosDetails.line,
        column: endPosDetails.column
      }
    };
  }

  function peg$fail(expected) {
    if (peg$currPos < peg$maxFailPos) { return; }

    if (peg$currPos > peg$maxFailPos) {
      peg$maxFailPos = peg$currPos;
      peg$maxFailExpected = [];
    }

    peg$maxFailExpected.push(expected);
  }

  function peg$buildException(message, expected, found, location) {
    function cleanupExpected(expected) {
      var i = 1;

      expected.sort(function(a, b) {
        if (a.description < b.description) {
          return -1;
        } else if (a.description > b.description) {
          return 1;
        } else {
          return 0;
        }
      });

      /*
       * This works because the bytecode generator guarantees that every
       * expectation object exists only once, so it's enough to use |===| instead
       * of deeper structural comparison.
       */
      while (i < expected.length) {
        if (expected[i - 1] === expected[i]) {
          expected.splice(i, 1);
        } else {
          i++;
        }
      }
    }

    function buildMessage(expected, found) {
      function stringEscape(s) {
        function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }

        /*
         * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a string
         * literal except for the closing quote character, backslash, carriage
         * return, line separator, paragraph separator, and line feed. Any character
         * may appear in the form of an escape sequence.
         *
         * For portability, we also escape all control and non-ASCII characters.
         * Note that "\0" and "\v" escape sequences are not used because JSHint does
         * not like the first and IE the second.
         */
        return s
          .replace(/\\/g,   '\\\\')       // backslash
          .replace(/"/g,    '\\"')        // closing double quote
          .replace(/\x08/g, '\\b')        // backspace
          .replace(/\t/g,   '\\t')        // horizontal tab
          .replace(/\n/g,   '\\n')        // line feed
          .replace(/\f/g,   '\\f')        // form feed
          .replace(/\r/g,   '\\r')        // carriage return
          .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
          .replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return '\\x'  + hex(ch); })
          .replace(/[\u0100-\u0FFF]/g,         function(ch) { return '\\u0' + hex(ch); })
          .replace(/[\u1000-\uFFFF]/g,         function(ch) { return '\\u'  + hex(ch); });
      }

      var expectedDescs = new Array(expected.length),
        expectedDesc, foundDesc, i;

      for (i = 0; i < expected.length; i++) {
        expectedDescs[i] = expected[i].description;
      }

      expectedDesc = expected.length > 1
        ? expectedDescs.slice(0, -1).join(", ")
        + " or "
        + expectedDescs[expected.length - 1]
        : expectedDescs[0];

      foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";

      return "Expected " + expectedDesc + " but " + foundDesc + " found.";
    }

    if (expected !== null) {
      cleanupExpected(expected);
    }

    return new peg$SyntaxError(
      message !== null ? message : buildMessage(expected, found),
      expected,
      found,
      location
    );
  }

  function peg$buildParseException() {
    return peg$buildException(
      null,
      peg$maxFailExpected,
      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
      peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
    );
  }


  function peg$traceCall(parseFunc, name, argNames, args) {
    var argMap = {};
    for (let i = 0; i < args.length; i++) {
      argMap[argNames[i]] = args[i];
    }
    var startPos = peg$currPos;
    peg$tracer.trace({
      type:     "rule.enter",
      rule:     name,
      location: peg$computeLocation(startPos, startPos),
      args: argMap
    });
    var result = parseFunc.apply(null, args);
    if (result !== peg$FAILED) {
      peg$tracer.trace({
        type:     "rule.match",
        rule:     name,
        result:   result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: name,
        location: peg$computeLocation(startPos, startPos)
      });
    }
    return result;
  }

  var peg$tracer = "tracer" in options ? options.tracer : new peg$DefaultTracer();

    var peg$cache = {};
    var visitCounts = new Uint8Array(input.length);

  // expectations
  var peg$c0 = {"type":"end","description":"end of input"};
  var peg$c1 = {"type":"other","description":"start"};
  var peg$c2 = {"type":"other","description":"table_start_tag"};
  var peg$c3 = {"type":"other","description":"url"};
  var peg$c4 = {"type":"other","description":"table_attributes"};
  var peg$c5 = {"type":"other","description":"generic_newline_attributes"};
  var peg$c6 = {"type":"other","description":"tplarg_or_template_or_bust"};
  var peg$c7 = {"type":"other","description":"extlink"};
  var peg$c8 = {"type":"other","description":"tlb"};
  var peg$c9 = {"type":"class","value":"[ \\t]","description":"[ \\t]"};
  var peg$c10 = {"type":"literal","value":"<!--","description":"\"<!--\""};
  var peg$c11 = {"type":"any","description":"any character"};
  var peg$c12 = {"type":"literal","value":"-->","description":"\"-->\""};
  var peg$c13 = {"type":"literal","value":"|","description":"\"|\""};
  var peg$c14 = {"type":"literal","value":"{{!}}","description":"\"{{!}}\""};
  var peg$c15 = {"type":"literal","value":"//","description":"\"//\""};
  var peg$c16 = {"type":"class","value":"[A-Za-z]","description":"[A-Za-z]"};
  var peg$c17 = {"type":"class","value":"[-A-Za-z0-9+.]","description":"[-A-Za-z0-9+.]"};
  var peg$c18 = {"type":"literal","value":":","description":"\":\""};
  var peg$c19 = {"type":"literal","value":"[","description":"\"[\""};
  var peg$c20 = {"type":"class","value":"[0-9A-Fa-f:.]","description":"[0-9A-Fa-f:.]"};
  var peg$c21 = {"type":"literal","value":"]","description":"\"]\""};
  var peg$c22 = {"type":"class","value":"[^ :\\]\\[\\r\\n\"'<>\\x00-\\x20\\x7f,.&%\\u00A0\\u1680\\u180E\\u2000-\\u200A\\u202F\\u205F\\u3000{]","description":"[^ :\\]\\[\\r\\n\"'<>\\x00-\\x20\\x7f,.&%\\u00A0\\u1680\\u180E\\u2000-\\u200A\\u202F\\u205F\\u3000{]"};
  var peg$c23 = {"type":"literal","value":"=","description":"\"=\""};
  var peg$c24 = {"type":"class","value":"[\\0/=>]","description":"[\\0/=>]"};
  var peg$c25 = {"type":"class","value":"[ \\u00A0\\u1680\\u2000-\\u200A\\u202F\\u205F\\u3000]","description":"[ \\u00A0\\u1680\\u2000-\\u200A\\u202F\\u205F\\u3000]"};
  var peg$c26 = {"type":"literal","value":"\n","description":"\"\\n\""};
  var peg$c27 = {"type":"literal","value":"\r\n","description":"\"\\r\\n\""};
  var peg$c28 = {"type":"literal","value":"{","description":"\"{\""};
  var peg$c29 = {"type":"literal","value":"&","description":"\"&\""};
  var peg$c30 = {"type":"class","value":"[#0-9a-zA-Z]","description":"[#0-9a-zA-Z]"};
  var peg$c31 = {"type":"literal","value":";","description":"\";\""};
  var peg$c32 = {"type":"class","value":"[\"'=]","description":"[\"'=]"};
  var peg$c33 = {"type":"class","value":"[^ \\t\\r\\n\\0/=><&{}\\-!|\\[]","description":"[^ \\t\\r\\n\\0/=><&{}\\-!|\\[]"};
  var peg$c34 = {"type":"literal","value":"'","description":"\"'\""};
  var peg$c35 = {"type":"literal","value":"\"","description":"\"\\\"\""};
  var peg$c36 = {"type":"literal","value":"/","description":"\"/\""};
  var peg$c37 = {"type":"class","value":"[^ \\t\\r\\n\\0/=><&{}\\-!|]","description":"[^ \\t\\r\\n\\0/=><&{}\\-!|]"};
  var peg$c38 = {"type":"class","value":"[ \\t\\n\\r\\x0c]","description":"[ \\t\\n\\r\\x0c]"};
  var peg$c39 = {"type":"class","value":"[^'<~[{\\n\\r|!\\]}\\-\\t&=\"' \\u00A0\\u1680\\u180E\\u2000-\\u200A\\u202F\\u205F\\u3000]","description":"[^'<~[{\\n\\r|!\\]}\\-\\t&=\"' \\u00A0\\u1680\\u180E\\u2000-\\u200A\\u202F\\u205F\\u3000]"};
  var peg$c40 = {"type":"class","value":"[&|{\\-]","description":"[&|{\\-]"};
  var peg$c41 = {"type":"class","value":"[.:,]","description":"[.:,]"};
  var peg$c42 = {"type":"class","value":"[']","description":"[']"};
  var peg$c43 = {"type":"literal","value":" ","description":"\" \""};
  var peg$c44 = {"type":"class","value":"[^-'<~[{\\n\\r:;\\]}|!=]","description":"[^-'<~[{\\n\\r:;\\]}|!=]"};
  var peg$c45 = {"type":"literal","value":"[[","description":"\"[[\""};
  var peg$c46 = {"type":"literal","value":"<","description":"\"<\""};
  var peg$c47 = {"type":"literal","value":"{{","description":"\"{{\""};
  var peg$c48 = {"type":"class","value":"[^{}&<\\-!\\['\\r\\n|]","description":"[^{}&<\\-!\\['\\r\\n|]"};
  var peg$c49 = {"type":"class","value":"[{}&<\\-!\\[]","description":"[{}&<\\-!\\[]"};
  var peg$c50 = {"type":"class","value":"[^{}&<\\-!\\[\"\\r\\n|]","description":"[^{}&<\\-!\\[\"\\r\\n|]"};
  var peg$c51 = {"type":"class","value":"[^{}&<\\-!\\[ \\t\\n\\r\\x0c|]","description":"[^{}&<\\-!\\[ \\t\\n\\r\\x0c|]"};
  var peg$c52 = {"type":"class","value":"[^{}&<\\-|/'>]","description":"[^{}&<\\-|/'>]"};
  var peg$c53 = {"type":"class","value":"[{}&\\-|/]","description":"[{}&\\-|/]"};
  var peg$c54 = {"type":"class","value":"[^{}&<\\-|/\">]","description":"[^{}&<\\-|/\">]"};
  var peg$c55 = {"type":"class","value":"[^{}&<\\-|/ \\t\\n\\r\\x0c>]","description":"[^{}&<\\-|/ \\t\\n\\r\\x0c>]"};
  var peg$c56 = {"type":"literal","value":"__","description":"\"__\""};
  var peg$c57 = {"type":"literal","value":"-","description":"\"-\""};
  var peg$c58 = {"type":"literal","value":"''","description":"\"''\""};
  var peg$c59 = {"type":"class","value":"[ \\t\\n\\r\\0\\x0b]","description":"[ \\t\\n\\r\\0\\x0b]"};
  var peg$c60 = {"type":"literal","value":"----","description":"\"----\""};
  var peg$c61 = {"type":"literal","value":">","description":"\">\""};
  var peg$c62 = {"type":"literal","value":"{{{","description":"\"{{{\""};
  var peg$c63 = {"type":"literal","value":"}}}","description":"\"}}}\""};
  var peg$c64 = {"type":"literal","value":"}}","description":"\"}}\""};
  var peg$c65 = {"type":"literal","value":"]]","description":"\"]]\""};
  var peg$c66 = {"type":"class","value":"[&%{]","description":"[&%{]"};
  var peg$c67 = {"type":"literal","value":"RFC","description":"\"RFC\""};
  var peg$c68 = {"type":"literal","value":"PMID","description":"\"PMID\""};
  var peg$c69 = {"type":"class","value":"[0-9]","description":"[0-9]"};
  var peg$c70 = {"type":"literal","value":"ISBN","description":"\"ISBN\""};
  var peg$c71 = {"type":"class","value":"[xX]","description":"[xX]"};
  var peg$c72 = {"type":"class","value":"[^'\"<~[{\\n\\r:;\\]}|!=]","description":"[^'\"<~[{\\n\\r:;\\]}|!=]"};
  var peg$c73 = {"type":"class","value":"[\\n\\r\\t ]","description":"[\\n\\r\\t ]"};
  var peg$c74 = {"type":"literal","value":"}","description":"\"}\""};
  var peg$c75 = {"type":"class","value":"[^<[{\\n\\r\\t|!\\]}{ &\\-]","description":"[^<[{\\n\\r\\t|!\\]}{ &\\-]"};
  var peg$c76 = {"type":"class","value":"[!<\\-\\}\\]\\n\\r]","description":"[!<\\-\\}\\]\\n\\r]"};
  var peg$c77 = {"type":"literal","value":"-{","description":"\"-{\""};
  var peg$c78 = {"type":"literal","value":"}-","description":"\"}-\""};
  var peg$c79 = {"type":"class","value":"[*#:;]","description":"[*#:;]"};
  var peg$c80 = {"type":"literal","value":"+","description":"\"+\""};
  var peg$c81 = {"type":"class","value":"[^\\t\\n\\v />\\0]","description":"[^\\t\\n\\v />\\0]"};
  var peg$c82 = {"type":"literal","value":"!","description":"\"!\""};
  var peg$c83 = {"type":"literal","value":"!!","description":"\"!!\""};
  var peg$c84 = {"type":"literal","value":"=>","description":"\"=>\""};
  var peg$c85 = {"type":"literal","value":"||","description":"\"||\""};
  var peg$c86 = {"type":"literal","value":"{{!}}{{!}}","description":"\"{{!}}{{!}}\""};
  var peg$c87 = {"type":"class","value":"[-+A-Z]","description":"[-+A-Z]"};
  var peg$c88 = {"type":"class","value":"[^{}|;]","description":"[^{}|;]"};
  var peg$c89 = {"type":"class","value":"[a-z]","description":"[a-z]"};
  var peg$c90 = {"type":"class","value":"[-a-zA-Z]","description":"[-a-zA-Z]"};

  // actions
  function peg$a0() {
  
        if (endOffset() === input.length) {
            emitChunk([ new EOFTk() ]);
        }
        // terminate the loop
        return false;
      
  }
  function peg$a1() {
  
        // end is passed inline as a token, as well as a separate event for now.
        emitChunk([ new EOFTk() ]);
        return true;
    
  }
  function peg$a2(sc) {
   return endOffset(); 
  }
  function peg$a3(sc, startPos, b, p) {
   assert(false); return false; 
  }
  function peg$a4(sc, startPos, b, p, ta) {
   return endOffset(); 
  }
  function peg$a5(sc, startPos, b, p, ta, tsEndPos, s2) {
  
          ta = ta.slice(0); // ta is immutable when cached
          var coms = tu.popComments(ta);
          if (coms) {
            tsEndPos = coms.commentStartPos;
          }
  
          var da = { tsr: [startPos, tsEndPos] };
          if (p !== "|") {
              // Variation from default
              da.startTagSrc = b + p;
          }
  
          sc.push(new TagTk('table', ta, da));
          if (coms) {
            sc = sc.concat(coms.buf);
          }
          return sc.concat(s2);
      
  }
  function peg$a6(proto, addr, c) {
   return c; 
  }
  function peg$a7(proto, addr, s) {
   return s; 
  }
  function peg$a8(proto, addr, he) {
   return he; 
  }
  function peg$a9(proto, addr, r) {
   return r; 
  }
  function peg$a10(proto, addr, path) {
   return addr.length > 0 || path.length > 0; 
  }
  function peg$a11(proto, addr, path) {
  
      return tu.flattenString([proto, addr].concat(path));
  
  }
  function peg$a12(as, s, p) {
  
          return [as, s, p];
      
  }
  function peg$a13(b) {
   return b; 
  }
  function peg$a14(r) {
   return tu.flattenIfArray(r); 
  }
  function peg$a15() {
   return endOffset(); 
  }
  function peg$a16(p0, addr, target) {
   return endOffset(); 
  }
  function peg$a17(p0, addr, target, p1) {
  
            // Protocol must be valid and there ought to be at least one
            // post-protocol character.  So strip last char off target
            // before testing protocol.
            var flat = tu.flattenString([addr, target]);
            if (Array.isArray(flat)) {
               // There are templates present, alas.
               return flat.length > 0;
            }
            return Util.isProtocolValid(flat.slice(0, -1), env);
          
  }
  function peg$a18(p0, addr, target, p1, sp) {
   return endOffset(); 
  }
  function peg$a19(p0, addr, target, p1, sp, p2, content) {
   return endOffset(); 
  }
  function peg$a20(p0, addr, target, p1, sp, p2, content, p3) {
  
              const tsr1 = [p0, p1];
              const tsr2 = [p2, p3];
              return [
                  new SelfclosingTagTk('extlink', [
                      new KV('href', tu.flattenString([addr, target]), tu.expandTsrV(tsr1)),
                      new KV('mw:content', content || '', tu.expandTsrV(tsr2)),
                      new KV('spaces', sp),
                  ], {
                      tsr: tsrOffsets(),
                      extLinkContentOffsets: tsr2,
                  }),
              ];
          
  }
  function peg$a21(r) {
   return r; 
  }
  function peg$a22(b) {
  
      // Clear the tokenizer's backtracking cache after matching each
      // toplevelblock. There won't be any backtracking as a document is just a
      // sequence of toplevelblocks, so the cache for previous toplevelblocks
      // will never be needed.
      var end = startOffset();
      for (; prevOffset < end; prevOffset++) {
          peg$cache[prevOffset] = undefined;
      }
  
      var tokens;
      if (Array.isArray(b) && b.length) {
          tokens = tu.flattenIfArray(b);
      } else if (b && b.constructor === String) {
          tokens = [b];
      }
  
      // Emit tokens for this toplevelblock. This feeds a chunk to the parser pipeline.
      if (tokens) {
          emitChunk(tokens);
      }
  
      // We don't return any tokens to the start rule to save memory. We
      // just emitted them already to our consumers.
      return true;
    
  }
  function peg$a23() {
   return [new NlTk(tsrOffsets())]; 
  }
  function peg$a24(c) {
  
          var data = WTUtils.encodeComment(c);
          return [new CommentTk(data, { tsr: tsrOffsets() })];
      
  }
  function peg$a25() {
   return Util.isProtocolValid(input.substr(endOffset()), env); 
  }
  function peg$a26(p) {
   return p; 
  }
  function peg$a27(extTag, h, extlink, templatedepth, preproc, equal, table, templateArg, tableCellArg, semicolon, arrow, linkdesc, colon, th) {
  
              return inlineBreaks(input, endOffset(), {
                  extTag: extTag,
                  h: h,
                  extlink: extlink,
                  templatedepth: templatedepth,
                  preproc: preproc,
                  equal: equal,
                  table: table,
                  templateArg: templateArg,
                  tableCellArg: tableCellArg,
                  semicolon: semicolon,
                  arrow: arrow,
                  linkdesc: linkdesc,
                  colon: colon,
                  th: th
              });
          
  }
  function peg$a28(templatedepth) {
  
        // Refuse to recurse beyond `maxDepth` levels. Default in the PHP parser
        // is $wgMaxTemplateDepth = 40; This is to prevent crashing from
        // buggy wikitext with lots of unclosed template calls, as in
        // eswiki/Usuario:C%C3%A1rdenas/PRUEBAS?oldid=651094
        return templatedepth + 1 < env.conf.parsoid.maxDepth;
      
  }
  function peg$a29(templatedepth, t) {
   return t; 
  }
  function peg$a30(cc) {
  
      // if this is an invalid entity, don't tag it with 'mw:Entity'
      if (cc.length > 2 /* decoded entity would be 1 or 2 UTF-16 characters */) {
          return cc;
      }
      return [
          // If this changes, the nowiki extension's toDOM will need to follow suit
          new TagTk('span', [new KV('typeof', 'mw:Entity')], { src: text(), srcContent: cc, tsr: tsrOffsets('start') }),
          cc,
          new EndTagTk('span', [], { tsr: tsrOffsets('end') }),
      ];
  
  }
  function peg$a31(s) {
   return endOffset(); 
  }
  function peg$a32(s, namePos0, name) {
   return endOffset(); 
  }
  function peg$a33(s, namePos0, name, namePos, v) {
   return v; 
  }
  function peg$a34(s, namePos0, name, namePos, vd) {
  
      // NB: Keep in sync w/ generic_newline_attribute
      var res;
      // Encapsulate protected attributes.
      if (typeof name === 'string') {
          name = tu.protectAttrs(name);
      }
      if (vd !== null) {
          res = new KV(name, vd.value, [namePos0, namePos, vd.srcOffsets[0], vd.srcOffsets[1]]);
          res.vsrc = input.substring(vd.srcOffsets[0], vd.srcOffsets[1]);
      } else {
          res = new KV(name, '', [namePos0, namePos, namePos, namePos]);
      }
      if (Array.isArray(name)) {
          res.ksrc = input.substring(namePos0, namePos);
      }
      return res;
  
  }
  function peg$a35(s) {
  
        if (s.length) {
            return [s];
        } else {
            return [];
        }
    
  }
  function peg$a36(c) {
   return new KV(c, ''); 
  }
  function peg$a37(namePos0, name) {
   return endOffset(); 
  }
  function peg$a38(namePos0, name, namePos, v) {
   return v; 
  }
  function peg$a39(namePos0, name, namePos, vd) {
  
      // NB: Keep in sync w/ table_attibute
      var res;
      // Encapsulate protected attributes.
      if (typeof name === 'string') {
          name = tu.protectAttrs(name);
      }
      if (vd !== null) {
          res = new KV(name, vd.value, [namePos0, namePos, vd.srcOffsets[0], vd.srcOffsets[1]]);
          res.vsrc = input.substring(vd.srcOffsets[0], vd.srcOffsets[1]);
      } else {
          res = new KV(name, '', [namePos0, namePos, namePos, namePos]);
      }
      if (Array.isArray(name)) {
          res.ksrc = input.substring(namePos0, namePos);
      }
      return res;
  
  }
  function peg$a40(s) {
   return s; 
  }
  function peg$a41(c) {
  
        return tu.flattenStringlist(c);
    
  }
  function peg$a42() {
   return endOffset() === input.length; 
  }
  function peg$a43(r, cil, bl) {
   return [r].concat(cil, bl || []); 
  }
  function peg$a44(c) {
   return c; 
  }
  function peg$a45(rs) {
   return rs; 
  }
  function peg$a46(a) {
   return a; 
  }
  function peg$a47(a, b) {
   return [a].concat(b); 
  }
  function peg$a48(m) {
  
      return Util.decodeWtEntities(m);
  
  }
  function peg$a49(q, ill) {
   return ill; 
  }
  function peg$a50(q, t) {
   return t; 
  }
  function peg$a51(q, r) {
   return r.length > 0 || q.length > 0; 
  }
  function peg$a52(q, r) {
   return tu.flattenString([q].concat(r)); 
  }
  function peg$a53(s, t, q) {
  
        return tu.getAttrVal(t, startOffset() + s.length, endOffset() - q.length);
      
  }
  function peg$a54(s, t) {
  
        return tu.getAttrVal(t, startOffset() + s.length, endOffset());
      
  }
  function peg$a55(r) {
  
          return tu.flattenString(r);
      
  }
  function peg$a56(al) {
   return al; 
  }
  function peg$a57(he) {
   return he; 
  }
  function peg$a58() {
  
                // Content with mw:Placeholder typeof attribute will be ignored by
                // editing clients and they are not expected to modify it either.
                // This is just an escape hatch for scenarios where we don't have
                // a good representation for this content and just want to render
                // it without providing any editing support for it.
                return [
                    new TagTk('span', [
                        new KV('typeof', 'mw:DisplaySpace mw:Placeholder'),
                    ], {
                        src: ' ',
                        tsr: tsrOffsets('start'),
                        isDisplayHack: true,
                    }),
                    '\u00a0',
                    new EndTagTk('span', [
                    ], {
                        tsr: tsrOffsets('end'),
                        isDisplayHack: true,
                    }),
                ];
            
  }
  function peg$a59(bs) {
   return bs; 
  }
  function peg$a60() {
   return endOffset() === 0 && !options.pipelineOffset; 
  }
  function peg$a61(rw, sp, c, wl) {
  
        return wl.length === 1 && wl[0] && wl[0].constructor !== String;
    
  }
  function peg$a62(rw, sp, c, wl) {
  
      var link = wl[0];
      if (sp) { rw += sp; }
      if (c) { rw += c; }
      // Build a redirect token
      var redirect = new SelfclosingTagTk('mw:redirect',
              // Put 'href' into attributes so it gets template-expanded
              [link.getAttributeKV('href')],
              {
                  src: rw,
                  tsr: tsrOffsets(),
                  linkTk: link,
              });
      return redirect;
  
  }
  function peg$a63(st, tl) {
   return tl; 
  }
  function peg$a64(st, bt, stl) {
   return bt.concat(stl); 
  }
  function peg$a65(st, bts) {
   return bts; 
  }
  function peg$a66(st, r) {
  
            return st.concat(r);
        
  }
  function peg$a67(s, os, so) {
   return os.concat(so); 
  }
  function peg$a68(s, s2, bl) {
  
          return s.concat(s2 || [], bl);
      
  }
  function peg$a69(tag) {
   return tag; 
  }
  function peg$a70(s1, s2, c) {
  
        return s1.concat(s2, c);
    
  }
  function peg$a71(preproc, t) {
  
          preproc.set(null);
          return t;
      
  }
  function peg$a72(v) {
   return v; 
  }
  function peg$a73(e) {
   return e; 
  }
  function peg$a74(r) {
  
      return tu.flattenString(r);
    
  }
  function peg$a75() {
   return Util.isUniWord(Util.lastUniChar(input, endOffset())); 
  }
  function peg$a76(target) {
  
          var tsr = tsrOffsets();
          var res = [new SelfclosingTagTk('urllink', [new KV('href', target, tu.expandTsrV(tsr))], { tsr })];
            return res;
        
  }
  function peg$a77(bs) {
  
      if (env.conf.wiki.isMagicWord(bs)) {
        return [
          new SelfclosingTagTk('behavior-switch', [ new KV('word', bs) ],
            { tsr: tsrOffsets(), src: bs, magicSrc: bs }
          ),
        ];
      } else {
        return [ bs ];
      }
    
  }
  function peg$a78(quotes) {
  
      // sequences of four or more than five quotes are assumed to start
      // with some number of plain-text apostrophes.
      var plainticks = 0;
      var result = [];
      if (quotes.length === 4) {
          plainticks = 1;
      } else if (quotes.length > 5) {
          plainticks = quotes.length - 5;
      }
      if (plainticks > 0) {
          result.push(quotes.substring(0, plainticks));
      }
      // mw-quote token Will be consumed in token transforms
      var tsr = tsrOffsets();
      tsr[0] += plainticks;
      var mwq = new SelfclosingTagTk('mw-quote', [new KV('value', quotes.substring(plainticks))], { tsr: tsr });
      if (quotes.length > 2) {
          mwq.addAttribute('preceding-2chars', input.substring(tsr[0] - 2, tsr[0]));
      }
      result.push(mwq);
      return result;
  
  }
  function peg$a79(rw) {
   return env.conf.wiki.getMagicWordMatcher('redirect').test(rw); 
  }
  function peg$a80(n) {
   return tu.isIncludeTag(n.toLowerCase()); 
  }
  function peg$a81(il, sol_il) {
  
      il = il[0];
      var lname = il.name.toLowerCase();
      if (!tu.isIncludeTag(lname)) { return false; }
      // Preserve SOL where necessary (for onlyinclude and noinclude)
      // Note that this only works because we encounter <*include*> tags in
      // the toplevel content and we rely on the php preprocessor to expand
      // templates, so we shouldn't ever be tokenizing inInclude.
      // Last line should be empty (except for comments)
      if (lname !== "includeonly" && sol_il && il.constructor === TagTk) {
          var dp = il.dataAttribs;
          var inclContent = dp.src.slice(dp.extTagOffsets[2], -dp.extTagOffsets[3]);
          var last = lastItem(inclContent.split('\n'));
          if (!/^(<!--([^-]|-(?!->))*-->)*$/.test(last)) {
              return false;
          }
      }
      return true;
    
  }
  function peg$a82(il, sol_il) {
   return il; 
  }
  function peg$a83(s, ill) {
   return ill || []; 
  }
  function peg$a84(s, ce) {
   return ce || s.length > 2; 
  }
  function peg$a85(s, ce) {
   return endOffset(); 
  }
  function peg$a86(s, ce, endTPos, spc) {
  
          var c;
          var e;
          var level;
          if (ce) {
              c = ce[0];
              e = ce[1];
              level = Math.min(s.length, e.length);
          } else {
              // split up equal signs into two equal parts, with at least
              // one character in the middle.
              level = Math.floor((s.length - 1) / 2);
              c = ['='.repeat(s.length - 2 * level)];
              s = e = '='.repeat(level);
          }
          level = Math.min(6, level);
          // convert surplus equals into text
          if (s.length > level) {
              // Avoid modifying a cached result
              c = Util.clone(c, false);
              var extras1 = s.substr(0, s.length - level);
              if (c[0].constructor === String) {
                  c[0] = extras1 + c[0];
              } else {
                  c.unshift(extras1);
              }
          }
          if (e.length > level) {
              // Avoid modifying a cached result
              c = Util.clone(c, false);
              var extras2 = e.substr(0, e.length - level);
              var lastElem = lastItem(c);
              if (lastElem.constructor === String) {
                  c[c.length - 1] += extras2;
              } else {
                  c.push(extras2);
              }
          }
  
          var tsr = tsrOffsets('start');
          tsr[1] += level;
          // Match PHP behavior by (a) making headingIndex part of tokenizer
          // state(don't reuse pipeline!) and (b) assigning the index when
          // ==*== is tokenized, even if we're inside a template argument
          // or other context which won't end up putting the heading
          // on the output page.  T213468/T214538
          headingIndex++;
          return [
            new TagTk('h' + level, [], { tsr: tsr, tmp: { headingIndex } }),
          ].concat(c, [
            new EndTagTk('h' + level, [], { tsr: [endTPos - level, endTPos] }),
            spc,
          ]);
        
  }
  function peg$a87(d) {
   return undefined; 
  }
  function peg$a88(d) {
   return true; 
  }
  function peg$a89(d, lineContent) {
  
      var dataAttribs = {
        tsr: tsrOffsets(),
        lineContent: lineContent,
      };
      if (d.length > 0) {
        dataAttribs.extra_dashes = d.length;
      }
      return new SelfclosingTagTk('hr', [], dataAttribs);
    
  }
  function peg$a90(tl) {
  
          return tl;
      
  }
  function peg$a91(end, name, extTag, isBlock) {
  
          if (extTag) {
              return isExtTag(name);
          } else {
              return isXMLTag(name, isBlock);
          }
      
  }
  function peg$a92(end, name, extTag, isBlock, attribs, selfclose) {
  
          var lcName = name.toLowerCase();
  
          // Extension tags don't necessarily have the same semantics as html tags,
          // so don't treat them as void elements.
          var isVoidElt = Util.isVoidElement(lcName) && !extTag;
  
          // Support </br>
          if (lcName === 'br' && end) {
              end = null;
          }
  
          var tsr = tsrOffsets();
          tsr[0]--; // For "<" matched at the start of xmlish_tag rule
          var res = tu.buildXMLTag(name, lcName, attribs, end, !!selfclose || isVoidElt, tsr);
  
          // change up data-attribs in one scenario
          // void-elts that aren't self-closed ==> useful for accurate RT-ing
          if (!selfclose && isVoidElt) {
              res.dataAttribs.selfClose = undefined;
              res.dataAttribs.noClose = true;
          }
  
          var met = maybeExtensionTag(res);
          return Array.isArray(met) ? met : [met];
      
  }
  function peg$a93(sp) {
   return endOffset(); 
  }
  function peg$a94(sp, p, c) {
  
          return [
              sp,
              new SelfclosingTagTk("meta", [new KV('typeof', 'mw:EmptyLine')], {
                  tokens: tu.flattenIfArray(c),
                  tsr: [p, endOffset()],
              }),
          ];
      
  }
  function peg$a95() {
  
        // Use the sol flag only at the start of the input
        // Flag should always be an actual boolean (not falsy or undefined)
        assert(typeof options.sol === 'boolean');
        return endOffset() === 0 && options.sol;
    
  }
  function peg$a96() {
   return []; 
  }
  function peg$a97(p, target) {
   return endOffset(); 
  }
  function peg$a98(p, target, p0, v) {
   return endOffset(); 
  }
  function peg$a99(p, target, p0, v, p1) {
   return { tokens: v, srcOffsets: [p0, p1] }; 
  }
  function peg$a100(p, target, r) {
   return r; 
  }
  function peg$a101(p, target, params) {
  
        params = params.map(function(o) {
          return new KV('', tu.flattenIfArray(o.tokens), tu.expandTsrV(o.srcOffsets));
        });
        if (target === null) { target = { tokens: '', srcOffsets: [p, p] }; }
        // Insert target as first positional attribute, so that it can be
        // generically expanded. The TemplateHandler then needs to shift it out
        // again.
        params.unshift(new KV(tu.flattenIfArray(target.tokens), '', tu.expandTsrK(target.srcOffsets)));
        var obj = new SelfclosingTagTk('templatearg', params, { tsr: tsrOffsets(), src: text() });
        return obj;
      
  }
  function peg$a102(leadWS, target) {
   return endOffset(); 
  }
  function peg$a103(leadWS, target, p0, v) {
   return endOffset(); 
  }
  function peg$a104(leadWS, target, p0, v, p) {
   return new KV('', tu.flattenIfArray(v), tu.expandTsrV([p0, p])); 
  }
  function peg$a105(leadWS, target, r) {
   return r; 
  }
  function peg$a106(leadWS, target, params, trailWS) {
  
        // Insert target as first positional attribute, so that it can be
        // generically expanded. The TemplateHandler then needs to shift it out
        // again.
        params.unshift(new KV(tu.flattenIfArray(target.tokens), '', tu.expandTsrK(target.srcOffsets)));
        var obj = new SelfclosingTagTk('template', params, { tsr: tsrOffsets(), src: text(), tmp: { leadWS, trailWS } });
        return obj;
      
  }
  function peg$a107(spos, target) {
   return endOffset(); 
  }
  function peg$a108(spos, target, tpos, lcs) {
  
        var pipeTrick = (lcs.length === 1 && lcs[0].v === null);
        var textTokens = [];
        if (target === null || pipeTrick) {
          textTokens.push("[[");
          if (target) {
            textTokens.push(target);
          }
          lcs.forEach(function(a) {
            // a is a mw:maybeContent attribute
            textTokens.push("|");
            if (a.v !== null) { textTokens.push(a.v); }
          });
          textTokens.push("]]");
          return textTokens;
        }
        var obj = new SelfclosingTagTk('wikilink');
        var hrefKV = new KV('href', target, tu.expandTsrV([spos,tpos]));
        hrefKV.vsrc = input.substring(spos, tpos);
        // XXX: Point to object with path, revision and input information
        // obj.source = input;
        obj.attribs.push(hrefKV);
        obj.attribs = obj.attribs.concat(lcs);
        obj.dataAttribs = {
            tsr: tsrOffsets(),
            src: text(),
        };
        return [obj];
    
  }
  function peg$a109(preproc) {
   preproc.set(null); return true; 
  }
  function peg$a110(preproc, a) {
  
          return a;
      
  }
  function peg$a111(extToken) {
   return extToken[0].name === 'extension'; 
  }
  function peg$a112(extToken) {
   return extToken[0]; 
  }
  function peg$a113(proto, addr, rhe) {
   return /^[<>\u00A0]$/.test(rhe); 
  }
  function peg$a114(proto, addr, path) {
  
      // as in Parser.php::makeFreeExternalLink, we're going to
      // yank trailing punctuation out of this match.
      var url = tu.flattenStringlist([proto, addr].concat(path));
      // only need to look at last element; HTML entities are strip-proof.
      var last = lastItem(url);
      var trim = 0;
      if (last && last.constructor === String) {
        var strip = ',;\\.:!?';
        if (path.indexOf("(") === -1) {
          strip += ')';
        }
        strip = new RegExp('[' + JSUtils.escapeRegExp(strip) + ']*$');
        trim = strip.exec(last)[0].length;
        url[url.length - 1] = last.slice(0, last.length - trim);
      }
      url = tu.flattenStringlist(url);
      if (url.length === 1 && url[0].constructor === String && url[0].length <= proto.length) {
        return null; // ensure we haven't stripped everything: T106945
      }
      peg$currPos -= trim;
      return url;
  
  }
  function peg$a115(r) {
   return r !== null; 
  }
  function peg$a116(r) {
  return r; 
  }
  function peg$a117(ref, sp, identifier) {
  
      var base_urls = {
        'RFC': 'https://tools.ietf.org/html/rfc%s',
        'PMID': '//www.ncbi.nlm.nih.gov/pubmed/%s?dopt=Abstract',
      };
      const tsr = tsrOffsets();
      return [
          new SelfclosingTagTk('extlink', [
             new KV('href', tu.sprintf(base_urls[ref], identifier)),
             new KV('mw:content', tu.flattenString([ref, sp, identifier]), tu.expandTsrV(tsr)),
             new KV('typeof', 'mw:ExtLink/' + ref),
          ],
          { stx: "magiclink", tsr }),
      ];
  
  }
  function peg$a118(sp, s) {
   return s; 
  }
  function peg$a119(sp, isbn) {
  
          // Convert isbn token-and-entity array to stripped string.
          return tu.flattenStringlist(isbn).filter(function(e) {
            return e.constructor === String;
          }).join('').replace(/[^\dX]/ig, '').toUpperCase();
        
  }
  function peg$a120(sp, isbn, isbncode) {
  
         // ISBNs can only be 10 or 13 digits long (with a specific format)
         return isbncode.length === 10 ||
               (isbncode.length === 13 && /^97[89]/.test(isbncode));
      
  }
  function peg$a121(sp, isbn, isbncode) {
  
      const tsr = tsrOffsets();
        return [
          new SelfclosingTagTk('extlink', [
             new KV('href', 'Special:BookSources/' + isbncode),
             new KV('mw:content', tu.flattenString(['ISBN', sp, isbn]), tu.expandTsrV(tsr)),
             new KV('typeof', 'mw:WikiLink/ISBN'),
          ],
          { stx: "magiclink", tsr }),
        ];
  
  }
  function peg$a122(lc) {
   return lc; 
  }
  function peg$a123(bullets, c) {
   return endOffset(); 
  }
  function peg$a124(bullets, c, cpos, d) {
  
          // Leave bullets as an array -- list handler expects this
          // TSR: +1 for the leading ";"
          const numBullets = bullets.length + 1;
          const tsr = tsrOffsets('start');
          tsr[1] += numBullets;
          const li1Bullets = bullets.slice();
          li1Bullets.push(";");
          const li1 = new TagTk('listItem', [new KV('bullets', li1Bullets, tu.expandTsrV(tsr))], { tsr });
          // TSR: -1 for the intermediate ":"
          const li2Bullets = bullets.slice();
          li2Bullets.push(":");
          const tsr2 = [cpos - 1, cpos];
          const li2 = new TagTk('listItem', [new KV('bullets', li2Bullets, tu.expandTsrV(tsr2))], { tsr: tsr2, stx: 'row' });
  
          return [ li1 ].concat(c || [], [ li2 ], d || []);
      
  }
  function peg$a125(bullets, tbl, line) {
  
      // Leave bullets as an array -- list handler expects this
      var tsr = tsrOffsets('start');
      tsr[1] += bullets.length;
      var li = new TagTk('listItem', [new KV('bullets', bullets, tu.expandTsrV(tsr))], { tsr });
      return tu.flattenIfArray([li, tbl || [], line || []]);
  
  }
  function peg$a126(bullets, c) {
  
      // Leave bullets as an array -- list handler expects this
      var tsr = tsrOffsets('start');
      tsr[1] += bullets.length;
      var li = new TagTk('listItem', [new KV('bullets', bullets, tu.expandTsrV(tsr))], { tsr });
      return [ li ].concat(c || []);
  
  }
  function peg$a127(spc) {
  
          if (spc.length) {
              return [spc];
          } else {
              return [];
          }
      
  }
  function peg$a128(sc, startPos, p, b) {
  
        var tblEnd = new EndTagTk('table', [], { tsr: [startPos, endOffset()] });
        if (p !== "|") {
            // p+"<brace-char>" is triggering some bug in pegJS
            // I cannot even use that expression in the comment!
            tblEnd.dataAttribs.endTagSrc = p + b;
        }
        return sc.concat([tblEnd]);
    
  }
  function peg$a129(tpt) {
  
          return { tokens: tpt, srcOffsets: tsrOffsets() };
      
  }
  function peg$a130(name) {
   return endOffset(); 
  }
  function peg$a131(name, kEndPos) {
   return endOffset(); 
  }
  function peg$a132(name, kEndPos, vStartPos, tpv) {
  
              return { kEndPos: kEndPos, vStartPos: vStartPos, value: (tpv && tpv.tokens) || [] };
          
  }
  function peg$a133(name, val) {
  
        if (val !== null) {
            var so = [startOffset(), val.kEndPos, val.vStartPos, endOffset()];
            if (val.value !== null) {
              return new KV(name, tu.flattenIfArray(val.value), so);
            } else {
              return new KV(tu.flattenIfArray(name), '', so);
            }
        } else {
          return new KV('', tu.flattenIfArray(name), tu.expandTsrV([startOffset(), endOffset()]));
        }
      
  }
  function peg$a134() {
  
      return new KV('', '', tu.expandTsrV([startOffset(), endOffset()]));
    
  }
  function peg$a135(t, wr) {
   return wr; 
  }
  function peg$a136(r) {
  
        return tu.flattenStringlist(r);
    
  }
  function peg$a137(startPos, lt) {
  
          var maybeContent = new KV('mw:maybeContent', lt, tu.expandTsrV([startPos, endOffset()]));
          maybeContent.vsrc = input.substring(startPos, endOffset());
          return maybeContent;
    
  }
  function peg$a138(he) {
   return Array.isArray(he) && /^\u00A0$/.test(he[1]); 
  }
  function peg$a139() {
   return startOffset(); 
  }
  function peg$a140(lv0) {
   return env.langConverterEnabled(); 
  }
  function peg$a141(lv0, ff) {
  
           // Avoid mutating cached expression results
           ff = Util.clone(ff, true);
           // if flags contains 'R', then don't treat ; or : specially inside.
           if (ff.flags) {
             ff.raw = ff.flags.has('R') || ff.flags.has('N');
           } else if (ff.variants) {
             ff.raw = true;
           }
           return ff;
         
  }
  function peg$a142(lv0) {
   return !env.langConverterEnabled(); 
  }
  function peg$a143(lv0) {
  
           // if language converter not enabled, don't try to parse inside.
           return { raw: true };
         
  }
  function peg$a144(lv0, f) {
   return f.raw; 
  }
  function peg$a145(lv0, f, lv) {
   return [{ text: lv }]; 
  }
  function peg$a146(lv0, f) {
   return !f.raw; 
  }
  function peg$a147(lv0, f, lv) {
   return lv; 
  }
  function peg$a148(lv0, f, ts) {
   return endOffset(); 
  }
  function peg$a149(lv0, f, ts, lv1) {
  
  
        if (!env.langConverterEnabled()) {
          return [ "-{", ts[0].text.tokens, "}-" ];
        }
        var lvsrc = input.substring(lv0, lv1);
        var attribs = [];
  
        // Do a deep clone since we may be destructively modifying
        // (the `t[fld] = name;` below) the result of a cached expression
        ts = Util.clone(ts, true);
  
        ts.forEach(function(t) {
          // move token strings into KV attributes so that they are
          // properly expanded by early stages of the token pipeline
          ['text','from','to'].forEach(function(fld) {
            if (t[fld] === undefined) { return; }
            var name = 'mw:lv' + attribs.length;
            // Note that AttributeExpander will expect the tokens array to be
            // flattened.  We do that in lang_variant_text / lang_variant_nowiki
            attribs.push(new KV(name, t[fld].tokens, tu.expandTsrV(t[fld].srcOffsets)));
            t[fld] = name;
          });
        });
        return [
          new SelfclosingTagTk(
            'language-variant',
             attribs,
             {
               tsr: [lv0, lv1],
               src: lvsrc,
               flags: f.flags && Array.from(f.flags).sort(),
               variants: f.variants && Array.from(f.variants).sort(),
               original: f.original,
               flagSp: f.sp,
               texts: ts,
             }),
        ];
      
  }
  function peg$a150(r, preproc) {
  
          preproc.set(null);
          return r;
      
  }
  function peg$a151(ill) {
   return ill; 
  }
  function peg$a152(p, dashes) {
   assert(false); return false; 
  }
  function peg$a153(p, dashes, a) {
   return endOffset(); 
  }
  function peg$a154(p, dashes, a, tagEndPos) {
  
          a = a.slice(0); // a is immutable when cached
          var coms = tu.popComments(a);
          if (coms) {
            tagEndPos = coms.commentStartPos;
          }
  
          var da = {
            tsr: [ startOffset(), tagEndPos ],
            startTagSrc: p + dashes,
          };
  
          // We rely on our tree builder to close the row as needed. This is
          // needed to support building tables from fragment templates with
          // individual cells or rows.
          var trToken = new TagTk('tr', a, da);
  
          var res = [ trToken ];
          if (coms) {
            res = res.concat(coms.buf);
          }
          return res;
      
  }
  function peg$a155(p, td) {
   return endOffset(); 
  }
  function peg$a156(p, td, tagEndPos, tds) {
  
          // Avoid modifying a cached result
          td = td.slice();
          td[0] = Util.clone(td[0]);
  
          var da = td[0].dataAttribs;
          da.tsr[0] -= p.length; // include "|"
          if (p !== "|") {
              // Variation from default
              da.startTagSrc = p;
          }
          return td.concat(tds);
      
  }
  function peg$a157(p, args) {
   return endOffset(); 
  }
  function peg$a158(p, args, tagEndPos, c) {
  
          return tu.buildTableTokens("caption", "|+", args, [startOffset(), tagEndPos], endOffset(), c, true);
      
  }
  function peg$a159(il) {
  
          // il is guaranteed to be an array -- so, tu.flattenIfArray will
          // always return an array
          var r = tu.flattenIfArray(il);
          if (r.length === 1 && r[0].constructor === String) {
              r = r[0];
          }
          return r;
      
  }
  function peg$a160() {
   return ''; 
  }
  function peg$a161(tpt) {
  
          return tpt;
      
  }
  function peg$a162(ff) {
   return ff; 
  }
  function peg$a163(f) {
  
      // Collect & separate flags and variants into a set and ordered list
      var flags = new Set();
      var variants = new Set();
      var flagList = [];
      var flagSpace = [];
      var variantList = [];
      var variantSpace = [];
      var useVariants = false;
      if (f !== null) {
        // lang_variant_flags returns arrays in reverse order.
        f.flags.reverse();
        f.sp.reverse();
        var spPtr = 0;
        f.flags.forEach(function(item) {
          if (item.flag) {
            flagSpace.push(f.sp[spPtr++]);
            flags.add(item.flag);
            flagList.push(item.flag);
            flagSpace.push(f.sp[spPtr++]);
          }
          if (item.variant) {
            variantSpace.push(f.sp[spPtr++]);
            variants.add(item.variant);
            variantList.push(item.variant);
            variantSpace.push(f.sp[spPtr++]);
          }
        });
        if (spPtr < f.sp.length) {
          // handle space after a trailing semicolon
          flagSpace.push(f.sp[spPtr]);
          variantSpace.push(f.sp[spPtr]);
        }
      }
      // Parse flags (this logic is from core/languages/ConverterRule.php
      // in the parseFlags() function)
      if (flags.size === 0 && variants.size === 0) {
        flags.add('$S');
      } else if (flags.has('R')) {
        flags = new Set(['R']); // remove other flags
      } else if (flags.has('N')) {
        flags = new Set(['N']); // remove other flags
      } else if (flags.has('-')) {
        flags = new Set(['-']); // remove other flags
      } else if (flags.has('T') && flags.size === 1) {
        flags.add('H');
      } else if (flags.has('H')) {
        // Replace A flag, and remove other flags except T and D
        var nf = new Set(['$+', 'H']);
        if (flags.has('T')) { nf.add('T'); }
        if (flags.has('D')) { nf.add('D'); }
        flags = nf;
      } else if (variants.size > 0) {
        useVariants = true;
      } else {
        if (flags.has('A')) {
          flags.add('$+');
          flags.add('$S');
        }
        if (flags.has('D')) {
          flags.delete('$S');
        }
      }
      if (useVariants) {
        return { variants: variants, original: variantList, sp: variantSpace };
      } else {
        return { flags: flags, original: flagList, sp: flagSpace };
      }
    
  }
  function peg$a164(tokens) {
   return { tokens: tu.flattenStringlist(tokens), srcOffsets: [startOffset(), endOffset()] }; 
  }
  function peg$a165(o, oo) {
   return oo; 
  }
  function peg$a166(o, rest, tr) {
  
        var r = [ o ].concat(rest);
        // if the last bogus option is just spaces, keep them; otherwise
        // drop all this bogus stuff on the ground.
        if (tr.length && /^\s*$/.test(tr[tr.length - 1][1])) {
          r.push({ semi: true, sp: tr[tr.length - 1][1] });
        }
        return r;
      
  }
  function peg$a167(lvtext) {
   return [{ text: lvtext }]; 
  }
  function peg$a168(thTag, pp, tht) {
  
              // Avoid modifying a cached result
              tht = tht.slice();
              tht[0] = Util.clone(tht[0]);
  
              var da = tht[0].dataAttribs;
              da.stx = 'row';
              da.tsr[0] -= pp.length; // include "!!" or "||"
  
              if (pp !== "!!" || (da.startTagSrc && da.startTagSrc !== pp)) {
                  // Variation from default
                  da.startTagSrc = pp + (da.startTagSrc ? da.startTagSrc.substring(1) : '');
              }
              return tht;
            
  }
  function peg$a169(thTag, thTags) {
  
          thTag = thTag.slice();
          thTag[0] = Util.clone(thTag[0]);
          thTag[0].dataAttribs.tsr[0]--; // include "!"
          return thTag.concat(thTags);
      
  }
  function peg$a170(arg) {
   return endOffset(); 
  }
  function peg$a171(arg, tagEndPos, td) {
  
          return tu.buildTableTokens("td", "|", arg, [startOffset(), tagEndPos], endOffset(), td);
      
  }
  function peg$a172(pp, tdt) {
  
          // Avoid modifying a cached result
          tdt = tdt.slice();
          tdt[0] = Util.clone(tdt[0]);
  
          var da = tdt[0].dataAttribs;
          da.stx = "row";
          da.tsr[0] -= pp.length; // include "||"
          if (pp !== "||" || (da.startTagSrc && da.startTagSrc !== pp)) {
            // Variation from default
            da.startTagSrc = pp + (da.startTagSrc ? da.startTagSrc.substring(1) : '');
          }
          return tdt;
        
  }
  function peg$a173(b) {
  
          return b;
      
  }
  function peg$a174(c) {
  
        return tu.flattenStringlist(c);
      
  }
  function peg$a175(sp1, f, sp2, more) {
  
      var r = more && more[1] ? more[1] : { sp: [], flags: [] };
      // Note that sp and flags are in reverse order, since we're using
      // right recursion and want to push instead of unshift.
      r.sp.push(sp2);
      r.sp.push(sp1);
      r.flags.push(f);
      return r;
    
  }
  function peg$a176(sp) {
  
      return { sp: [ sp ], flags: [] };
    
  }
  function peg$a177(sp1, lang, sp2, sp3, lvtext) {
  
        return {
          twoway: true,
          lang: lang,
          text: lvtext,
          sp: [sp1, sp2, sp3]
        };
      
  }
  function peg$a178(sp1, from, sp2, lang, sp3, sp4, to) {
  
        return {
          oneway: true,
          from: from,
          lang: lang,
          to: to,
          sp: [sp1, sp2, sp3, sp4]
        };
      
  }
  function peg$a179(arg, tagEndPos, th, d) {
  
              if (th.get() !== false && /\n/.test(text())) {
                  // There's been a newline. Remove the break and continue
                  // tokenizing nested_block_in_tables.
                  th.set(false);
              }
              return d;
          
  }
  function peg$a180(arg, tagEndPos, c) {
  
          return tu.buildTableTokens("th", "!", arg, [startOffset(), tagEndPos], endOffset(), c);
      
  }
  function peg$a181(r) {
  
          return r;
      
  }
  function peg$a182(f) {
   return { flag: f }; 
  }
  function peg$a183(v) {
   return { variant: v }; 
  }
  function peg$a184(b) {
   return { bogus: b }; /* bad flag */
  }
  function peg$a185(n, sp) {
  
          return { tokens: [ n ], srcOffsets: [startOffset(), endOffset() - sp.length] };
      
  }
  function peg$a186(tbl) {
  
          return tbl;
      
  }
  function peg$a187(extToken) {
   return extToken.getAttribute('name') === 'nowiki'; 
  }
  function peg$a188(extToken) {
   return extToken; 
  }
  function peg$a189(extToken) {
  
      var txt = Util.extractExtBody(extToken);
      return Util.decodeWtEntities(txt);
    
  }

  // initializer
  
  
      var pegIncludes = options.pegIncludes;
      var pegTokenizer = options.pegTokenizer;
  
      var env = pegTokenizer.env;
      var pipelineOpts = pegTokenizer.options;
  
      var TokenUtils = pegIncludes.TokenUtils;
      var Util = pegIncludes.Util;
      var WTUtils = pegIncludes.WTUtils;
      var JSUtils = pegIncludes.JSUtils;
      var PegTokenizer = pegIncludes.PegTokenizer;
      var TokenTypes = pegIncludes.TokenTypes;
      var constants = pegIncludes.constants;
      var tu = pegIncludes.tu;
  
      // define some constructor shortcuts
      const { KV, TagTk, EndTagTk, SelfclosingTagTk, NlTk, EOFTk, CommentTk } = TokenTypes;
      var lastItem = JSUtils.lastItem;
  
      var inlineBreaks = tu.inlineBreaks;
  
      var prevOffset = 0;
      var headingIndex = 0;
  
      // Assertions are not safe in the tokenizer, since we catch exceptions
      // thrown and treat it as a "failed match" and backtrack.  Nobody ever
      // sees the assertion failure.  Work around this by using a special
      // assertion method for tokenizer code.
      var assert = function(condition, text) {
        if (condition) { return; }
        env.log('fatal', text || "Tokenizer assertion failure");
      };
  
      // Some shorthands for legibility
      var startOffset = function() {
        return peg$savedPos;
      };
      var endOffset = function() {
        return peg$currPos;
      };
      var tsrOffsets = function(flag) {
        return tu.tsrOffsets(peg$savedPos, peg$currPos, flag);
      };
  
      /*
       * Emit a chunk of tokens to our consumers.  Once this has been done, the
       * current expression can return an empty list (true).
       */
      var emitChunk = function(tokens) {
          if (env.immutable) {
              // Tokens placed in the tokenizer's cache have been frozen to
              // to catch any mutations while testing, which may have led to
              // subtle, spooky action at a distance.
              tokens = Util.unFreeze(tokens, true);
          }
  
          // Shift tsr of all tokens by the pipeline offset
          TokenUtils.shiftTokenTSR(tokens, options.pipelineOffset);
          env.log("trace/peg", pegTokenizer.pipelineId, "---->  ", tokens);
  
          var i;
          var n = tokens.length;
  
          // Enforce parsing resource limits
          for (i = 0; i < n; i++) {
              tu.enforceWt2HtmlResourceLimits(env, tokens[i]);
          }
  
          // limit the size of individual chunks
          var chunkLimit = 100000;
          if (n > chunkLimit) {
              i = 0;
              while (i < n) {
                  options.cb(tokens.slice(i, i + chunkLimit));
                  i += chunkLimit;
              }
          } else {
              options.cb(tokens);
          }
      };
  
      /* ------------------------------------------------------------------------
       * Extension tags should be parsed with higher priority than anything else.
       *
       * The trick we use is to strip out the content inside a matching tag-pair
       * and not tokenize it. The content, if it needs to parsed (for example,
       * for <ref>, <*include*> tags), is parsed in a fresh tokenizer context
       * which means any error correction that needs to happen is restricted to
       * the scope of the extension content and doesn't spill over to the higher
       * level.  Ex: <math><!--foo</math>.
       *
       * IGNORE: {{ this just balances the blocks in this comment for pegjs
       *
       * This trick also lets us prevent extension content (that don't accept WT)
       * from being parsed as wikitext (Ex: <math>\frac{foo\frac{bar}}</math>)
       * We don't want the "}}" being treated as a template closing tag and
       * closing outer templates.
       * --------------------------------------------------------------------- */
  
      var isXMLTag = function(name, block) {
          var uName = name.toUpperCase();
          return block
              ? TokenUtils.isBlockTag(uName)
              : constants.HTML.HTML5Tags.has(uName) || constants.HTML.OlderHTMLTags.has(uName);
      };
  
      var isExtTag = function(name) {
          var lName = name.toLowerCase();
          var isInstalledExt = env.conf.wiki.extConfig.tags.has(lName);
          var isIncludeTag = tu.isIncludeTag(lName);
          return isInstalledExt || isIncludeTag;
      };
  
      var maybeExtensionTag = function(t) {
          var tagName = t.name.toLowerCase();
  
          var isInstalledExt = env.conf.wiki.extConfig.tags.has(tagName);
          var isIncludeTag = tu.isIncludeTag(tagName);
  
          // Extensions have higher precedence when they shadow html tags.
          if (!(isInstalledExt || isIncludeTag)) {
              return t;
          }
  
          var dp = t.dataAttribs;
          var skipPos = peg$currPos;
  
          switch (t.constructor) {
          case EndTagTk:
              if (isIncludeTag) {
                  return t;
              }
              // Similar to TagTk, we rely on the sanitizer to convert to text
              // where necessary and emit tokens to ease the wikitext escaping
              // code.  However, extension tags that shadow html tags will see
              // their unmatched end tags dropped while tree building, since
              // the sanitizer will let them through.
              return t;  // not text()
          case SelfclosingTagTk:
              dp.src = input.substring(dp.tsr[0], dp.tsr[1]);
              dp.extTagOffsets = [dp.tsr[0], dp.tsr[1], dp.tsr[1] - dp.tsr[0], 0];
              if (isIncludeTag) {
                  return t;
              }
              break;
          case TagTk:
              var endTagRE = new RegExp("^[\\s\\S]*?(</" + tagName + "\\s*>)", "i");
              var restOfInput = input.substring(dp.tsr[0]);
              var tagContent = restOfInput.match(endTagRE);
  
              if (!tagContent) {
                  dp.src = input.substring(dp.tsr[0], dp.tsr[1]);
                  dp.extTagOffsets = [dp.tsr[0], dp.tsr[1], dp.tsr[1] - dp.tsr[0], 0];
                  if (isIncludeTag) {
                      return t;
                  } else {
                      // This is undefined behaviour.  The php parser currently
                      // returns text here (see core commit 674e8388cba),
                      // whereas this results in unclosed
                      // extension tags that shadow html tags falling back to
                      // their html equivalent.  The sanitizer will take care
                      // of converting to text where necessary.  We do this to
                      // simplify `hasWikitextTokens` when escaping wikitext,
                      // which wants these as tokens because it's otherwise
                      // lacking in context.
                      return t;  // not text()
                  }
              }
  
              var extSrc = tagContent[0];
              var extEndOffset = dp.tsr[0] + extSrc.length;
              var extEndTagWidth = tagContent[1].length;
  
              if (pipelineOpts.inTemplate) {
                  // Support 1-level of nesting in extensions tags while
                  // tokenizing in templates to support the #tag parser function.
                  //
                  // It's necessary to permit this broadly in templates because
                  // there's no way to distinguish whether the nesting happened
                  // while expanding the #tag parser function, or just a general
                  // syntax errors.  In other words,
                  //
                  //   hi<ref>ho<ref>hi</ref>ho</ref>
                  //
                  // and
                  //
                  //   hi{{#tag:ref|ho<ref>hi</ref>ho}}
                  //
                  // found in template are returned indistinguishably after a
                  // preprocessing request, though the php parser renders them
                  // differently.  #tag in template is probably a common enough
                  // use case that we want to accept these false positives,
                  // though another approach could be to drop this code here, and
                  // invoke a native #tag handler and forgo those in templates.
                  //
                  // Expand `extSrc` as long as there is a <tagName> found in the
                  // extension source body.
                  var s = extSrc.substring(dp.tsr[1] - dp.tsr[0]);
                  while (s && s.match(new RegExp("<" + tagName + "[^/<>]*>", "i"))) {
                      tagContent = restOfInput.substring(extSrc.length).match(endTagRE);
                      if (tagContent) {
                          s = tagContent[0];
                          extEndOffset += s.length;
                          extEndTagWidth = tagContent[1].length;
                          extSrc += s;
                      } else {
                          s = null;
                      }
                  }
              }
  
              // Extension content source
              dp.src = extSrc;
              dp.extTagOffsets = [dp.tsr[0], extEndOffset, dp.tsr[1] - dp.tsr[0], extEndTagWidth];
  
              skipPos = extEndOffset - extEndTagWidth;
  
              // If the xml-tag is a known installed (not native) extension,
              // skip the end-tag as well.
              if (isInstalledExt) {
                  skipPos = extEndOffset;
              }
              break;
          default:
              assert(false, 'Should not be reachable.');
          }
  
          peg$currPos = skipPos;
  
          if (isInstalledExt) {
              // update tsr[1] to span the start and end tags.
              dp.tsr[1] = endOffset();  // was just modified above
              return new SelfclosingTagTk('extension', [
                  new KV('typeof', 'mw:Extension'),
                  new KV('name', tagName),
                  new KV('about', env.newAboutId()),
                  new KV('source', dp.src),
                  new KV('options', t.attribs),
              ], dp);
          } else if (isIncludeTag) {
              // Parse ext-content, strip eof, and shift tsr
              var extContent = dp.src.slice(dp.extTagOffsets[2], -dp.extTagOffsets[3]);
              var tokenizer = new PegTokenizer(env);
              var innerStart = dp.extTagOffsets[0] + dp.extTagOffsets[2];
              var innerEnd = dp.extTagOffsets[1] - dp.extTagOffsets[3];
              tokenizer.setSourceOffsets(innerStart, innerEnd);
              var extContentToks = tokenizer.tokenizeSync(extContent);
              if (dp.extTagOffsets[3] > 0) {
                  extContentToks = TokenUtils.stripEOFTkfromTokens(extContentToks);
              }
              return [t].concat(extContentToks);
          } else {
              assert(false, 'Should not be reachable.');
          }
      };
  

  // generated
  function* peg$streamstart_async(silence, param_preproc) {
    var r1,p2,r3,r4;
    for (;;) {
      choice_1: {
      r1 = peg$parsetlb(silence, param_preproc);
      if (r1!==peg$FAILED) {
        break choice_1;
      }
      seq_1: {
      p2 = peg$currPos;
      r3 = [];
      for (;;) {
        r4 = peg$parsenewlineToken(silence);
        if (r4!==peg$FAILED) {
          r3.push(r4);
        } else {
          break;
        }
      }
      // free r4
      peg$savedPos = peg$currPos;
      r4 = peg$a0();
      if (r4) {
        r4 = void 0;
      } else {
        r4 = peg$FAILED;
        peg$currPos = p2;
        r1 = peg$FAILED;
        break seq_1;
      }
      r1 = [r3,r4];
      } // seq_1
      // free p2
      } // choice_1
      if (r1!==peg$FAILED) {
        yield r1;
      } else {
        if (peg$currPos < input.length) {
          peg$fail(peg$c0);
          throw peg$buildParseException();
        }
        break;
      }
    }
  }
  function peg$parsestart(silence, param_preproc) {
    var r1,p2,p3,r4,r5;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [284, param_preproc.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    for (;;) {
      r5 = peg$discardtlb(true, param_preproc);
      if (r5===peg$FAILED) {
        break;
      }
    }
    // free r5
    r4 = true;
    if (r4===peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    // free r4
    for (;;) {
      r5 = peg$discardnewlineToken(true);
      if (r5===peg$FAILED) {
        break;
      }
    }
    // free r5
    r4 = true;
    if (r4===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free r4
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a1();
    } else {
      if (!silence) {peg$fail(peg$c1);}
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
    }
    return r1;
  }
  function peg$parsetable_start_tag(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,p6,r7,r8,r9,r10,p11,r12,r13;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [468, boolParams & 0x3bef, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = [];
    for (;;) {
      choice_1: {
      r5 = peg$parsespace(true);
      if (r5!==peg$FAILED) {
        break choice_1;
      }
      r5 = peg$parsecomment(true);
      } // choice_1
      if (r5!==peg$FAILED) {
        r4.push(r5);
      } else {
        break;
      }
    }
    // sc <- r4
    // free r5
    p6 = peg$currPos;
    r5 = '';
    // startPos <- r5
    if (r5!==peg$FAILED) {
      peg$savedPos = p6;
      r5 = peg$a2(r4);
    } else {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // b <- r7
    if (input.charCodeAt(peg$currPos) === 123) {
      r7 = "{";
      peg$currPos += 1;
    } else {
      r7 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r8 = peg$parsepipe(true);
    // p <- r8
    if (r8===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    choice_2: {
    r9 = peg$parsetable_attributes(true, boolParams & ~0x10, param_templatedepth, param_preproc, param_th);
    if (r9!==peg$FAILED) {
      break choice_2;
    }
    peg$savedPos = peg$currPos;
    r9 = peg$a3(r4, r5, r7, r8);
    if (r9) {
      r9 = void 0;
    } else {
      r9 = peg$FAILED;
    }
    } // choice_2
    // ta <- r9
    if (r9===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p11 = peg$currPos;
    r10 = '';
    // tsEndPos <- r10
    if (r10!==peg$FAILED) {
      peg$savedPos = p11;
      r10 = peg$a4(r4, r5, r7, r8, r9);
    } else {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r12 = [];
    for (;;) {
      r13 = peg$parsespace(true);
      if (r13!==peg$FAILED) {
        r12.push(r13);
      } else {
        break;
      }
    }
    // s2 <- r12
    // free r13
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a5(r4, r5, r7, r8, r9, r10, r12);
    } else {
      if (!silence) {peg$fail(peg$c2);}
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parseurl(silence, param_preproc) {
    var r1,p2,p3,r4,r5,r6,r7,p8,p9,p10,r11,r12,r13,p14,p15,r16,p17,r18,r19,p20,r21,r22,r23,r24,r25,r26,r27,r28;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [340, param_preproc.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = peg$parseurl_protocol(true);
    // proto <- r4
    if (r4===peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    choice_1: {
    r5 = peg$parseurladdr(true);
    if (r5!==peg$FAILED) {
      break choice_1;
    }
    r5 = '';
    } // choice_1
    // addr <- r5
    if (r5===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r6 = [];
    for (;;) {
      choice_2: {
      p8 = peg$currPos;
      seq_2: {
      p9 = peg$currPos;
      p10 = peg$currPos;
      r11 = peg$discardinline_breaks(true, 0x0, 0, param_preproc, new peg$Reference(null));
      if (r11 === peg$FAILED) {
        r11 = void 0;
      } else {
        r11 = peg$FAILED;
        peg$currPos = p10;
        r7 = peg$FAILED;
        break seq_2;
      }
      // free p10
      r12 = peg$parseno_punctuation_char(true);
      // c <- r12
      if (r12===peg$FAILED) {
        peg$currPos = p9;
        r7 = peg$FAILED;
        break seq_2;
      }
      r7 = true;
      } // seq_2
      if (r7!==peg$FAILED) {
        peg$savedPos = p8;
        r7 = peg$a6(r4, r5, r12);
        break choice_2;
      }
      // free p9
      p9 = peg$currPos;
      r13 = input.charAt(peg$currPos);
      // s <- r13
      if (/^[.:,']/.test(r13)) {
        peg$currPos++;
      } else {
        r13 = peg$FAILED;
      }
      r7 = r13;
      if (r7!==peg$FAILED) {
        peg$savedPos = p9;
        r7 = peg$a7(r4, r5, r13);
        break choice_2;
      }
      r7 = peg$parsecomment(true);
      if (r7!==peg$FAILED) {
        break choice_2;
      }
      r7 = peg$parsetplarg_or_template(true, 0x0, 0, new peg$Reference(null), param_preproc);
      if (r7!==peg$FAILED) {
        break choice_2;
      }
      p10 = peg$currPos;
      seq_3: {
      p14 = peg$currPos;
      p15 = peg$currPos;
      seq_4: {
      p17 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 38) {
        r18 = "&";
        peg$currPos += 1;
      } else {
        r18 = peg$FAILED;
        r16 = peg$FAILED;
        break seq_4;
      }
      choice_3: {
      seq_5: {
      p20 = peg$currPos;
      r21 = input.charAt(peg$currPos);
      if (/^[lL]/.test(r21)) {
        peg$currPos++;
      } else {
        r21 = peg$FAILED;
        r19 = peg$FAILED;
        break seq_5;
      }
      r22 = input.charAt(peg$currPos);
      if (/^[tT]/.test(r22)) {
        peg$currPos++;
      } else {
        r22 = peg$FAILED;
        peg$currPos = p20;
        r19 = peg$FAILED;
        break seq_5;
      }
      r19 = true;
      } // seq_5
      if (r19!==peg$FAILED) {
        break choice_3;
      }
      // free p20
      seq_6: {
      p20 = peg$currPos;
      r23 = input.charAt(peg$currPos);
      if (/^[gG]/.test(r23)) {
        peg$currPos++;
      } else {
        r23 = peg$FAILED;
        r19 = peg$FAILED;
        break seq_6;
      }
      r24 = input.charAt(peg$currPos);
      if (/^[tT]/.test(r24)) {
        peg$currPos++;
      } else {
        r24 = peg$FAILED;
        peg$currPos = p20;
        r19 = peg$FAILED;
        break seq_6;
      }
      r19 = true;
      } // seq_6
      // free p20
      } // choice_3
      if (r19===peg$FAILED) {
        peg$currPos = p17;
        r16 = peg$FAILED;
        break seq_4;
      }
      if (input.charCodeAt(peg$currPos) === 59) {
        r25 = ";";
        peg$currPos += 1;
      } else {
        r25 = peg$FAILED;
        peg$currPos = p17;
        r16 = peg$FAILED;
        break seq_4;
      }
      r16 = true;
      } // seq_4
      // free p17
      if (r16 === peg$FAILED) {
        r16 = void 0;
      } else {
        r16 = peg$FAILED;
        peg$currPos = p15;
        r7 = peg$FAILED;
        break seq_3;
      }
      // free p15
      choice_4: {
      p15 = peg$currPos;
      seq_7: {
      p17 = peg$currPos;
      p20 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 38) {
        r27 = "&";
        peg$currPos += 1;
        r27 = void 0;
        peg$currPos = p20;
      } else {
        r27 = peg$FAILED;
        r26 = peg$FAILED;
        break seq_7;
      }
      // free p20
      r28 = peg$parsehtmlentity(true);
      // he <- r28
      if (r28===peg$FAILED) {
        peg$currPos = p17;
        r26 = peg$FAILED;
        break seq_7;
      }
      r26 = true;
      } // seq_7
      if (r26!==peg$FAILED) {
        peg$savedPos = p15;
        r26 = peg$a8(r4, r5, r28);
        break choice_4;
      }
      // free p17
      r26 = input.charAt(peg$currPos);
      if (/^[&%{]/.test(r26)) {
        peg$currPos++;
      } else {
        r26 = peg$FAILED;
      }
      } // choice_4
      // r <- r26
      if (r26===peg$FAILED) {
        peg$currPos = p14;
        r7 = peg$FAILED;
        break seq_3;
      }
      r7 = true;
      } // seq_3
      if (r7!==peg$FAILED) {
        peg$savedPos = p10;
        r7 = peg$a9(r4, r5, r26);
      }
      // free p14
      } // choice_2
      if (r7!==peg$FAILED) {
        r6.push(r7);
      } else {
        break;
      }
    }
    // path <- r6
    // free r7
    peg$savedPos = peg$currPos;
    r7 = peg$a10(r4, r5, r6);
    if (r7) {
      r7 = void 0;
    } else {
      r7 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a11(r4, r5, r6);
    } else {
      if (!silence) {peg$fail(peg$c3);}
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
    }
    return r1;
  }
  function peg$parserow_syntax_table_args(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,r6,p7,r8;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [488, boolParams & 0x3bbf, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = peg$parsetable_attributes(silence, boolParams | 0x40, param_templatedepth, param_preproc, param_th);
    // as <- r4
    if (r4===peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    r5 = peg$parseoptional_spaces(silence);
    // s <- r5
    if (r5===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r6 = peg$parsepipe(silence);
    // p <- r6
    if (r6===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p7 = peg$currPos;
    r8 = peg$discardpipe(true);
    if (r8 === peg$FAILED) {
      r8 = void 0;
    } else {
      r8 = peg$FAILED;
      peg$currPos = p7;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p7
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a12(r4, r5, r6);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsetable_attributes(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,r2,p3,p4,r5,r6;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [290, boolParams & 0x3bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    r1 = [];
    for (;;) {
      choice_1: {
      r2 = peg$parsetable_attribute(true, boolParams, param_templatedepth, param_preproc, param_th);
      if (r2!==peg$FAILED) {
        break choice_1;
      }
      p3 = peg$currPos;
      seq_1: {
      p4 = peg$currPos;
      r5 = peg$discardoptionalSpaceToken(true);
      if (r5===peg$FAILED) {
        r2 = peg$FAILED;
        break seq_1;
      }
      r6 = peg$parsebroken_table_attribute_name_char(true);
      // b <- r6
      if (r6===peg$FAILED) {
        peg$currPos = p4;
        r2 = peg$FAILED;
        break seq_1;
      }
      r2 = true;
      } // seq_1
      if (r2!==peg$FAILED) {
        peg$savedPos = p3;
        r2 = peg$a13(r6);
      }
      // free p4
      } // choice_1
      if (r2!==peg$FAILED) {
        r1.push(r2);
      } else {
        break;
      }
    }
    // free r2
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsegeneric_newline_attributes(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,r2;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [288, boolParams & 0x3bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    r1 = [];
    for (;;) {
      r2 = peg$parsegeneric_newline_attribute(true, boolParams, param_templatedepth, param_preproc, param_th);
      if (r2!==peg$FAILED) {
        r1.push(r2);
      } else {
        break;
      }
    }
    // free r2
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsetplarg_or_template_or_bust(silence, param_preproc) {
    var r1,p2,r3,r4;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [350, param_preproc.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    r3 = [];
    for (;;) {
      choice_1: {
      r4 = peg$parsetplarg_or_template(true, 0x0, 0, new peg$Reference(null), param_preproc);
      if (r4!==peg$FAILED) {
        break choice_1;
      }
      if (peg$currPos < input.length) {
        r4 = input.charAt(peg$currPos++);
      } else {
        r4 = peg$FAILED;
      }
      } // choice_1
      if (r4!==peg$FAILED) {
        r3.push(r4);
      } else {
        break;
      }
    }
    if (r3.length === 0) {
      r3 = peg$FAILED;
    }
    // r <- r3
    // free r4
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a14(r3);
    } else {
      if (!silence) {peg$fail(peg$c6);}
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
    }
    return r1;
  }
  function peg$parseextlink(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,p6,p7,r8,r9,p10,r11,p12,r13,r14,r15,r16,r17,r18,p19,r20,r21,r22,p23,r24;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [330, boolParams & 0x3bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    if (!(/*extlink*/(boolParams & 0x4) !== 0)) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    p6 = peg$currPos;
    seq_2: {
    p7 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 91) {
      r8 = "[";
      peg$currPos += 1;
    } else {
      r8 = peg$FAILED;
      r5 = peg$FAILED;
      break seq_2;
    }
    p10 = peg$currPos;
    r9 = '';
    // p0 <- r9
    if (r9!==peg$FAILED) {
      peg$savedPos = p10;
      r9 = peg$a15();
    } else {
      peg$currPos = p7;
      r5 = peg$FAILED;
      break seq_2;
    }
    choice_1: {
    seq_3: {
    p12 = peg$currPos;
    r13 = peg$parseurl_protocol(true);
    if (r13===peg$FAILED) {
      r11 = peg$FAILED;
      break seq_3;
    }
    r14 = peg$parseurladdr(true);
    if (r14===peg$FAILED) {
      peg$currPos = p12;
      r11 = peg$FAILED;
      break seq_3;
    }
    r11 = [r13,r14];
    } // seq_3
    if (r11!==peg$FAILED) {
      break choice_1;
    }
    // free p12
    r11 = '';
    } // choice_1
    // addr <- r11
    if (r11===peg$FAILED) {
      peg$currPos = p7;
      r5 = peg$FAILED;
      break seq_2;
    }
    choice_2: {
    r15 = peg$parseextlink_preprocessor_text(true, boolParams | 0x4, param_templatedepth, param_preproc, param_th);
    if (r15!==peg$FAILED) {
      break choice_2;
    }
    r15 = '';
    } // choice_2
    // target <- r15
    if (r15===peg$FAILED) {
      peg$currPos = p7;
      r5 = peg$FAILED;
      break seq_2;
    }
    p12 = peg$currPos;
    r16 = '';
    // p1 <- r16
    if (r16!==peg$FAILED) {
      peg$savedPos = p12;
      r16 = peg$a16(r9, r11, r15);
    } else {
      peg$currPos = p7;
      r5 = peg$FAILED;
      break seq_2;
    }
    peg$savedPos = peg$currPos;
    r17 = peg$a17(r9, r11, r15, r16);
    if (r17) {
      r17 = void 0;
    } else {
      r17 = peg$FAILED;
      peg$currPos = p7;
      r5 = peg$FAILED;
      break seq_2;
    }
    p19 = peg$currPos;
    for (;;) {
      choice_3: {
      r20 = peg$discardspace(true);
      if (r20!==peg$FAILED) {
        break choice_3;
      }
      r20 = peg$discardunispace(true);
      } // choice_3
      if (r20===peg$FAILED) {
        break;
      }
    }
    // free r20
    r18 = true;
    // sp <- r18
    if (r18!==peg$FAILED) {
      r18 = input.substring(p19, peg$currPos);
    } else {
      r18 = peg$FAILED;
      peg$currPos = p7;
      r5 = peg$FAILED;
      break seq_2;
    }
    // free p19
    p19 = peg$currPos;
    r20 = '';
    // p2 <- r20
    if (r20!==peg$FAILED) {
      peg$savedPos = p19;
      r20 = peg$a18(r9, r11, r15, r16, r18);
    } else {
      peg$currPos = p7;
      r5 = peg$FAILED;
      break seq_2;
    }
    r21 = peg$parseinlineline(true, boolParams | 0x4, param_templatedepth, param_preproc, param_th);
    if (r21===peg$FAILED) {
      r21 = null;
    }
    // content <- r21
    p23 = peg$currPos;
    r22 = '';
    // p3 <- r22
    if (r22!==peg$FAILED) {
      peg$savedPos = p23;
      r22 = peg$a19(r9, r11, r15, r16, r18, r20, r21);
    } else {
      peg$currPos = p7;
      r5 = peg$FAILED;
      break seq_2;
    }
    if (input.charCodeAt(peg$currPos) === 93) {
      r24 = "]";
      peg$currPos += 1;
    } else {
      r24 = peg$FAILED;
      peg$currPos = p7;
      r5 = peg$FAILED;
      break seq_2;
    }
    r5 = true;
    } // seq_2
    // r <- r5
    if (r5!==peg$FAILED) {
      peg$savedPos = p6;
      r5 = peg$a20(r9, r11, r15, r16, r18, r20, r21, r22);
    } else {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p7
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a21(r5);
    } else {
      if (!silence) {peg$fail(peg$c7);}
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsetlb(silence, param_preproc) {
    var r1,p2,p3,p4,r5,r6;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [296, param_preproc.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p4 = peg$currPos;
    r5 = peg$discardeof(true);
    if (r5 === peg$FAILED) {
      r5 = void 0;
    } else {
      r5 = peg$FAILED;
      peg$currPos = p4;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p4
    r6 = peg$parseblock(true, 0x0, 0, new peg$Reference(null), param_preproc);
    // b <- r6
    if (r6===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a22(r6);
    } else {
      if (!silence) {peg$fail(peg$c8);}
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
    }
    return r1;
  }
  function peg$parsenewlineToken(silence) {
    var r1,p2;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 538;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    r1 = peg$discardnewline(silence);
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a23();
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$discardtlb(silence, param_preproc) {
    var r1,p2,p3,p4,r5,r6;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [297, param_preproc.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p4 = peg$currPos;
    r5 = peg$discardeof(true);
    if (r5 === peg$FAILED) {
      r5 = void 0;
    } else {
      r5 = peg$FAILED;
      peg$currPos = p4;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p4
    r6 = peg$parseblock(true, 0x0, 0, new peg$Reference(null), param_preproc);
    // b <- r6
    if (r6===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a22(r6);
    } else {
      if (!silence) {peg$fail(peg$c8);}
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
    }
    return r1;
  }
  function peg$discardnewlineToken(silence) {
    var r1,p2;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 539;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    r1 = peg$discardnewline(silence);
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a23();
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parsespace(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 502;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    r1 = input.charAt(peg$currPos);
    if (/^[ \t]/.test(r1)) {
      peg$currPos++;
    } else {
      r1 = peg$FAILED;
      if (!silence) {peg$fail(peg$c9);}
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parsecomment(silence) {
    var r1,p2,p3,r4,r5,p6,r7,p8,p9,r10,r11;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 322;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = input.substr(peg$currPos,4);
    if (r4 === "<!--") {
      peg$currPos += 4;
    } else {
      if (!silence) {peg$fail(peg$c10);}
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    p6 = peg$currPos;
    for (;;) {
      seq_2: {
      p8 = peg$currPos;
      p9 = peg$currPos;
      r10 = input.substr(peg$currPos,3);
      if (r10 === "-->") {
        peg$currPos += 3;
      } else {
        r10 = peg$FAILED;
      }
      if (r10 === peg$FAILED) {
        r10 = void 0;
      } else {
        r10 = peg$FAILED;
        peg$currPos = p9;
        r7 = peg$FAILED;
        break seq_2;
      }
      // free p9
      if (peg$currPos < input.length) {
        r11 = input.charAt(peg$currPos++);
      } else {
        r11 = peg$FAILED;
        if (!silence) {peg$fail(peg$c11);}
        peg$currPos = p8;
        r7 = peg$FAILED;
        break seq_2;
      }
      r7 = true;
      } // seq_2
      if (r7===peg$FAILED) {
        break;
      }
      // free p8
    }
    // free r7
    r5 = true;
    // c <- r5
    if (r5!==peg$FAILED) {
      r5 = input.substring(p6, peg$currPos);
    } else {
      r5 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p6
    choice_1: {
    r7 = input.substr(peg$currPos,3);
    if (r7 === "-->") {
      peg$currPos += 3;
      break choice_1;
    } else {
      if (!silence) {peg$fail(peg$c12);}
      r7 = peg$FAILED;
    }
    r7 = peg$discardeof(silence);
    } // choice_1
    if (r7===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a24(r5);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parsepipe(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 564;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    if (input.charCodeAt(peg$currPos) === 124) {
      r1 = "|";
      peg$currPos += 1;
      break choice_1;
    } else {
      if (!silence) {peg$fail(peg$c13);}
      r1 = peg$FAILED;
    }
    r1 = input.substr(peg$currPos,5);
    if (r1 === "{{!}}") {
      peg$currPos += 5;
    } else {
      if (!silence) {peg$fail(peg$c14);}
      r1 = peg$FAILED;
    }
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parseurl_protocol(silence) {
    var r1,p2,p3,r4,r5,p6,p7,r8,r9,r10;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 336;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    peg$savedPos = peg$currPos;
    r4 = peg$a25();
    if (r4) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    p6 = peg$currPos;
    choice_1: {
    r5 = input.substr(peg$currPos,2);
    if (r5 === "//") {
      peg$currPos += 2;
      break choice_1;
    } else {
      if (!silence) {peg$fail(peg$c15);}
      r5 = peg$FAILED;
    }
    seq_2: {
    p7 = peg$currPos;
    r8 = input.charAt(peg$currPos);
    if (/^[A-Za-z]/.test(r8)) {
      peg$currPos++;
    } else {
      r8 = peg$FAILED;
      if (!silence) {peg$fail(peg$c16);}
      r5 = peg$FAILED;
      break seq_2;
    }
    for (;;) {
      r10 = input.charAt(peg$currPos);
      if (/^[\-A-Za-z0-9+.]/.test(r10)) {
        peg$currPos++;
      } else {
        r10 = peg$FAILED;
        if (!silence) {peg$fail(peg$c17);}
        break;
      }
    }
    // free r10
    r9 = true;
    if (r9===peg$FAILED) {
      peg$currPos = p7;
      r5 = peg$FAILED;
      break seq_2;
    }
    // free r9
    if (input.charCodeAt(peg$currPos) === 58) {
      r9 = ":";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c18);}
      r9 = peg$FAILED;
      peg$currPos = p7;
      r5 = peg$FAILED;
      break seq_2;
    }
    r10 = input.substr(peg$currPos,2);
    if (r10 === "//") {
      peg$currPos += 2;
    } else {
      if (!silence) {peg$fail(peg$c15);}
      r10 = peg$FAILED;
      r10 = null;
    }
    r5 = true;
    } // seq_2
    // free p7
    } // choice_1
    // p <- r5
    if (r5!==peg$FAILED) {
      r5 = input.substring(p6, peg$currPos);
    } else {
      r5 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p6
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a26(r5);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parseurladdr(silence) {
    var p1,r2,p3,r4,r5,r6;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 344;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    p1 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 91) {
      r4 = "[";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c19);}
      r4 = peg$FAILED;
      r2 = peg$FAILED;
      break seq_1;
    }
    r5 = peg$FAILED;
    for (;;) {
      r6 = input.charAt(peg$currPos);
      if (/^[0-9A-Fa-f:.]/.test(r6)) {
        peg$currPos++;
        r5 = true;
      } else {
        r6 = peg$FAILED;
        if (!silence) {peg$fail(peg$c20);}
        break;
      }
    }
    if (r5===peg$FAILED) {
      peg$currPos = p3;
      r2 = peg$FAILED;
      break seq_1;
    }
    // free r6
    if (input.charCodeAt(peg$currPos) === 93) {
      r6 = "]";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c21);}
      r6 = peg$FAILED;
      peg$currPos = p3;
      r2 = peg$FAILED;
      break seq_1;
    }
    r2 = true;
    } // seq_1
    if (r2!==peg$FAILED) {
      r2 = input.substring(p1, peg$currPos);
    } else {
      r2 = peg$FAILED;
    }
    // free p3
    // free p1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r2,
      };
  
    }
    return r2;
  }
  function peg$discardinline_breaks(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var p1,r2,p3,r4,r5,r6;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [315, boolParams & 0x1bfe, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    seq_1: {
    p1 = peg$currPos;
    p3 = peg$currPos;
    r4 = input.charAt(peg$currPos);
    if (/^[=|!{}:;\r\n[\]\-]/.test(r4)) {
      peg$currPos++;
      r4 = void 0;
      peg$currPos = p3;
    } else {
      r4 = peg$FAILED;
      r2 = peg$FAILED;
      break seq_1;
    }
    // free p3
    seq_2: {
    p3 = peg$currPos;
    peg$savedPos = peg$currPos;
    r6 = peg$a27(/*extTag*/(boolParams & 0x800) !== 0, /*h*/(boolParams & 0x2) !== 0, /*extlink*/(boolParams & 0x4) !== 0, param_templatedepth, param_preproc.value, /*equal*/(boolParams & 0x8) !== 0, /*table*/(boolParams & 0x10) !== 0, /*templateArg*/(boolParams & 0x20) !== 0, /*tableCellArg*/(boolParams & 0x40) !== 0, /*semicolon*/(boolParams & 0x80) !== 0, /*arrow*/(boolParams & 0x100) !== 0, /*linkdesc*/(boolParams & 0x200) !== 0, /*colon*/(boolParams & 0x1000) !== 0, param_th.value);
    if (r6) {
      r6 = void 0;
    } else {
      r6 = peg$FAILED;
      peg$currPos = p3;
      r5 = peg$FAILED;
      break seq_2;
    }
    r5 = true;
    } // seq_2
    if (r5===peg$FAILED) {
      peg$currPos = p1;
      r2 = peg$FAILED;
      break seq_1;
    }
    // free r5,p3
    r2 = true;
    } // seq_1
    // free r2,p1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r2,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r2;
  }
  function peg$parseno_punctuation_char(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 338;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    r1 = input.charAt(peg$currPos);
    if (/^[^ :\][\r\n"'<>\0- ,.&%\xA0\u1680\u180E\u2000-\u200A\u202F\u205F\u3000{]/.test(r1)) {
      peg$currPos++;
    } else {
      r1 = peg$FAILED;
      if (!silence) {peg$fail(peg$c22);}
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parsetplarg_or_template(silence, boolParams, param_templatedepth, param_th, param_preproc) {
    var r1,p2,p3,p4,r5,r6,r7;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [346, boolParams & 0x3bff, param_templatedepth, param_th.value, param_preproc.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
        return cached.result;
      }
        var saved_th=param_th.value;
        var saved_preproc=param_preproc.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p4 = peg$currPos;
    r5 = input.substr(peg$currPos,2);
    if (r5 === "{{") {
      peg$currPos += 2;
      r5 = void 0;
      peg$currPos = p4;
    } else {
      r5 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p4
    peg$savedPos = peg$currPos;
    r6 = peg$a28(param_templatedepth);
    if (r6) {
      r6 = void 0;
    } else {
      r6 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r7 = peg$parsetplarg_or_template_guarded(silence, boolParams, param_templatedepth + 1, param_th, param_preproc);
    // t <- r7
    if (r7===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a29(param_templatedepth, r7);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_th !== param_th.value) cached.$th = param_th.value;
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
    }
    return r1;
  }
  function peg$parsehtmlentity(silence) {
    var r1,p2,r3;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 496;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    r3 = peg$parseraw_htmlentity(silence);
    // cc <- r3
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a30(r3);
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parseoptional_spaces(silence) {
    var p1,r2,r3;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 500;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    p1 = peg$currPos;
    for (;;) {
      r3 = input.charAt(peg$currPos);
      if (/^[ \t]/.test(r3)) {
        peg$currPos++;
      } else {
        r3 = peg$FAILED;
        if (!silence) {peg$fail(peg$c9);}
        break;
      }
    }
    // free r3
    r2 = true;
    if (r2!==peg$FAILED) {
      r2 = input.substring(p1, peg$currPos);
    } else {
      r2 = peg$FAILED;
    }
    // free p1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r2,
      };
  
    }
    return r2;
  }
  function peg$discardpipe(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 565;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    if (input.charCodeAt(peg$currPos) === 124) {
      r1 = "|";
      peg$currPos += 1;
      break choice_1;
    } else {
      if (!silence) {peg$fail(peg$c13);}
      r1 = peg$FAILED;
    }
    r1 = input.substr(peg$currPos,5);
    if (r1 === "{{!}}") {
      peg$currPos += 5;
    } else {
      if (!silence) {peg$fail(peg$c14);}
      r1 = peg$FAILED;
    }
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parsetable_attribute(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,p6,r7,r8,p9,r10,p11,p12,r13,r14,r15;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [434, boolParams & 0x3bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = peg$parseoptionalSpaceToken(silence);
    // s <- r4
    if (r4===peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    p6 = peg$currPos;
    r5 = '';
    // namePos0 <- r5
    if (r5!==peg$FAILED) {
      peg$savedPos = p6;
      r5 = peg$a31(r4);
    } else {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r7 = peg$parsetable_attribute_name(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // name <- r7
    if (r7===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p9 = peg$currPos;
    r8 = '';
    // namePos <- r8
    if (r8!==peg$FAILED) {
      peg$savedPos = p9;
      r8 = peg$a32(r4, r5, r7);
    } else {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p11 = peg$currPos;
    seq_2: {
    p12 = peg$currPos;
    r13 = peg$discardoptionalSpaceToken(silence);
    if (r13===peg$FAILED) {
      r10 = peg$FAILED;
      break seq_2;
    }
    if (input.charCodeAt(peg$currPos) === 61) {
      r14 = "=";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c23);}
      r14 = peg$FAILED;
      peg$currPos = p12;
      r10 = peg$FAILED;
      break seq_2;
    }
    r15 = peg$parsetable_att_value(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r15===peg$FAILED) {
      r15 = null;
    }
    // v <- r15
    r10 = true;
    } // seq_2
    if (r10!==peg$FAILED) {
      peg$savedPos = p11;
      r10 = peg$a33(r4, r5, r7, r8, r15);
    } else {
      r10 = null;
    }
    // free p12
    // vd <- r10
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a34(r4, r5, r7, r8, r10);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$discardoptionalSpaceToken(silence) {
    var r1,p2,r3;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 505;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    r3 = peg$parseoptional_spaces(silence);
    // s <- r3
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a35(r3);
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parsebroken_table_attribute_name_char(silence) {
    var r1,p2,r3;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 440;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    r3 = input.charAt(peg$currPos);
    // c <- r3
    if (/^[\0\/=>]/.test(r3)) {
      peg$currPos++;
    } else {
      r3 = peg$FAILED;
      if (!silence) {peg$fail(peg$c24);}
    }
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a36(r3);
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parsegeneric_newline_attribute(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,p6,r7,p8,r9,p10,p11,r12,r13;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [432, boolParams & 0x3bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    for (;;) {
      r5 = peg$discardspace_or_newline_or_solidus(silence);
      if (r5===peg$FAILED) {
        break;
      }
    }
    // free r5
    r4 = true;
    if (r4===peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    // free r4
    p6 = peg$currPos;
    r4 = '';
    // namePos0 <- r4
    if (r4!==peg$FAILED) {
      peg$savedPos = p6;
      r4 = peg$a15();
    } else {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r5 = peg$parsegeneric_attribute_name(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // name <- r5
    if (r5===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p8 = peg$currPos;
    r7 = '';
    // namePos <- r7
    if (r7!==peg$FAILED) {
      peg$savedPos = p8;
      r7 = peg$a37(r4, r5);
    } else {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p10 = peg$currPos;
    seq_2: {
    p11 = peg$currPos;
    for (;;) {
      r13 = peg$discardspace_or_newline(silence);
      if (r13===peg$FAILED) {
        break;
      }
    }
    // free r13
    r12 = true;
    if (r12===peg$FAILED) {
      r9 = peg$FAILED;
      break seq_2;
    }
    // free r12
    if (input.charCodeAt(peg$currPos) === 61) {
      r12 = "=";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c23);}
      r12 = peg$FAILED;
      peg$currPos = p11;
      r9 = peg$FAILED;
      break seq_2;
    }
    r13 = peg$parsegeneric_att_value(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r13===peg$FAILED) {
      r13 = null;
    }
    // v <- r13
    r9 = true;
    } // seq_2
    if (r9!==peg$FAILED) {
      peg$savedPos = p10;
      r9 = peg$a38(r4, r5, r7, r13);
    } else {
      r9 = null;
    }
    // free p11
    // vd <- r9
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a39(r4, r5, r7, r9);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parseextlink_preprocessor_text(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [548, boolParams & 0x39ff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    r1 = peg$parseextlink_preprocessor_text_parameterized(silence, boolParams & ~0x200, param_templatedepth, param_preproc, param_th);
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$discardspace(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 503;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    r1 = input.charAt(peg$currPos);
    if (/^[ \t]/.test(r1)) {
      peg$currPos++;
    } else {
      r1 = peg$FAILED;
      if (!silence) {peg$fail(peg$c9);}
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$discardunispace(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 511;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    r1 = input.charAt(peg$currPos);
    if (/^[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/.test(r1)) {
      peg$currPos++;
    } else {
      r1 = peg$FAILED;
      if (!silence) {peg$fail(peg$c25);}
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parseinlineline(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,r3,r4,p5,p6,p7,r8,r9,p10,p11,r12,r13;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [316, boolParams & 0x3bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    r3 = [];
    for (;;) {
      choice_1: {
      r4 = peg$parseurltext(silence, boolParams, param_templatedepth, param_preproc, param_th);
      if (r4!==peg$FAILED) {
        break choice_1;
      }
      p5 = peg$currPos;
      seq_1: {
      p6 = peg$currPos;
      p7 = peg$currPos;
      r8 = peg$discardinline_breaks(true, boolParams, param_templatedepth, param_preproc, param_th);
      if (r8 === peg$FAILED) {
        r8 = void 0;
      } else {
        r8 = peg$FAILED;
        peg$currPos = p7;
        r4 = peg$FAILED;
        break seq_1;
      }
      // free p7
      choice_2: {
      r9 = peg$parseinline_element(silence, boolParams, param_templatedepth, param_preproc, param_th);
      if (r9!==peg$FAILED) {
        break choice_2;
      }
      p7 = peg$currPos;
      seq_2: {
      p10 = peg$currPos;
      p11 = peg$currPos;
      r12 = peg$discardnewline(true);
      if (r12 === peg$FAILED) {
        r12 = void 0;
      } else {
        r12 = peg$FAILED;
        peg$currPos = p11;
        r9 = peg$FAILED;
        break seq_2;
      }
      // free p11
      // s <- r13
      if (peg$currPos < input.length) {
        r13 = input.charAt(peg$currPos++);
      } else {
        r13 = peg$FAILED;
        if (!silence) {peg$fail(peg$c11);}
        peg$currPos = p10;
        r9 = peg$FAILED;
        break seq_2;
      }
      r9 = true;
      } // seq_2
      if (r9!==peg$FAILED) {
        peg$savedPos = p7;
        r9 = peg$a40(r13);
      }
      // free p10
      } // choice_2
      // r <- r9
      if (r9===peg$FAILED) {
        peg$currPos = p6;
        r4 = peg$FAILED;
        break seq_1;
      }
      r4 = true;
      } // seq_1
      if (r4!==peg$FAILED) {
        peg$savedPos = p5;
        r4 = peg$a21(r9);
      }
      // free p6
      } // choice_1
      if (r4!==peg$FAILED) {
        r3.push(r4);
      } else {
        break;
      }
    }
    if (r3.length === 0) {
      r3 = peg$FAILED;
    }
    // c <- r3
    // free r4
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a41(r3);
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$discardeof(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 535;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    peg$savedPos = peg$currPos;
    r1 = peg$a42();
    if (r1) {
      r1 = void 0;
    } else {
      r1 = peg$FAILED;
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parseblock(silence, boolParams, param_templatedepth, param_th, param_preproc) {
    var r1,p2,p3,p4,r5,r6,r7,r8,p9,r10,r11,p12,r13,p14,r15,r16,r17,r18,r19;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [298, boolParams & 0x3bff, param_templatedepth, param_th.value, param_preproc.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
        return cached.result;
      }
        var saved_th=param_th.value;
        var saved_preproc=param_preproc.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p4 = peg$currPos;
    r5 = peg$discardsof(true);
    if (r5!==peg$FAILED) {
      r5 = void 0;
      peg$currPos = p4;
    } else {
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p4
    r6 = peg$parseredirect(silence, boolParams, param_templatedepth, param_th, param_preproc);
    // r <- r6
    if (r6===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r7 = peg$parsecomment_or_includes(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // cil <- r7
    if (r7===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r8 = peg$parseblock_line(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r8===peg$FAILED) {
      r8 = null;
    }
    // bl <- r8
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a43(r6, r7, r8);
      break choice_1;
    }
    // free p3
    r1 = peg$parseblock_lines(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    p3 = peg$currPos;
    seq_2: {
    p4 = peg$currPos;
    p9 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 60) {
      r10 = "<";
      peg$currPos += 1;
      r10 = void 0;
      peg$currPos = p9;
    } else {
      r10 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_2;
    }
    // free p9
    choice_2: {
    p9 = peg$currPos;
    seq_3: {
    p12 = peg$currPos;
    r13 = peg$parsecomment(silence);
    // c <- r13
    if (r13===peg$FAILED) {
      r11 = peg$FAILED;
      break seq_3;
    }
    p14 = peg$currPos;
    r15 = peg$discardeolf(true);
    if (r15!==peg$FAILED) {
      r15 = void 0;
      peg$currPos = p14;
    } else {
      peg$currPos = p12;
      r11 = peg$FAILED;
      break seq_3;
    }
    // free p14
    r11 = true;
    } // seq_3
    if (r11!==peg$FAILED) {
      peg$savedPos = p9;
      r11 = peg$a44(r13);
      break choice_2;
    }
    // free p12
    r16 = peg$parseblock_tag(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // bt <- r16
    r11 = r16;
    } // choice_2
    // rs <- r11
    if (r11===peg$FAILED) {
      peg$currPos = p4;
      r1 = peg$FAILED;
      break seq_2;
    }
    r1 = true;
    } // seq_2
    if (r1!==peg$FAILED) {
      peg$savedPos = p3;
      r1 = peg$a45(r11);
      break choice_1;
    }
    // free p4
    r1 = peg$parseparagraph(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    r1 = peg$parseinlineline(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    p4 = peg$currPos;
    seq_4: {
    p12 = peg$currPos;
    r17 = peg$parsesol(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // s <- r17
    if (r17===peg$FAILED) {
      r1 = peg$FAILED;
      break seq_4;
    }
    p14 = peg$currPos;
    r18 = peg$discardsof(true);
    if (r18 === peg$FAILED) {
      r18 = void 0;
    } else {
      r18 = peg$FAILED;
      peg$currPos = p14;
      peg$currPos = p12;
      r1 = peg$FAILED;
      break seq_4;
    }
    // free p14
    p14 = peg$currPos;
    r19 = peg$discardinline_breaks(true, boolParams, param_templatedepth, param_preproc, param_th);
    if (r19 === peg$FAILED) {
      r19 = void 0;
    } else {
      r19 = peg$FAILED;
      peg$currPos = p14;
      peg$currPos = p12;
      r1 = peg$FAILED;
      break seq_4;
    }
    // free p14
    r1 = true;
    } // seq_4
    if (r1!==peg$FAILED) {
      peg$savedPos = p4;
      r1 = peg$a40(r17);
    }
    // free p12
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_th !== param_th.value) cached.$th = param_th.value;
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
    }
    return r1;
  }
  function peg$discardnewline(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 537;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    if (input.charCodeAt(peg$currPos) === 10) {
      r1 = "\n";
      peg$currPos += 1;
      break choice_1;
    } else {
      if (!silence) {peg$fail(peg$c26);}
      r1 = peg$FAILED;
    }
    r1 = input.substr(peg$currPos,2);
    if (r1 === "\r\n") {
      peg$currPos += 2;
    } else {
      if (!silence) {peg$fail(peg$c27);}
      r1 = peg$FAILED;
    }
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parsetplarg_or_template_guarded(silence, boolParams, param_templatedepth, param_th, param_preproc) {
    var r1,p2,p3,p4,r5,p6,r7,p8,r9,p10,r11,r12,p13,r14,r15,r16,r17,r18,r19,r20,p21,r22,r23,r24,r25,r26,p27,r28,r29,r30;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [348, boolParams & 0x3bff, param_templatedepth, param_th.value, param_preproc.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
        return cached.result;
      }
        var saved_th=param_th.value;
        var saved_preproc=param_preproc.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p4 = peg$currPos;
    seq_2: {
    p6 = peg$currPos;
    r7 = input.substr(peg$currPos,2);
    if (r7 === "{{") {
      peg$currPos += 2;
    } else {
      r7 = peg$FAILED;
      r5 = peg$FAILED;
      break seq_2;
    }
    p8 = peg$currPos;
    seq_3: {
    p10 = peg$currPos;
    r11 = peg$FAILED;
    for (;;) {
      r12 = input.substr(peg$currPos,3);
      if (r12 === "{{{") {
        peg$currPos += 3;
        r11 = true;
      } else {
        r12 = peg$FAILED;
        break;
      }
    }
    if (r11===peg$FAILED) {
      r9 = peg$FAILED;
      break seq_3;
    }
    // free r12
    p13 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 123) {
      r12 = "{";
      peg$currPos += 1;
    } else {
      r12 = peg$FAILED;
    }
    if (r12 === peg$FAILED) {
      r12 = void 0;
    } else {
      r12 = peg$FAILED;
      peg$currPos = p13;
      peg$currPos = p10;
      r9 = peg$FAILED;
      break seq_3;
    }
    // free p13
    r9 = true;
    } // seq_3
    if (r9!==peg$FAILED) {
      r9 = void 0;
      peg$currPos = p8;
    } else {
      peg$currPos = p6;
      r5 = peg$FAILED;
      break seq_2;
    }
    // free p10
    // free p8
    r14 = peg$discardtplarg(true, boolParams, param_templatedepth, param_th);
    if (r14===peg$FAILED) {
      peg$currPos = p6;
      r5 = peg$FAILED;
      break seq_2;
    }
    r5 = true;
    } // seq_2
    if (r5!==peg$FAILED) {
      r5 = void 0;
      peg$currPos = p4;
    } else {
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p6
    // free p4
    choice_2: {
    r15 = peg$parsetemplate(silence, boolParams, param_templatedepth, param_th);
    if (r15!==peg$FAILED) {
      break choice_2;
    }
    r15 = peg$parsebroken_template(silence, param_preproc);
    } // choice_2
    // a <- r15
    if (r15===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a46(r15);
      break choice_1;
    }
    // free p3
    p3 = peg$currPos;
    seq_4: {
    p4 = peg$currPos;
    p6 = peg$currPos;
    seq_5: {
    p8 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 123) {
      r17 = "{";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c28);}
      r17 = peg$FAILED;
      r16 = peg$FAILED;
      break seq_5;
    }
    p10 = peg$currPos;
    seq_6: {
    p13 = peg$currPos;
    r19 = peg$FAILED;
    for (;;) {
      r20 = input.substr(peg$currPos,3);
      if (r20 === "{{{") {
        peg$currPos += 3;
        r19 = true;
      } else {
        r20 = peg$FAILED;
        break;
      }
    }
    if (r19===peg$FAILED) {
      r18 = peg$FAILED;
      break seq_6;
    }
    // free r20
    p21 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 123) {
      r20 = "{";
      peg$currPos += 1;
    } else {
      r20 = peg$FAILED;
    }
    if (r20 === peg$FAILED) {
      r20 = void 0;
    } else {
      r20 = peg$FAILED;
      peg$currPos = p21;
      peg$currPos = p13;
      r18 = peg$FAILED;
      break seq_6;
    }
    // free p21
    r18 = true;
    } // seq_6
    if (r18!==peg$FAILED) {
      r18 = void 0;
      peg$currPos = p10;
    } else {
      peg$currPos = p8;
      r16 = peg$FAILED;
      break seq_5;
    }
    // free p13
    // free p10
    r16 = true;
    } // seq_5
    if (r16===peg$FAILED) {
      r16 = null;
    }
    // free p8
    // a <- r16
    r16 = input.substring(p6, peg$currPos);
    // free p6
    r22 = peg$parsetplarg(silence, boolParams, param_templatedepth, param_th);
    // b <- r22
    if (r22===peg$FAILED) {
      peg$currPos = p4;
      r1 = peg$FAILED;
      break seq_4;
    }
    r1 = true;
    } // seq_4
    if (r1!==peg$FAILED) {
      peg$savedPos = p3;
      r1 = peg$a47(r16, r22);
      break choice_1;
    }
    // free p4
    p4 = peg$currPos;
    seq_7: {
    p6 = peg$currPos;
    p8 = peg$currPos;
    seq_8: {
    p10 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 123) {
      r24 = "{";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c28);}
      r24 = peg$FAILED;
      r23 = peg$FAILED;
      break seq_8;
    }
    p13 = peg$currPos;
    seq_9: {
    p21 = peg$currPos;
    r26 = input.substr(peg$currPos,2);
    if (r26 === "{{") {
      peg$currPos += 2;
    } else {
      r26 = peg$FAILED;
      r25 = peg$FAILED;
      break seq_9;
    }
    p27 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 123) {
      r28 = "{";
      peg$currPos += 1;
    } else {
      r28 = peg$FAILED;
    }
    if (r28 === peg$FAILED) {
      r28 = void 0;
    } else {
      r28 = peg$FAILED;
      peg$currPos = p27;
      peg$currPos = p21;
      r25 = peg$FAILED;
      break seq_9;
    }
    // free p27
    r25 = true;
    } // seq_9
    if (r25!==peg$FAILED) {
      r25 = void 0;
      peg$currPos = p13;
    } else {
      peg$currPos = p10;
      r23 = peg$FAILED;
      break seq_8;
    }
    // free p21
    // free p13
    r23 = true;
    } // seq_8
    if (r23===peg$FAILED) {
      r23 = null;
    }
    // free p10
    // a <- r23
    r23 = input.substring(p8, peg$currPos);
    // free p8
    r29 = peg$parsetemplate(silence, boolParams, param_templatedepth, param_th);
    // b <- r29
    if (r29===peg$FAILED) {
      peg$currPos = p6;
      r1 = peg$FAILED;
      break seq_7;
    }
    r1 = true;
    } // seq_7
    if (r1!==peg$FAILED) {
      peg$savedPos = p4;
      r1 = peg$a47(r23, r29);
      break choice_1;
    }
    // free p6
    p6 = peg$currPos;
    r30 = peg$parsebroken_template(silence, param_preproc);
    // a <- r30
    r1 = r30;
    if (r1!==peg$FAILED) {
      peg$savedPos = p6;
      r1 = peg$a46(r30);
    }
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_th !== param_th.value) cached.$th = param_th.value;
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
    }
    return r1;
  }
  function peg$parseraw_htmlentity(silence) {
    var r1,p2,r3,p4,p5,r6,r7,r8;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 494;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    p4 = peg$currPos;
    seq_1: {
    p5 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 38) {
      r6 = "&";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c29);}
      r6 = peg$FAILED;
      r3 = peg$FAILED;
      break seq_1;
    }
    r7 = peg$FAILED;
    for (;;) {
      r8 = input.charAt(peg$currPos);
      if (/^[#0-9a-zA-Z]/.test(r8)) {
        peg$currPos++;
        r7 = true;
      } else {
        r8 = peg$FAILED;
        if (!silence) {peg$fail(peg$c30);}
        break;
      }
    }
    if (r7===peg$FAILED) {
      peg$currPos = p5;
      r3 = peg$FAILED;
      break seq_1;
    }
    // free r8
    if (input.charCodeAt(peg$currPos) === 59) {
      r8 = ";";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c31);}
      r8 = peg$FAILED;
      peg$currPos = p5;
      r3 = peg$FAILED;
      break seq_1;
    }
    r3 = true;
    } // seq_1
    // m <- r3
    if (r3!==peg$FAILED) {
      r3 = input.substring(p4, peg$currPos);
    } else {
      r3 = peg$FAILED;
    }
    // free p5
    // free p4
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a48(r3);
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parseoptionalSpaceToken(silence) {
    var r1,p2,r3;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 504;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    r3 = peg$parseoptional_spaces(silence);
    // s <- r3
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a35(r3);
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parsetable_attribute_name(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,p5,r6,r7,r8,p9,p10,r11,p12,p13,r14,r15,p16,r17,r18;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [442, boolParams & 0x3bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p5 = peg$currPos;
    r4 = input.charAt(peg$currPos);
    if (/^["'=]/.test(r4)) {
      peg$currPos++;
    } else {
      r4 = peg$FAILED;
      if (!silence) {peg$fail(peg$c32);}
      r4 = null;
    }
    // q <- r4
    r4 = input.substring(p5, peg$currPos);
    // free p5
    r6 = [];
    for (;;) {
      choice_1: {
      p5 = peg$currPos;
      r7 = peg$FAILED;
      for (;;) {
        r8 = input.charAt(peg$currPos);
        if (/^[^ \t\r\n\0\/=><&{}\-!|[]/.test(r8)) {
          peg$currPos++;
          r7 = true;
        } else {
          r8 = peg$FAILED;
          if (!silence) {peg$fail(peg$c33);}
          break;
        }
      }
      if (r7!==peg$FAILED) {
        r7 = input.substring(p5, peg$currPos);
        break choice_1;
      } else {
        r7 = peg$FAILED;
      }
      // free r8
      // free p5
      p5 = peg$currPos;
      seq_2: {
      p9 = peg$currPos;
      p10 = peg$currPos;
      r8 = peg$discardinline_breaks(true, boolParams, param_templatedepth, param_preproc, param_th);
      if (r8 === peg$FAILED) {
        r8 = void 0;
      } else {
        r8 = peg$FAILED;
        peg$currPos = p10;
        r7 = peg$FAILED;
        break seq_2;
      }
      // free p10
      choice_2: {
      p10 = peg$currPos;
      r11 = peg$discardwikilink(silence, boolParams, param_templatedepth, param_th, param_preproc);
      if (r11!==peg$FAILED) {
        r11 = input.substring(p10, peg$currPos);
        break choice_2;
      } else {
        r11 = peg$FAILED;
      }
      // free p10
      r11 = peg$parsedirective(silence, boolParams, param_templatedepth, param_preproc, param_th);
      if (r11!==peg$FAILED) {
        break choice_2;
      }
      p10 = peg$currPos;
      seq_3: {
      p12 = peg$currPos;
      p13 = peg$currPos;
      r14 = peg$discardxmlish_tag(true, boolParams, param_templatedepth, param_preproc, param_th);
      if (r14!==peg$FAILED) {
        r14 = void 0;
        peg$currPos = p13;
      } else {
        r11 = peg$FAILED;
        break seq_3;
      }
      // free p13
      r15 = peg$parseinlineline(silence, boolParams, param_templatedepth, param_preproc, param_th);
      // ill <- r15
      if (r15===peg$FAILED) {
        peg$currPos = p12;
        r11 = peg$FAILED;
        break seq_3;
      }
      r11 = true;
      } // seq_3
      if (r11!==peg$FAILED) {
        peg$savedPos = p10;
        r11 = peg$a49(r4, r15);
        break choice_2;
      }
      // free p12
      p12 = peg$currPos;
      seq_4: {
      p13 = peg$currPos;
      p16 = peg$currPos;
      choice_3: {
      r17 = peg$discardspace_or_newline(true);
      if (r17!==peg$FAILED) {
        break choice_3;
      }
      r17 = input.charAt(peg$currPos);
      if (/^[\0\/=>]/.test(r17)) {
        peg$currPos++;
      } else {
        r17 = peg$FAILED;
      }
      } // choice_3
      if (r17 === peg$FAILED) {
        r17 = void 0;
      } else {
        r17 = peg$FAILED;
        peg$currPos = p16;
        r11 = peg$FAILED;
        break seq_4;
      }
      // free p16
      if (peg$currPos < input.length) {
        r18 = input.charAt(peg$currPos++);
      } else {
        r18 = peg$FAILED;
        if (!silence) {peg$fail(peg$c11);}
        peg$currPos = p13;
        r11 = peg$FAILED;
        break seq_4;
      }
      r11 = true;
      } // seq_4
      if (r11!==peg$FAILED) {
        r11 = input.substring(p12, peg$currPos);
      } else {
        r11 = peg$FAILED;
      }
      // free p13
      // free p12
      } // choice_2
      // t <- r11
      if (r11===peg$FAILED) {
        peg$currPos = p9;
        r7 = peg$FAILED;
        break seq_2;
      }
      r7 = true;
      } // seq_2
      if (r7!==peg$FAILED) {
        peg$savedPos = p5;
        r7 = peg$a50(r4, r11);
      }
      // free p9
      } // choice_1
      if (r7!==peg$FAILED) {
        r6.push(r7);
      } else {
        break;
      }
    }
    // r <- r6
    // free r7
    peg$savedPos = peg$currPos;
    r7 = peg$a51(r4, r6);
    if (r7) {
      r7 = void 0;
    } else {
      r7 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a52(r4, r6);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsetable_att_value(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,p5,p6,r7,r8,r9,r10,p11,r12,r13,r14,r15,r16,r17;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [446, boolParams & 0x3bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p5 = peg$currPos;
    seq_2: {
    p6 = peg$currPos;
    for (;;) {
      r8 = peg$discardspace(silence);
      if (r8===peg$FAILED) {
        break;
      }
    }
    // free r8
    r7 = true;
    if (r7===peg$FAILED) {
      r4 = peg$FAILED;
      break seq_2;
    }
    // free r7
    if (input.charCodeAt(peg$currPos) === 39) {
      r7 = "'";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c34);}
      r7 = peg$FAILED;
      peg$currPos = p6;
      r4 = peg$FAILED;
      break seq_2;
    }
    r4 = true;
    } // seq_2
    // s <- r4
    if (r4!==peg$FAILED) {
      r4 = input.substring(p5, peg$currPos);
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p6
    // free p5
    r8 = peg$parsetable_attribute_preprocessor_text_single(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r8===peg$FAILED) {
      r8 = null;
    }
    // t <- r8
    p5 = peg$currPos;
    choice_2: {
    if (input.charCodeAt(peg$currPos) === 39) {
      r9 = "'";
      peg$currPos += 1;
      break choice_2;
    } else {
      if (!silence) {peg$fail(peg$c34);}
      r9 = peg$FAILED;
    }
    p6 = peg$currPos;
    choice_3: {
    r9 = input.substr(peg$currPos,2);
    if (r9 === "!!") {
      peg$currPos += 2;
      break choice_3;
    } else {
      r9 = peg$FAILED;
    }
    r9 = input.charAt(peg$currPos);
    if (/^[|\r\n]/.test(r9)) {
      peg$currPos++;
    } else {
      r9 = peg$FAILED;
    }
    } // choice_3
    if (r9!==peg$FAILED) {
      r9 = void 0;
      peg$currPos = p6;
    }
    // free p6
    } // choice_2
    // q <- r9
    if (r9!==peg$FAILED) {
      r9 = input.substring(p5, peg$currPos);
    } else {
      r9 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p5
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a53(r4, r8, r9);
      break choice_1;
    }
    // free p3
    p3 = peg$currPos;
    seq_3: {
    p5 = peg$currPos;
    p6 = peg$currPos;
    seq_4: {
    p11 = peg$currPos;
    for (;;) {
      r13 = peg$discardspace(silence);
      if (r13===peg$FAILED) {
        break;
      }
    }
    // free r13
    r12 = true;
    if (r12===peg$FAILED) {
      r10 = peg$FAILED;
      break seq_4;
    }
    // free r12
    if (input.charCodeAt(peg$currPos) === 34) {
      r12 = "\"";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c35);}
      r12 = peg$FAILED;
      peg$currPos = p11;
      r10 = peg$FAILED;
      break seq_4;
    }
    r10 = true;
    } // seq_4
    // s <- r10
    if (r10!==peg$FAILED) {
      r10 = input.substring(p6, peg$currPos);
    } else {
      r10 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_3;
    }
    // free p11
    // free p6
    r13 = peg$parsetable_attribute_preprocessor_text_double(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r13===peg$FAILED) {
      r13 = null;
    }
    // t <- r13
    p6 = peg$currPos;
    choice_4: {
    if (input.charCodeAt(peg$currPos) === 34) {
      r14 = "\"";
      peg$currPos += 1;
      break choice_4;
    } else {
      if (!silence) {peg$fail(peg$c35);}
      r14 = peg$FAILED;
    }
    p11 = peg$currPos;
    choice_5: {
    r14 = input.substr(peg$currPos,2);
    if (r14 === "!!") {
      peg$currPos += 2;
      break choice_5;
    } else {
      r14 = peg$FAILED;
    }
    r14 = input.charAt(peg$currPos);
    if (/^[|\r\n]/.test(r14)) {
      peg$currPos++;
    } else {
      r14 = peg$FAILED;
    }
    } // choice_5
    if (r14!==peg$FAILED) {
      r14 = void 0;
      peg$currPos = p11;
    }
    // free p11
    } // choice_4
    // q <- r14
    if (r14!==peg$FAILED) {
      r14 = input.substring(p6, peg$currPos);
    } else {
      r14 = peg$FAILED;
      peg$currPos = p5;
      r1 = peg$FAILED;
      break seq_3;
    }
    // free p6
    r1 = true;
    } // seq_3
    if (r1!==peg$FAILED) {
      peg$savedPos = p3;
      r1 = peg$a53(r10, r13, r14);
      break choice_1;
    }
    // free p5
    p5 = peg$currPos;
    seq_5: {
    p6 = peg$currPos;
    p11 = peg$currPos;
    for (;;) {
      r16 = peg$discardspace(silence);
      if (r16===peg$FAILED) {
        break;
      }
    }
    // free r16
    r15 = true;
    // s <- r15
    if (r15!==peg$FAILED) {
      r15 = input.substring(p11, peg$currPos);
    } else {
      r15 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_5;
    }
    // free p11
    r16 = peg$parsetable_attribute_preprocessor_text(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // t <- r16
    if (r16===peg$FAILED) {
      peg$currPos = p6;
      r1 = peg$FAILED;
      break seq_5;
    }
    p11 = peg$currPos;
    choice_6: {
    r17 = peg$discardspace_or_newline(true);
    if (r17!==peg$FAILED) {
      break choice_6;
    }
    r17 = peg$discardeof(true);
    if (r17!==peg$FAILED) {
      break choice_6;
    }
    r17 = input.substr(peg$currPos,2);
    if (r17 === "!!") {
      peg$currPos += 2;
      break choice_6;
    } else {
      r17 = peg$FAILED;
    }
    if (input.charCodeAt(peg$currPos) === 124) {
      r17 = "|";
      peg$currPos += 1;
    } else {
      r17 = peg$FAILED;
    }
    } // choice_6
    if (r17!==peg$FAILED) {
      r17 = void 0;
      peg$currPos = p11;
    } else {
      peg$currPos = p6;
      r1 = peg$FAILED;
      break seq_5;
    }
    // free p11
    r1 = true;
    } // seq_5
    if (r1!==peg$FAILED) {
      peg$savedPos = p5;
      r1 = peg$a54(r15, r16);
    }
    // free p6
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$discardspace_or_newline_or_solidus(silence) {
    var r1,p2,p3,r4,p5,r6;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 425;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    r1 = peg$discardspace_or_newline(silence);
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    // s <- r4
    if (input.charCodeAt(peg$currPos) === 47) {
      r4 = "/";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c36);}
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    p5 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 62) {
      r6 = ">";
      peg$currPos += 1;
    } else {
      r6 = peg$FAILED;
    }
    if (r6 === peg$FAILED) {
      r6 = void 0;
    } else {
      r6 = peg$FAILED;
      peg$currPos = p5;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p5
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a40(r4);
    }
    // free p3
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parsegeneric_attribute_name(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,p5,r6,r7,r8,p9,p10,r11,p12,p13,r14,r15;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [438, boolParams & 0x3bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p5 = peg$currPos;
    r4 = input.charAt(peg$currPos);
    if (/^["'=]/.test(r4)) {
      peg$currPos++;
    } else {
      r4 = peg$FAILED;
      if (!silence) {peg$fail(peg$c32);}
      r4 = null;
    }
    // q <- r4
    r4 = input.substring(p5, peg$currPos);
    // free p5
    r6 = [];
    for (;;) {
      choice_1: {
      p5 = peg$currPos;
      r7 = peg$FAILED;
      for (;;) {
        r8 = input.charAt(peg$currPos);
        if (/^[^ \t\r\n\0\/=><&{}\-!|]/.test(r8)) {
          peg$currPos++;
          r7 = true;
        } else {
          r8 = peg$FAILED;
          if (!silence) {peg$fail(peg$c37);}
          break;
        }
      }
      if (r7!==peg$FAILED) {
        r7 = input.substring(p5, peg$currPos);
        break choice_1;
      } else {
        r7 = peg$FAILED;
      }
      // free r8
      // free p5
      p5 = peg$currPos;
      seq_2: {
      p9 = peg$currPos;
      p10 = peg$currPos;
      r8 = peg$discardinline_breaks(true, boolParams, param_templatedepth, param_preproc, param_th);
      if (r8 === peg$FAILED) {
        r8 = void 0;
      } else {
        r8 = peg$FAILED;
        peg$currPos = p10;
        r7 = peg$FAILED;
        break seq_2;
      }
      // free p10
      choice_2: {
      r11 = peg$parsedirective(silence, boolParams, param_templatedepth, param_preproc, param_th);
      if (r11!==peg$FAILED) {
        break choice_2;
      }
      r11 = peg$parseless_than(silence, boolParams);
      if (r11!==peg$FAILED) {
        break choice_2;
      }
      p10 = peg$currPos;
      seq_3: {
      p12 = peg$currPos;
      p13 = peg$currPos;
      choice_3: {
      r14 = peg$discardspace_or_newline(true);
      if (r14!==peg$FAILED) {
        break choice_3;
      }
      r14 = input.charAt(peg$currPos);
      if (/^[\0\/=><]/.test(r14)) {
        peg$currPos++;
      } else {
        r14 = peg$FAILED;
      }
      } // choice_3
      if (r14 === peg$FAILED) {
        r14 = void 0;
      } else {
        r14 = peg$FAILED;
        peg$currPos = p13;
        r11 = peg$FAILED;
        break seq_3;
      }
      // free p13
      if (peg$currPos < input.length) {
        r15 = input.charAt(peg$currPos++);
      } else {
        r15 = peg$FAILED;
        if (!silence) {peg$fail(peg$c11);}
        peg$currPos = p12;
        r11 = peg$FAILED;
        break seq_3;
      }
      r11 = true;
      } // seq_3
      if (r11!==peg$FAILED) {
        r11 = input.substring(p10, peg$currPos);
      } else {
        r11 = peg$FAILED;
      }
      // free p12
      // free p10
      } // choice_2
      // t <- r11
      if (r11===peg$FAILED) {
        peg$currPos = p9;
        r7 = peg$FAILED;
        break seq_2;
      }
      r7 = true;
      } // seq_2
      if (r7!==peg$FAILED) {
        peg$savedPos = p5;
        r7 = peg$a50(r4, r11);
      }
      // free p9
      } // choice_1
      if (r7!==peg$FAILED) {
        r6.push(r7);
      } else {
        break;
      }
    }
    // r <- r6
    // free r7
    peg$savedPos = peg$currPos;
    r7 = peg$a51(r4, r6);
    if (r7) {
      r7 = void 0;
    } else {
      r7 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a52(r4, r6);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$discardspace_or_newline(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 507;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    r1 = input.charAt(peg$currPos);
    if (/^[ \t\n\r\f]/.test(r1)) {
      peg$currPos++;
    } else {
      r1 = peg$FAILED;
      if (!silence) {peg$fail(peg$c38);}
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parsegeneric_att_value(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,p5,p6,r7,r8,r9,p10,r11,r12,r13,r14,r15,r16,p17,r18,r19,r20,r21,r22,r23,r24;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [444, boolParams & 0x3bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p5 = peg$currPos;
    seq_2: {
    p6 = peg$currPos;
    for (;;) {
      r8 = peg$discardspace_or_newline(silence);
      if (r8===peg$FAILED) {
        break;
      }
    }
    // free r8
    r7 = true;
    if (r7===peg$FAILED) {
      r4 = peg$FAILED;
      break seq_2;
    }
    // free r7
    if (input.charCodeAt(peg$currPos) === 39) {
      r7 = "'";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c34);}
      r7 = peg$FAILED;
      peg$currPos = p6;
      r4 = peg$FAILED;
      break seq_2;
    }
    r4 = true;
    } // seq_2
    // s <- r4
    if (r4!==peg$FAILED) {
      r4 = input.substring(p5, peg$currPos);
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p6
    // free p5
    r8 = peg$parseattribute_preprocessor_text_single(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r8===peg$FAILED) {
      r8 = null;
    }
    // t <- r8
    p5 = peg$currPos;
    choice_2: {
    if (input.charCodeAt(peg$currPos) === 39) {
      r9 = "'";
      peg$currPos += 1;
      break choice_2;
    } else {
      if (!silence) {peg$fail(peg$c34);}
      r9 = peg$FAILED;
    }
    p6 = peg$currPos;
    seq_3: {
    p10 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 47) {
      r11 = "/";
      peg$currPos += 1;
    } else {
      r11 = peg$FAILED;
      r11 = null;
    }
    if (input.charCodeAt(peg$currPos) === 62) {
      r12 = ">";
      peg$currPos += 1;
    } else {
      r12 = peg$FAILED;
      peg$currPos = p10;
      r9 = peg$FAILED;
      break seq_3;
    }
    r9 = true;
    } // seq_3
    if (r9!==peg$FAILED) {
      r9 = void 0;
      peg$currPos = p6;
    }
    // free p10
    // free p6
    } // choice_2
    // q <- r9
    if (r9!==peg$FAILED) {
      r9 = input.substring(p5, peg$currPos);
    } else {
      r9 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p5
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a53(r4, r8, r9);
      break choice_1;
    }
    // free p3
    p3 = peg$currPos;
    seq_4: {
    p5 = peg$currPos;
    p6 = peg$currPos;
    seq_5: {
    p10 = peg$currPos;
    for (;;) {
      r15 = peg$discardspace_or_newline(silence);
      if (r15===peg$FAILED) {
        break;
      }
    }
    // free r15
    r14 = true;
    if (r14===peg$FAILED) {
      r13 = peg$FAILED;
      break seq_5;
    }
    // free r14
    if (input.charCodeAt(peg$currPos) === 34) {
      r14 = "\"";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c35);}
      r14 = peg$FAILED;
      peg$currPos = p10;
      r13 = peg$FAILED;
      break seq_5;
    }
    r13 = true;
    } // seq_5
    // s <- r13
    if (r13!==peg$FAILED) {
      r13 = input.substring(p6, peg$currPos);
    } else {
      r13 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_4;
    }
    // free p10
    // free p6
    r15 = peg$parseattribute_preprocessor_text_double(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r15===peg$FAILED) {
      r15 = null;
    }
    // t <- r15
    p6 = peg$currPos;
    choice_3: {
    if (input.charCodeAt(peg$currPos) === 34) {
      r16 = "\"";
      peg$currPos += 1;
      break choice_3;
    } else {
      if (!silence) {peg$fail(peg$c35);}
      r16 = peg$FAILED;
    }
    p10 = peg$currPos;
    seq_6: {
    p17 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 47) {
      r18 = "/";
      peg$currPos += 1;
    } else {
      r18 = peg$FAILED;
      r18 = null;
    }
    if (input.charCodeAt(peg$currPos) === 62) {
      r19 = ">";
      peg$currPos += 1;
    } else {
      r19 = peg$FAILED;
      peg$currPos = p17;
      r16 = peg$FAILED;
      break seq_6;
    }
    r16 = true;
    } // seq_6
    if (r16!==peg$FAILED) {
      r16 = void 0;
      peg$currPos = p10;
    }
    // free p17
    // free p10
    } // choice_3
    // q <- r16
    if (r16!==peg$FAILED) {
      r16 = input.substring(p6, peg$currPos);
    } else {
      r16 = peg$FAILED;
      peg$currPos = p5;
      r1 = peg$FAILED;
      break seq_4;
    }
    // free p6
    r1 = true;
    } // seq_4
    if (r1!==peg$FAILED) {
      peg$savedPos = p3;
      r1 = peg$a53(r13, r15, r16);
      break choice_1;
    }
    // free p5
    p5 = peg$currPos;
    seq_7: {
    p6 = peg$currPos;
    p10 = peg$currPos;
    for (;;) {
      r21 = peg$discardspace_or_newline(silence);
      if (r21===peg$FAILED) {
        break;
      }
    }
    // free r21
    r20 = true;
    // s <- r20
    if (r20!==peg$FAILED) {
      r20 = input.substring(p10, peg$currPos);
    } else {
      r20 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_7;
    }
    // free p10
    r21 = peg$parseattribute_preprocessor_text(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // t <- r21
    if (r21===peg$FAILED) {
      peg$currPos = p6;
      r1 = peg$FAILED;
      break seq_7;
    }
    p10 = peg$currPos;
    choice_4: {
    r22 = peg$discardspace_or_newline(true);
    if (r22!==peg$FAILED) {
      break choice_4;
    }
    r22 = peg$discardeof(true);
    if (r22!==peg$FAILED) {
      break choice_4;
    }
    seq_8: {
    p17 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 47) {
      r23 = "/";
      peg$currPos += 1;
    } else {
      r23 = peg$FAILED;
      r23 = null;
    }
    if (input.charCodeAt(peg$currPos) === 62) {
      r24 = ">";
      peg$currPos += 1;
    } else {
      r24 = peg$FAILED;
      peg$currPos = p17;
      r22 = peg$FAILED;
      break seq_8;
    }
    r22 = true;
    } // seq_8
    // free p17
    } // choice_4
    if (r22!==peg$FAILED) {
      r22 = void 0;
      peg$currPos = p10;
    } else {
      peg$currPos = p6;
      r1 = peg$FAILED;
      break seq_7;
    }
    // free p10
    r1 = true;
    } // seq_7
    if (r1!==peg$FAILED) {
      peg$savedPos = p5;
      r1 = peg$a54(r20, r21);
    }
    // free p6
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parseextlink_preprocessor_text_parameterized(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,r3,r4,p5,r6,p7,p8,r9,r10,p11,r12,r13,r14;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [550, boolParams & 0x3bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    r3 = [];
    for (;;) {
      choice_1: {
      p5 = peg$currPos;
      r4 = peg$FAILED;
      for (;;) {
        r6 = input.charAt(peg$currPos);
        if (/^[^'<~[{\n\r|!\]}\-\t&="' \xA0\u1680\u180E\u2000-\u200A\u202F\u205F\u3000]/.test(r6)) {
          peg$currPos++;
          r4 = true;
        } else {
          r6 = peg$FAILED;
          if (!silence) {peg$fail(peg$c39);}
          break;
        }
      }
      if (r4!==peg$FAILED) {
        r4 = input.substring(p5, peg$currPos);
        break choice_1;
      } else {
        r4 = peg$FAILED;
      }
      // free r6
      // free p5
      p5 = peg$currPos;
      seq_1: {
      p7 = peg$currPos;
      p8 = peg$currPos;
      r6 = peg$discardinline_breaks(true, boolParams, param_templatedepth, param_preproc, param_th);
      if (r6 === peg$FAILED) {
        r6 = void 0;
      } else {
        r6 = peg$FAILED;
        peg$currPos = p8;
        r4 = peg$FAILED;
        break seq_1;
      }
      // free p8
      choice_2: {
      r9 = peg$parsedirective(silence, boolParams, param_templatedepth, param_preproc, param_th);
      if (r9!==peg$FAILED) {
        break choice_2;
      }
      r9 = peg$parseno_punctuation_char(silence);
      if (r9!==peg$FAILED) {
        break choice_2;
      }
      r9 = input.charAt(peg$currPos);
      if (/^[&|{\-]/.test(r9)) {
        peg$currPos++;
      } else {
        r9 = peg$FAILED;
        if (!silence) {peg$fail(peg$c40);}
      }
      } // choice_2
      // s <- r9
      if (r9===peg$FAILED) {
        peg$currPos = p7;
        r4 = peg$FAILED;
        break seq_1;
      }
      r4 = true;
      } // seq_1
      if (r4!==peg$FAILED) {
        peg$savedPos = p5;
        r4 = peg$a40(r9);
        break choice_1;
      }
      // free p7
      p7 = peg$currPos;
      seq_2: {
      p8 = peg$currPos;
      r10 = input.charAt(peg$currPos);
      if (/^[.:,]/.test(r10)) {
        peg$currPos++;
      } else {
        r10 = peg$FAILED;
        if (!silence) {peg$fail(peg$c41);}
        r4 = peg$FAILED;
        break seq_2;
      }
      p11 = peg$currPos;
      choice_3: {
      r12 = peg$discardspace(true);
      if (r12!==peg$FAILED) {
        break choice_3;
      }
      r12 = peg$discardeolf(true);
      } // choice_3
      if (r12 === peg$FAILED) {
        r12 = void 0;
      } else {
        r12 = peg$FAILED;
        peg$currPos = p11;
        peg$currPos = p8;
        r4 = peg$FAILED;
        break seq_2;
      }
      // free p11
      r4 = true;
      } // seq_2
      if (r4!==peg$FAILED) {
        r4 = input.substring(p7, peg$currPos);
        break choice_1;
      } else {
        r4 = peg$FAILED;
      }
      // free p8
      // free p7
      p7 = peg$currPos;
      seq_3: {
      p8 = peg$currPos;
      r13 = input.charAt(peg$currPos);
      if (/^[']/.test(r13)) {
        peg$currPos++;
      } else {
        r13 = peg$FAILED;
        if (!silence) {peg$fail(peg$c42);}
        r4 = peg$FAILED;
        break seq_3;
      }
      p11 = peg$currPos;
      r14 = input.charAt(peg$currPos);
      if (/^[']/.test(r14)) {
        peg$currPos++;
      } else {
        r14 = peg$FAILED;
      }
      if (r14 === peg$FAILED) {
        r14 = void 0;
      } else {
        r14 = peg$FAILED;
        peg$currPos = p11;
        peg$currPos = p8;
        r4 = peg$FAILED;
        break seq_3;
      }
      // free p11
      r4 = true;
      } // seq_3
      if (r4!==peg$FAILED) {
        r4 = input.substring(p7, peg$currPos);
      } else {
        r4 = peg$FAILED;
      }
      // free p8
      // free p7
      } // choice_1
      if (r4!==peg$FAILED) {
        r3.push(r4);
      } else {
        break;
      }
    }
    if (r3.length === 0) {
      r3 = peg$FAILED;
    }
    // r <- r3
    // free r4
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a55(r3);
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parseurltext(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,r2,p3,p4,p5,r6,r7,p8,r9,r10,r11,p12,r13,p14,r15,r16;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [492, boolParams & 0x3bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    r1 = [];
    for (;;) {
      choice_1: {
      p3 = peg$currPos;
      seq_1: {
      p4 = peg$currPos;
      p5 = peg$currPos;
      r6 = input.charAt(peg$currPos);
      if (/^[\/A-Za-z]/.test(r6)) {
        peg$currPos++;
        r6 = void 0;
        peg$currPos = p5;
      } else {
        r6 = peg$FAILED;
        r2 = peg$FAILED;
        break seq_1;
      }
      // free p5
      r7 = peg$parseautolink(silence, boolParams, param_templatedepth, param_preproc, param_th);
      // al <- r7
      if (r7===peg$FAILED) {
        peg$currPos = p4;
        r2 = peg$FAILED;
        break seq_1;
      }
      r2 = true;
      } // seq_1
      if (r2!==peg$FAILED) {
        peg$savedPos = p3;
        r2 = peg$a56(r7);
        break choice_1;
      }
      // free p4
      p4 = peg$currPos;
      seq_2: {
      p5 = peg$currPos;
      p8 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 38) {
        r9 = "&";
        peg$currPos += 1;
        r9 = void 0;
        peg$currPos = p8;
      } else {
        r9 = peg$FAILED;
        r2 = peg$FAILED;
        break seq_2;
      }
      // free p8
      r10 = peg$parsehtmlentity(silence);
      // he <- r10
      if (r10===peg$FAILED) {
        peg$currPos = p5;
        r2 = peg$FAILED;
        break seq_2;
      }
      r2 = true;
      } // seq_2
      if (r2!==peg$FAILED) {
        peg$savedPos = p4;
        r2 = peg$a57(r10);
        break choice_1;
      }
      // free p5
      p5 = peg$currPos;
      seq_3: {
      p8 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 32) {
        r11 = " ";
        peg$currPos += 1;
      } else {
        if (!silence) {peg$fail(peg$c43);}
        r11 = peg$FAILED;
        r2 = peg$FAILED;
        break seq_3;
      }
      p12 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 58) {
        r13 = ":";
        peg$currPos += 1;
        r13 = void 0;
        peg$currPos = p12;
      } else {
        r13 = peg$FAILED;
        peg$currPos = p8;
        r2 = peg$FAILED;
        break seq_3;
      }
      // free p12
      r2 = true;
      } // seq_3
      if (r2!==peg$FAILED) {
        peg$savedPos = p5;
        r2 = peg$a58();
        break choice_1;
      }
      // free p8
      p8 = peg$currPos;
      seq_4: {
      p12 = peg$currPos;
      p14 = peg$currPos;
      r15 = input.substr(peg$currPos,2);
      if (r15 === "__") {
        peg$currPos += 2;
        r15 = void 0;
        peg$currPos = p14;
      } else {
        r15 = peg$FAILED;
        r2 = peg$FAILED;
        break seq_4;
      }
      // free p14
      r16 = peg$parsebehavior_switch(silence);
      // bs <- r16
      if (r16===peg$FAILED) {
        peg$currPos = p12;
        r2 = peg$FAILED;
        break seq_4;
      }
      r2 = true;
      } // seq_4
      if (r2!==peg$FAILED) {
        peg$savedPos = p8;
        r2 = peg$a59(r16);
        break choice_1;
      }
      // free p12
      r2 = input.charAt(peg$currPos);
      if (/^[^\-'<~[{\n\r:;\]}|!=]/.test(r2)) {
        peg$currPos++;
      } else {
        r2 = peg$FAILED;
        if (!silence) {peg$fail(peg$c44);}
      }
      } // choice_1
      if (r2!==peg$FAILED) {
        r1.push(r2);
      } else {
        break;
      }
    }
    if (r1.length === 0) {
      r1 = peg$FAILED;
    }
    // free r2
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parseinline_element(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,p4,r5,r6,p7,r8,r9,p10,r11,r12,r13,r14,p15,r16,r17,p18,r19,r20;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [318, boolParams & 0x3bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p4 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 60) {
      r5 = "<";
      peg$currPos += 1;
      r5 = void 0;
      peg$currPos = p4;
    } else {
      r5 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p4
    choice_2: {
    r6 = peg$parsexmlish_tag(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r6!==peg$FAILED) {
      break choice_2;
    }
    r6 = peg$parsecomment(silence);
    } // choice_2
    // r <- r6
    if (r6===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a21(r6);
      break choice_1;
    }
    // free p3
    p3 = peg$currPos;
    seq_2: {
    p4 = peg$currPos;
    p7 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 123) {
      r8 = "{";
      peg$currPos += 1;
      r8 = void 0;
      peg$currPos = p7;
    } else {
      r8 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_2;
    }
    // free p7
    r9 = peg$parsetplarg_or_template(silence, boolParams, param_templatedepth, param_th, param_preproc);
    // r <- r9
    if (r9===peg$FAILED) {
      peg$currPos = p4;
      r1 = peg$FAILED;
      break seq_2;
    }
    r1 = true;
    } // seq_2
    if (r1!==peg$FAILED) {
      peg$savedPos = p3;
      r1 = peg$a21(r9);
      break choice_1;
    }
    // free p4
    p4 = peg$currPos;
    seq_3: {
    p7 = peg$currPos;
    p10 = peg$currPos;
    r11 = input.substr(peg$currPos,2);
    if (r11 === "-{") {
      peg$currPos += 2;
      r11 = void 0;
      peg$currPos = p10;
    } else {
      r11 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_3;
    }
    // free p10
    r12 = peg$parselang_variant_or_tpl(silence, boolParams, param_templatedepth, param_th, param_preproc);
    // r <- r12
    if (r12===peg$FAILED) {
      peg$currPos = p7;
      r1 = peg$FAILED;
      break seq_3;
    }
    r1 = true;
    } // seq_3
    if (r1!==peg$FAILED) {
      peg$savedPos = p4;
      r1 = peg$a21(r12);
      break choice_1;
    }
    // free p7
    p7 = peg$currPos;
    r1 = peg$FAILED;
    for (;;) {
      seq_4: {
      p10 = peg$currPos;
      r14 = input.substr(peg$currPos,2);
      if (r14 === "[[") {
        peg$currPos += 2;
      } else {
        if (!silence) {peg$fail(peg$c45);}
        r14 = peg$FAILED;
        r13 = peg$FAILED;
        break seq_4;
      }
      p15 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 91) {
        r16 = "[";
        peg$currPos += 1;
        r16 = void 0;
        peg$currPos = p15;
      } else {
        r16 = peg$FAILED;
        peg$currPos = p10;
        r13 = peg$FAILED;
        break seq_4;
      }
      // free p15
      r13 = true;
      } // seq_4
      if (r13!==peg$FAILED) {
        r1 = true;
      } else {
        break;
      }
      // free p10
    }
    if (r1!==peg$FAILED) {
      r1 = input.substring(p7, peg$currPos);
      break choice_1;
    } else {
      r1 = peg$FAILED;
    }
    // free r13
    // free p7
    p7 = peg$currPos;
    seq_5: {
    p10 = peg$currPos;
    p15 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 91) {
      r13 = "[";
      peg$currPos += 1;
      r13 = void 0;
      peg$currPos = p15;
    } else {
      r13 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_5;
    }
    // free p15
    choice_3: {
    r17 = peg$parsewikilink(silence, boolParams, param_templatedepth, param_th, param_preproc);
    if (r17!==peg$FAILED) {
      break choice_3;
    }
    r17 = peg$parseextlink(silence, boolParams, param_templatedepth, param_preproc, param_th);
    } // choice_3
    // r <- r17
    if (r17===peg$FAILED) {
      peg$currPos = p10;
      r1 = peg$FAILED;
      break seq_5;
    }
    r1 = true;
    } // seq_5
    if (r1!==peg$FAILED) {
      peg$savedPos = p7;
      r1 = peg$a21(r17);
      break choice_1;
    }
    // free p10
    p10 = peg$currPos;
    seq_6: {
    p15 = peg$currPos;
    p18 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 39) {
      r19 = "'";
      peg$currPos += 1;
      r19 = void 0;
      peg$currPos = p18;
    } else {
      r19 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_6;
    }
    // free p18
    r20 = peg$parsequote(silence);
    // r <- r20
    if (r20===peg$FAILED) {
      peg$currPos = p15;
      r1 = peg$FAILED;
      break seq_6;
    }
    r1 = true;
    } // seq_6
    if (r1!==peg$FAILED) {
      peg$savedPos = p10;
      r1 = peg$a21(r20);
    }
    // free p15
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$discardsof(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 533;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    peg$savedPos = peg$currPos;
    r1 = peg$a60();
    if (r1) {
      r1 = void 0;
    } else {
      r1 = peg$FAILED;
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parseredirect(silence, boolParams, param_templatedepth, param_th, param_preproc) {
    var r1,p2,p3,r4,r5,p6,r7,p8,r9,r10,r11;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [286, boolParams & 0x3bff, param_templatedepth, param_th.value, param_preproc.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
        return cached.result;
      }
        var saved_th=param_th.value;
        var saved_preproc=param_preproc.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = peg$parseredirect_word(silence);
    // rw <- r4
    if (r4===peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    p6 = peg$currPos;
    for (;;) {
      r7 = peg$discardspace_or_newline(silence);
      if (r7===peg$FAILED) {
        break;
      }
    }
    // free r7
    r5 = true;
    // sp <- r5
    if (r5!==peg$FAILED) {
      r5 = input.substring(p6, peg$currPos);
    } else {
      r5 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p6
    p6 = peg$currPos;
    seq_2: {
    p8 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 58) {
      r9 = ":";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c18);}
      r9 = peg$FAILED;
      r7 = peg$FAILED;
      break seq_2;
    }
    for (;;) {
      r11 = peg$discardspace_or_newline(silence);
      if (r11===peg$FAILED) {
        break;
      }
    }
    // free r11
    r10 = true;
    if (r10===peg$FAILED) {
      peg$currPos = p8;
      r7 = peg$FAILED;
      break seq_2;
    }
    // free r10
    r7 = true;
    } // seq_2
    if (r7===peg$FAILED) {
      r7 = null;
    }
    // free p8
    // c <- r7
    r7 = input.substring(p6, peg$currPos);
    // free p6
    r10 = peg$parsewikilink(silence, boolParams, param_templatedepth, param_th, param_preproc);
    // wl <- r10
    if (r10===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    peg$savedPos = peg$currPos;
    r11 = peg$a61(r4, r5, r7, r10);
    if (r11) {
      r11 = void 0;
    } else {
      r11 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a62(r4, r5, r7, r10);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_th !== param_th.value) cached.$th = param_th.value;
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
    }
    return r1;
  }
  function peg$parsecomment_or_includes(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,r2;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [518, boolParams & 0x13af, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    r1 = [];
    for (;;) {
      choice_1: {
      r2 = peg$parsecomment(silence);
      if (r2!==peg$FAILED) {
        break choice_1;
      }
      r2 = peg$parseinclude_limits(silence, boolParams | 0x2000, param_templatedepth, param_preproc, param_th);
      } // choice_1
      if (r2!==peg$FAILED) {
        r1.push(r2);
      } else {
        break;
      }
    }
    // free r2
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parseblock_line(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,p6,p7,p8,r9,r10,r11,r12,p13,p14,r15,r16;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [308, boolParams & 0x3bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    r1 = peg$parseheading(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    r1 = peg$parselist_item(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    r1 = peg$parsehr(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = peg$parseoptionalSpaceToken(silence);
    // st <- r4
    if (r4===peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    choice_2: {
    p6 = peg$currPos;
    seq_2: {
    p7 = peg$currPos;
    p8 = peg$currPos;
    r9 = input.charAt(peg$currPos);
    if (/^[ <{}|!]/.test(r9)) {
      peg$currPos++;
      r9 = void 0;
      peg$currPos = p8;
    } else {
      r9 = peg$FAILED;
      r5 = peg$FAILED;
      break seq_2;
    }
    // free p8
    r10 = peg$parsetable_line(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // tl <- r10
    if (r10===peg$FAILED) {
      peg$currPos = p7;
      r5 = peg$FAILED;
      break seq_2;
    }
    r5 = true;
    } // seq_2
    if (r5!==peg$FAILED) {
      peg$savedPos = p6;
      r5 = peg$a63(r4, r10);
      break choice_2;
    }
    // free p7
    p7 = peg$currPos;
    seq_3: {
    p8 = peg$currPos;
    r11 = [];
    for (;;) {
      p13 = peg$currPos;
      seq_4: {
      p14 = peg$currPos;
      r15 = peg$parseblock_tag(silence, boolParams, param_templatedepth, param_preproc, param_th);
      // bt <- r15
      if (r15===peg$FAILED) {
        r12 = peg$FAILED;
        break seq_4;
      }
      r16 = peg$parseoptionalSpaceToken(silence);
      // stl <- r16
      if (r16===peg$FAILED) {
        peg$currPos = p14;
        r12 = peg$FAILED;
        break seq_4;
      }
      r12 = true;
      } // seq_4
      if (r12!==peg$FAILED) {
        peg$savedPos = p13;
        r12 = peg$a64(r4, r15, r16);
        r11.push(r12);
      } else {
        break;
      }
      // free p14
    }
    if (r11.length === 0) {
      r11 = peg$FAILED;
    }
    // bts <- r11
    if (r11===peg$FAILED) {
      r5 = peg$FAILED;
      break seq_3;
    }
    // free r12
    p14 = peg$currPos;
    r12 = peg$discardeolf(true);
    if (r12!==peg$FAILED) {
      r12 = void 0;
      peg$currPos = p14;
    } else {
      peg$currPos = p8;
      r5 = peg$FAILED;
      break seq_3;
    }
    // free p14
    r5 = true;
    } // seq_3
    if (r5!==peg$FAILED) {
      peg$savedPos = p7;
      r5 = peg$a65(r4, r11);
    }
    // free p8
    } // choice_2
    // r <- r5
    if (r5===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a66(r4, r5);
    }
    // free p3
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parseblock_lines(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,p6,p7,r8,r9,r10;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [304, boolParams & 0x3bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = peg$parsesol(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // s <- r4
    if (r4===peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    p6 = peg$currPos;
    seq_2: {
    p7 = peg$currPos;
    r8 = peg$parseoptionalSpaceToken(silence);
    // os <- r8
    if (r8===peg$FAILED) {
      r5 = peg$FAILED;
      break seq_2;
    }
    r9 = peg$parsesol(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // so <- r9
    if (r9===peg$FAILED) {
      peg$currPos = p7;
      r5 = peg$FAILED;
      break seq_2;
    }
    r5 = true;
    } // seq_2
    if (r5!==peg$FAILED) {
      peg$savedPos = p6;
      r5 = peg$a67(r4, r8, r9);
    } else {
      r5 = null;
    }
    // free p7
    // s2 <- r5
    r10 = peg$parseblock_line(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // bl <- r10
    if (r10===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a68(r4, r5, r10);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$discardeolf(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 541;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    r1 = peg$discardnewline(silence);
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    r1 = peg$discardeof(silence);
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parseblock_tag(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [430, boolParams & 0x33af, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 60) {
      r4 = "<";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c46);}
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    choice_1: {
    r5 = peg$parsexmlish_tag_opened(silence, boolParams | 0xc00, param_templatedepth, param_preproc, param_th);
    if (r5!==peg$FAILED) {
      break choice_1;
    }
    r5 = peg$parsexmlish_tag_opened(silence, (boolParams & ~0x800) | 0x400, param_templatedepth, param_preproc, param_th);
    } // choice_1
    // tag <- r5
    if (r5===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a69(r5);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parseparagraph(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,r6;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [310, boolParams & 0x3bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = peg$parsesol(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // s1 <- r4
    if (r4===peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    r5 = peg$parsesol(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // s2 <- r5
    if (r5===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r6 = peg$parseinlineline(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // c <- r6
    if (r6===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a70(r4, r5, r6);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsesol(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var p1,r2,r3,r4;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [520, boolParams & 0x13af, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    seq_1: {
    p1 = peg$currPos;
    choice_1: {
    r3 = peg$parseempty_line_with_comments(silence);
    if (r3!==peg$FAILED) {
      break choice_1;
    }
    r3 = peg$parsesol_prefix(silence);
    } // choice_1
    if (r3===peg$FAILED) {
      r2 = peg$FAILED;
      break seq_1;
    }
    r4 = peg$parsecomment_or_includes(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r4===peg$FAILED) {
      peg$currPos = p1;
      r2 = peg$FAILED;
      break seq_1;
    }
    r2 = [r3,r4];
    } // seq_1
    // free r2,p1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r2,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r2;
  }
  function peg$discardtplarg(silence, boolParams, param_templatedepth, param_th) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [359, boolParams & 0x3bff, param_templatedepth, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    r1 = peg$discardtplarg_preproc(silence, boolParams, param_templatedepth, new peg$Reference("}}"), param_th);
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsetemplate(silence, boolParams, param_templatedepth, param_th) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [352, boolParams & 0x3bff, param_templatedepth, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    r1 = peg$parsetemplate_preproc(silence, boolParams, param_templatedepth, new peg$Reference("}}"), param_th);
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsebroken_template(silence, param_preproc) {
    var r1,p2,p3,r4;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [354, param_preproc.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = input.substr(peg$currPos,2);
    // t <- r4
    if (r4 === "{{") {
      peg$currPos += 2;
    } else {
      if (!silence) {peg$fail(peg$c47);}
      r4 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a71(param_preproc, r4);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
    }
    return r1;
  }
  function peg$parsetplarg(silence, boolParams, param_templatedepth, param_th) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [358, boolParams & 0x3bff, param_templatedepth, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    r1 = peg$parsetplarg_preproc(silence, boolParams, param_templatedepth, new peg$Reference("}}"), param_th);
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$discardwikilink(silence, boolParams, param_templatedepth, param_th, param_preproc) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [403, boolParams & 0x3bff, param_templatedepth, param_th.value, param_preproc.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
        return cached.result;
      }
        var saved_th=param_th.value;
        var saved_preproc=param_preproc.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    r1 = peg$discardwikilink_preproc(silence, boolParams, param_templatedepth, new peg$Reference("]]"), param_th);
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    r1 = peg$discardbroken_wikilink(silence, boolParams, param_preproc, param_templatedepth, param_th);
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_th !== param_th.value) cached.$th = param_th.value;
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
    }
    return r1;
  }
  function peg$parsedirective(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,p4,r5,r6,p7,r8,r9;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [544, boolParams & 0x3bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    r1 = peg$parsecomment(silence);
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    r1 = peg$parseextension_tag(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    r1 = peg$parsetplarg_or_template(silence, boolParams, param_templatedepth, param_th, param_preproc);
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p4 = peg$currPos;
    r5 = input.substr(peg$currPos,2);
    if (r5 === "-{") {
      peg$currPos += 2;
      r5 = void 0;
      peg$currPos = p4;
    } else {
      r5 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p4
    r6 = peg$parselang_variant_or_tpl(silence, boolParams, param_templatedepth, param_th, param_preproc);
    // v <- r6
    if (r6===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a72(r6);
      break choice_1;
    }
    // free p3
    p3 = peg$currPos;
    seq_2: {
    p4 = peg$currPos;
    p7 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 38) {
      r8 = "&";
      peg$currPos += 1;
      r8 = void 0;
      peg$currPos = p7;
    } else {
      r8 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_2;
    }
    // free p7
    r9 = peg$parsehtmlentity(silence);
    // e <- r9
    if (r9===peg$FAILED) {
      peg$currPos = p4;
      r1 = peg$FAILED;
      break seq_2;
    }
    r1 = true;
    } // seq_2
    if (r1!==peg$FAILED) {
      peg$savedPos = p3;
      r1 = peg$a73(r9);
      break choice_1;
    }
    // free p4
    r1 = peg$parseinclude_limits(silence, boolParams, param_templatedepth, param_preproc, param_th);
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$discardxmlish_tag(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [427, boolParams & 0x33af, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 60) {
      r4 = "<";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c46);}
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    choice_1: {
    r5 = peg$parsexmlish_tag_opened(silence, (boolParams & ~0x400) | 0x800, param_templatedepth, param_preproc, param_th);
    if (r5!==peg$FAILED) {
      break choice_1;
    }
    r5 = peg$parsexmlish_tag_opened(silence, boolParams & ~0xc00, param_templatedepth, param_preproc, param_th);
    } // choice_1
    // tag <- r5
    if (r5===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a69(r5);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsetable_attribute_preprocessor_text_single(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,r3,r4,p5,r6,p7,p8,r9;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [560, boolParams & 0x3bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    r3 = [];
    for (;;) {
      choice_1: {
      p5 = peg$currPos;
      r4 = peg$FAILED;
      for (;;) {
        r6 = input.charAt(peg$currPos);
        if (/^[^{}&<\-!['\r\n|]/.test(r6)) {
          peg$currPos++;
          r4 = true;
        } else {
          r6 = peg$FAILED;
          if (!silence) {peg$fail(peg$c48);}
          break;
        }
      }
      if (r4!==peg$FAILED) {
        r4 = input.substring(p5, peg$currPos);
        break choice_1;
      } else {
        r4 = peg$FAILED;
      }
      // free r6
      // free p5
      p5 = peg$currPos;
      seq_1: {
      p7 = peg$currPos;
      p8 = peg$currPos;
      r6 = peg$discardinline_breaks(true, boolParams, param_templatedepth, param_preproc, param_th);
      if (r6 === peg$FAILED) {
        r6 = void 0;
      } else {
        r6 = peg$FAILED;
        peg$currPos = p8;
        r4 = peg$FAILED;
        break seq_1;
      }
      // free p8
      choice_2: {
      r9 = peg$parsedirective(silence, boolParams, param_templatedepth, param_preproc, param_th);
      if (r9!==peg$FAILED) {
        break choice_2;
      }
      r9 = input.charAt(peg$currPos);
      if (/^[{}&<\-![]/.test(r9)) {
        peg$currPos++;
      } else {
        r9 = peg$FAILED;
        if (!silence) {peg$fail(peg$c49);}
      }
      } // choice_2
      // s <- r9
      if (r9===peg$FAILED) {
        peg$currPos = p7;
        r4 = peg$FAILED;
        break seq_1;
      }
      r4 = true;
      } // seq_1
      if (r4!==peg$FAILED) {
        peg$savedPos = p5;
        r4 = peg$a40(r9);
      }
      // free p7
      } // choice_1
      if (r4!==peg$FAILED) {
        r3.push(r4);
      } else {
        break;
      }
    }
    // r <- r3
    // free r4
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a74(r3);
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsetable_attribute_preprocessor_text_double(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,r3,r4,p5,r6,p7,p8,r9;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [562, boolParams & 0x3bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    r3 = [];
    for (;;) {
      choice_1: {
      p5 = peg$currPos;
      r4 = peg$FAILED;
      for (;;) {
        r6 = input.charAt(peg$currPos);
        if (/^[^{}&<\-!["\r\n|]/.test(r6)) {
          peg$currPos++;
          r4 = true;
        } else {
          r6 = peg$FAILED;
          if (!silence) {peg$fail(peg$c50);}
          break;
        }
      }
      if (r4!==peg$FAILED) {
        r4 = input.substring(p5, peg$currPos);
        break choice_1;
      } else {
        r4 = peg$FAILED;
      }
      // free r6
      // free p5
      p5 = peg$currPos;
      seq_1: {
      p7 = peg$currPos;
      p8 = peg$currPos;
      r6 = peg$discardinline_breaks(true, boolParams, param_templatedepth, param_preproc, param_th);
      if (r6 === peg$FAILED) {
        r6 = void 0;
      } else {
        r6 = peg$FAILED;
        peg$currPos = p8;
        r4 = peg$FAILED;
        break seq_1;
      }
      // free p8
      choice_2: {
      r9 = peg$parsedirective(silence, boolParams, param_templatedepth, param_preproc, param_th);
      if (r9!==peg$FAILED) {
        break choice_2;
      }
      r9 = input.charAt(peg$currPos);
      if (/^[{}&<\-![]/.test(r9)) {
        peg$currPos++;
      } else {
        r9 = peg$FAILED;
        if (!silence) {peg$fail(peg$c49);}
      }
      } // choice_2
      // s <- r9
      if (r9===peg$FAILED) {
        peg$currPos = p7;
        r4 = peg$FAILED;
        break seq_1;
      }
      r4 = true;
      } // seq_1
      if (r4!==peg$FAILED) {
        peg$savedPos = p5;
        r4 = peg$a40(r9);
      }
      // free p7
      } // choice_1
      if (r4!==peg$FAILED) {
        r3.push(r4);
      } else {
        break;
      }
    }
    // r <- r3
    // free r4
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a74(r3);
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsetable_attribute_preprocessor_text(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,r3,r4,p5,r6,p7,p8,r9;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [558, boolParams & 0x3bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    r3 = [];
    for (;;) {
      choice_1: {
      p5 = peg$currPos;
      r4 = peg$FAILED;
      for (;;) {
        r6 = input.charAt(peg$currPos);
        if (/^[^{}&<\-![ \t\n\r\f|]/.test(r6)) {
          peg$currPos++;
          r4 = true;
        } else {
          r6 = peg$FAILED;
          if (!silence) {peg$fail(peg$c51);}
          break;
        }
      }
      if (r4!==peg$FAILED) {
        r4 = input.substring(p5, peg$currPos);
        break choice_1;
      } else {
        r4 = peg$FAILED;
      }
      // free r6
      // free p5
      p5 = peg$currPos;
      seq_1: {
      p7 = peg$currPos;
      p8 = peg$currPos;
      r6 = peg$discardinline_breaks(true, boolParams, param_templatedepth, param_preproc, param_th);
      if (r6 === peg$FAILED) {
        r6 = void 0;
      } else {
        r6 = peg$FAILED;
        peg$currPos = p8;
        r4 = peg$FAILED;
        break seq_1;
      }
      // free p8
      choice_2: {
      r9 = peg$parsedirective(silence, boolParams, param_templatedepth, param_preproc, param_th);
      if (r9!==peg$FAILED) {
        break choice_2;
      }
      r9 = input.charAt(peg$currPos);
      if (/^[{}&<\-![]/.test(r9)) {
        peg$currPos++;
      } else {
        r9 = peg$FAILED;
        if (!silence) {peg$fail(peg$c49);}
      }
      } // choice_2
      // s <- r9
      if (r9===peg$FAILED) {
        peg$currPos = p7;
        r4 = peg$FAILED;
        break seq_1;
      }
      r4 = true;
      } // seq_1
      if (r4!==peg$FAILED) {
        peg$savedPos = p5;
        r4 = peg$a40(r9);
      }
      // free p7
      } // choice_1
      if (r4!==peg$FAILED) {
        r3.push(r4);
      } else {
        break;
      }
    }
    if (r3.length === 0) {
      r3 = peg$FAILED;
    }
    // r <- r3
    // free r4
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a74(r3);
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parseless_than(silence, boolParams) {
    var p1,r2,p3,r4,r5;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [436, boolParams & 0x800].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    p1 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    if (/*extTag*/(boolParams & 0x800) !== 0) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      r2 = peg$FAILED;
      break seq_1;
    }
    if (input.charCodeAt(peg$currPos) === 60) {
      r5 = "<";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c46);}
      r5 = peg$FAILED;
      peg$currPos = p3;
      r2 = peg$FAILED;
      break seq_1;
    }
    r2 = true;
    } // seq_1
    if (r2!==peg$FAILED) {
      r2 = input.substring(p1, peg$currPos);
    } else {
      r2 = peg$FAILED;
    }
    // free p3
    // free p1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r2,
      };
  
    }
    return r2;
  }
  function peg$parseattribute_preprocessor_text_single(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,r3,r4,p5,r6,p7,p8,r9,r10;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [554, boolParams & 0x3bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    r3 = [];
    for (;;) {
      choice_1: {
      p5 = peg$currPos;
      r4 = peg$FAILED;
      for (;;) {
        r6 = input.charAt(peg$currPos);
        if (/^[^{}&<\-|\/'>]/.test(r6)) {
          peg$currPos++;
          r4 = true;
        } else {
          r6 = peg$FAILED;
          if (!silence) {peg$fail(peg$c52);}
          break;
        }
      }
      if (r4!==peg$FAILED) {
        r4 = input.substring(p5, peg$currPos);
        break choice_1;
      } else {
        r4 = peg$FAILED;
      }
      // free r6
      // free p5
      p5 = peg$currPos;
      seq_1: {
      p7 = peg$currPos;
      p8 = peg$currPos;
      r6 = peg$discardinline_breaks(true, boolParams, param_templatedepth, param_preproc, param_th);
      if (r6 === peg$FAILED) {
        r6 = void 0;
      } else {
        r6 = peg$FAILED;
        peg$currPos = p8;
        r4 = peg$FAILED;
        break seq_1;
      }
      // free p8
      p8 = peg$currPos;
      r9 = input.substr(peg$currPos,2);
      if (r9 === "/>") {
        peg$currPos += 2;
      } else {
        r9 = peg$FAILED;
      }
      if (r9 === peg$FAILED) {
        r9 = void 0;
      } else {
        r9 = peg$FAILED;
        peg$currPos = p8;
        peg$currPos = p7;
        r4 = peg$FAILED;
        break seq_1;
      }
      // free p8
      choice_2: {
      r10 = peg$parsedirective(silence, boolParams, param_templatedepth, param_preproc, param_th);
      if (r10!==peg$FAILED) {
        break choice_2;
      }
      r10 = peg$parseless_than(silence, boolParams);
      if (r10!==peg$FAILED) {
        break choice_2;
      }
      r10 = input.charAt(peg$currPos);
      if (/^[{}&\-|\/]/.test(r10)) {
        peg$currPos++;
      } else {
        r10 = peg$FAILED;
        if (!silence) {peg$fail(peg$c53);}
      }
      } // choice_2
      // s <- r10
      if (r10===peg$FAILED) {
        peg$currPos = p7;
        r4 = peg$FAILED;
        break seq_1;
      }
      r4 = true;
      } // seq_1
      if (r4!==peg$FAILED) {
        peg$savedPos = p5;
        r4 = peg$a40(r10);
      }
      // free p7
      } // choice_1
      if (r4!==peg$FAILED) {
        r3.push(r4);
      } else {
        break;
      }
    }
    // r <- r3
    // free r4
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a74(r3);
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parseattribute_preprocessor_text_double(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,r3,r4,p5,r6,p7,p8,r9,r10;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [556, boolParams & 0x3bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    r3 = [];
    for (;;) {
      choice_1: {
      p5 = peg$currPos;
      r4 = peg$FAILED;
      for (;;) {
        r6 = input.charAt(peg$currPos);
        if (/^[^{}&<\-|\/">]/.test(r6)) {
          peg$currPos++;
          r4 = true;
        } else {
          r6 = peg$FAILED;
          if (!silence) {peg$fail(peg$c54);}
          break;
        }
      }
      if (r4!==peg$FAILED) {
        r4 = input.substring(p5, peg$currPos);
        break choice_1;
      } else {
        r4 = peg$FAILED;
      }
      // free r6
      // free p5
      p5 = peg$currPos;
      seq_1: {
      p7 = peg$currPos;
      p8 = peg$currPos;
      r6 = peg$discardinline_breaks(true, boolParams, param_templatedepth, param_preproc, param_th);
      if (r6 === peg$FAILED) {
        r6 = void 0;
      } else {
        r6 = peg$FAILED;
        peg$currPos = p8;
        r4 = peg$FAILED;
        break seq_1;
      }
      // free p8
      p8 = peg$currPos;
      r9 = input.substr(peg$currPos,2);
      if (r9 === "/>") {
        peg$currPos += 2;
      } else {
        r9 = peg$FAILED;
      }
      if (r9 === peg$FAILED) {
        r9 = void 0;
      } else {
        r9 = peg$FAILED;
        peg$currPos = p8;
        peg$currPos = p7;
        r4 = peg$FAILED;
        break seq_1;
      }
      // free p8
      choice_2: {
      r10 = peg$parsedirective(silence, boolParams, param_templatedepth, param_preproc, param_th);
      if (r10!==peg$FAILED) {
        break choice_2;
      }
      r10 = peg$parseless_than(silence, boolParams);
      if (r10!==peg$FAILED) {
        break choice_2;
      }
      r10 = input.charAt(peg$currPos);
      if (/^[{}&\-|\/]/.test(r10)) {
        peg$currPos++;
      } else {
        r10 = peg$FAILED;
        if (!silence) {peg$fail(peg$c53);}
      }
      } // choice_2
      // s <- r10
      if (r10===peg$FAILED) {
        peg$currPos = p7;
        r4 = peg$FAILED;
        break seq_1;
      }
      r4 = true;
      } // seq_1
      if (r4!==peg$FAILED) {
        peg$savedPos = p5;
        r4 = peg$a40(r10);
      }
      // free p7
      } // choice_1
      if (r4!==peg$FAILED) {
        r3.push(r4);
      } else {
        break;
      }
    }
    // r <- r3
    // free r4
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a74(r3);
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parseattribute_preprocessor_text(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,r3,r4,p5,r6,p7,p8,r9,r10;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [552, boolParams & 0x3bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    r3 = [];
    for (;;) {
      choice_1: {
      p5 = peg$currPos;
      r4 = peg$FAILED;
      for (;;) {
        r6 = input.charAt(peg$currPos);
        if (/^[^{}&<\-|\/ \t\n\r\f>]/.test(r6)) {
          peg$currPos++;
          r4 = true;
        } else {
          r6 = peg$FAILED;
          if (!silence) {peg$fail(peg$c55);}
          break;
        }
      }
      if (r4!==peg$FAILED) {
        r4 = input.substring(p5, peg$currPos);
        break choice_1;
      } else {
        r4 = peg$FAILED;
      }
      // free r6
      // free p5
      p5 = peg$currPos;
      seq_1: {
      p7 = peg$currPos;
      p8 = peg$currPos;
      r6 = peg$discardinline_breaks(true, boolParams, param_templatedepth, param_preproc, param_th);
      if (r6 === peg$FAILED) {
        r6 = void 0;
      } else {
        r6 = peg$FAILED;
        peg$currPos = p8;
        r4 = peg$FAILED;
        break seq_1;
      }
      // free p8
      p8 = peg$currPos;
      r9 = input.substr(peg$currPos,2);
      if (r9 === "/>") {
        peg$currPos += 2;
      } else {
        r9 = peg$FAILED;
      }
      if (r9 === peg$FAILED) {
        r9 = void 0;
      } else {
        r9 = peg$FAILED;
        peg$currPos = p8;
        peg$currPos = p7;
        r4 = peg$FAILED;
        break seq_1;
      }
      // free p8
      choice_2: {
      r10 = peg$parsedirective(silence, boolParams, param_templatedepth, param_preproc, param_th);
      if (r10!==peg$FAILED) {
        break choice_2;
      }
      r10 = peg$parseless_than(silence, boolParams);
      if (r10!==peg$FAILED) {
        break choice_2;
      }
      r10 = input.charAt(peg$currPos);
      if (/^[{}&\-|\/]/.test(r10)) {
        peg$currPos++;
      } else {
        r10 = peg$FAILED;
        if (!silence) {peg$fail(peg$c53);}
      }
      } // choice_2
      // s <- r10
      if (r10===peg$FAILED) {
        peg$currPos = p7;
        r4 = peg$FAILED;
        break seq_1;
      }
      r4 = true;
      } // seq_1
      if (r4!==peg$FAILED) {
        peg$savedPos = p5;
        r4 = peg$a40(r10);
      }
      // free p7
      } // choice_1
      if (r4!==peg$FAILED) {
        r3.push(r4);
      } else {
        break;
      }
    }
    if (r3.length === 0) {
      r3 = peg$FAILED;
    }
    // r <- r3
    // free r4
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a74(r3);
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parseautolink(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,r6,p7,r8;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [328, boolParams & 0x3bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    if (!(/*extlink*/(boolParams & 0x4) !== 0)) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    peg$savedPos = peg$currPos;
    r5 = peg$a75();
    if (!r5) {
      r5 = void 0;
    } else {
      r5 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    choice_1: {
    p7 = peg$currPos;
    r8 = peg$parseautourl(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // target <- r8
    r6 = r8;
    if (r6!==peg$FAILED) {
      peg$savedPos = p7;
      r6 = peg$a76(r8);
      break choice_1;
    }
    r6 = peg$parseautoref(silence);
    if (r6!==peg$FAILED) {
      break choice_1;
    }
    r6 = peg$parseisbn(silence);
    } // choice_1
    // r <- r6
    if (r6===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a21(r6);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsebehavior_switch(silence) {
    var r1,p2,r3,p4,p5,r6,r7,r8;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 324;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    p4 = peg$currPos;
    seq_1: {
    p5 = peg$currPos;
    r6 = input.substr(peg$currPos,2);
    if (r6 === "__") {
      peg$currPos += 2;
    } else {
      if (!silence) {peg$fail(peg$c56);}
      r6 = peg$FAILED;
      r3 = peg$FAILED;
      break seq_1;
    }
    r7 = peg$discardbehavior_text(silence);
    if (r7===peg$FAILED) {
      peg$currPos = p5;
      r3 = peg$FAILED;
      break seq_1;
    }
    r8 = input.substr(peg$currPos,2);
    if (r8 === "__") {
      peg$currPos += 2;
    } else {
      if (!silence) {peg$fail(peg$c56);}
      r8 = peg$FAILED;
      peg$currPos = p5;
      r3 = peg$FAILED;
      break seq_1;
    }
    r3 = true;
    } // seq_1
    // bs <- r3
    if (r3!==peg$FAILED) {
      r3 = input.substring(p4, peg$currPos);
    } else {
      r3 = peg$FAILED;
    }
    // free p5
    // free p4
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a77(r3);
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parsexmlish_tag(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [426, boolParams & 0x33af, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 60) {
      r4 = "<";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c46);}
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    choice_1: {
    r5 = peg$parsexmlish_tag_opened(silence, (boolParams & ~0x400) | 0x800, param_templatedepth, param_preproc, param_th);
    if (r5!==peg$FAILED) {
      break choice_1;
    }
    r5 = peg$parsexmlish_tag_opened(silence, boolParams & ~0xc00, param_templatedepth, param_preproc, param_th);
    } // choice_1
    // tag <- r5
    if (r5===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a69(r5);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parselang_variant_or_tpl(silence, boolParams, param_templatedepth, param_th, param_preproc) {
    var r1,p2,p3,p4,r5,p6,r7,p8,r9,p10,r11,r12,p13,r14,r15,r16,r17,r18,r19,r20,p21,r22,r23,r24,r25,r26,r27,r28,p29,r30,r31;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [370, boolParams & 0x3bff, param_templatedepth, param_th.value, param_preproc.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
        return cached.result;
      }
        var saved_th=param_th.value;
        var saved_preproc=param_preproc.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p4 = peg$currPos;
    seq_2: {
    p6 = peg$currPos;
    r7 = input.substr(peg$currPos,2);
    if (r7 === "-{") {
      peg$currPos += 2;
    } else {
      r7 = peg$FAILED;
      r5 = peg$FAILED;
      break seq_2;
    }
    p8 = peg$currPos;
    seq_3: {
    p10 = peg$currPos;
    r11 = peg$FAILED;
    for (;;) {
      r12 = input.substr(peg$currPos,3);
      if (r12 === "{{{") {
        peg$currPos += 3;
        r11 = true;
      } else {
        r12 = peg$FAILED;
        break;
      }
    }
    if (r11===peg$FAILED) {
      r9 = peg$FAILED;
      break seq_3;
    }
    // free r12
    p13 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 123) {
      r12 = "{";
      peg$currPos += 1;
    } else {
      r12 = peg$FAILED;
    }
    if (r12 === peg$FAILED) {
      r12 = void 0;
    } else {
      r12 = peg$FAILED;
      peg$currPos = p13;
      peg$currPos = p10;
      r9 = peg$FAILED;
      break seq_3;
    }
    // free p13
    r9 = true;
    } // seq_3
    if (r9!==peg$FAILED) {
      r9 = void 0;
      peg$currPos = p8;
    } else {
      peg$currPos = p6;
      r5 = peg$FAILED;
      break seq_2;
    }
    // free p10
    // free p8
    r14 = peg$discardtplarg(true, boolParams, param_templatedepth, param_th);
    if (r14===peg$FAILED) {
      peg$currPos = p6;
      r5 = peg$FAILED;
      break seq_2;
    }
    r5 = true;
    } // seq_2
    if (r5!==peg$FAILED) {
      r5 = void 0;
      peg$currPos = p4;
    } else {
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p6
    // free p4
    r15 = peg$parselang_variant(silence, boolParams, param_templatedepth, param_th, param_preproc);
    // a <- r15
    if (r15===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a46(r15);
      break choice_1;
    }
    // free p3
    p3 = peg$currPos;
    seq_4: {
    p4 = peg$currPos;
    p6 = peg$currPos;
    seq_5: {
    p8 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 45) {
      r17 = "-";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c57);}
      r17 = peg$FAILED;
      r16 = peg$FAILED;
      break seq_5;
    }
    p10 = peg$currPos;
    seq_6: {
    p13 = peg$currPos;
    r19 = peg$FAILED;
    for (;;) {
      r20 = input.substr(peg$currPos,3);
      if (r20 === "{{{") {
        peg$currPos += 3;
        r19 = true;
      } else {
        r20 = peg$FAILED;
        break;
      }
    }
    if (r19===peg$FAILED) {
      r18 = peg$FAILED;
      break seq_6;
    }
    // free r20
    p21 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 123) {
      r20 = "{";
      peg$currPos += 1;
    } else {
      r20 = peg$FAILED;
    }
    if (r20 === peg$FAILED) {
      r20 = void 0;
    } else {
      r20 = peg$FAILED;
      peg$currPos = p21;
      peg$currPos = p13;
      r18 = peg$FAILED;
      break seq_6;
    }
    // free p21
    r18 = true;
    } // seq_6
    if (r18!==peg$FAILED) {
      r18 = void 0;
      peg$currPos = p10;
    } else {
      peg$currPos = p8;
      r16 = peg$FAILED;
      break seq_5;
    }
    // free p13
    // free p10
    r16 = true;
    } // seq_5
    // a <- r16
    if (r16!==peg$FAILED) {
      r16 = input.substring(p6, peg$currPos);
    } else {
      r16 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_4;
    }
    // free p8
    // free p6
    r22 = peg$parsetplarg(silence, boolParams, param_templatedepth, param_th);
    // b <- r22
    if (r22===peg$FAILED) {
      peg$currPos = p4;
      r1 = peg$FAILED;
      break seq_4;
    }
    r1 = true;
    } // seq_4
    if (r1!==peg$FAILED) {
      peg$savedPos = p3;
      r1 = peg$a47(r16, r22);
      break choice_1;
    }
    // free p4
    p4 = peg$currPos;
    seq_7: {
    p6 = peg$currPos;
    p8 = peg$currPos;
    seq_8: {
    p10 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 45) {
      r24 = "-";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c57);}
      r24 = peg$FAILED;
      r23 = peg$FAILED;
      break seq_8;
    }
    p13 = peg$currPos;
    seq_9: {
    p21 = peg$currPos;
    r26 = input.substr(peg$currPos,2);
    if (r26 === "{{") {
      peg$currPos += 2;
    } else {
      r26 = peg$FAILED;
      r25 = peg$FAILED;
      break seq_9;
    }
    for (;;) {
      r28 = input.substr(peg$currPos,3);
      if (r28 === "{{{") {
        peg$currPos += 3;
      } else {
        r28 = peg$FAILED;
        break;
      }
    }
    // free r28
    r27 = true;
    if (r27===peg$FAILED) {
      peg$currPos = p21;
      r25 = peg$FAILED;
      break seq_9;
    }
    // free r27
    p29 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 123) {
      r27 = "{";
      peg$currPos += 1;
    } else {
      r27 = peg$FAILED;
    }
    if (r27 === peg$FAILED) {
      r27 = void 0;
    } else {
      r27 = peg$FAILED;
      peg$currPos = p29;
      peg$currPos = p21;
      r25 = peg$FAILED;
      break seq_9;
    }
    // free p29
    r25 = true;
    } // seq_9
    if (r25!==peg$FAILED) {
      r25 = void 0;
      peg$currPos = p13;
    } else {
      peg$currPos = p10;
      r23 = peg$FAILED;
      break seq_8;
    }
    // free p21
    // free p13
    r23 = true;
    } // seq_8
    // a <- r23
    if (r23!==peg$FAILED) {
      r23 = input.substring(p8, peg$currPos);
    } else {
      r23 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_7;
    }
    // free p10
    // free p8
    r28 = peg$parsetemplate(silence, boolParams, param_templatedepth, param_th);
    // b <- r28
    if (r28===peg$FAILED) {
      peg$currPos = p6;
      r1 = peg$FAILED;
      break seq_7;
    }
    r1 = true;
    } // seq_7
    if (r1!==peg$FAILED) {
      peg$savedPos = p4;
      r1 = peg$a47(r23, r28);
      break choice_1;
    }
    // free p6
    p6 = peg$currPos;
    seq_10: {
    p8 = peg$currPos;
    p10 = peg$currPos;
    r30 = input.substr(peg$currPos,2);
    if (r30 === "-{") {
      peg$currPos += 2;
      r30 = void 0;
      peg$currPos = p10;
    } else {
      r30 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_10;
    }
    // free p10
    r31 = peg$parselang_variant(silence, boolParams, param_templatedepth, param_th, param_preproc);
    // a <- r31
    if (r31===peg$FAILED) {
      peg$currPos = p8;
      r1 = peg$FAILED;
      break seq_10;
    }
    r1 = true;
    } // seq_10
    if (r1!==peg$FAILED) {
      peg$savedPos = p6;
      r1 = peg$a46(r31);
    }
    // free p8
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_th !== param_th.value) cached.$th = param_th.value;
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
    }
    return r1;
  }
  function peg$parsewikilink(silence, boolParams, param_templatedepth, param_th, param_preproc) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [402, boolParams & 0x3bff, param_templatedepth, param_th.value, param_preproc.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
        return cached.result;
      }
        var saved_th=param_th.value;
        var saved_preproc=param_preproc.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    r1 = peg$parsewikilink_preproc(silence, boolParams, param_templatedepth, new peg$Reference("]]"), param_th);
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    r1 = peg$parsebroken_wikilink(silence, boolParams, param_preproc, param_templatedepth, param_th);
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_th !== param_th.value) cached.$th = param_th.value;
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
    }
    return r1;
  }
  function peg$parsequote(silence) {
    var r1,p2,r3,p4,p5,r6,r7,r8;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 412;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    p4 = peg$currPos;
    seq_1: {
    p5 = peg$currPos;
    r6 = input.substr(peg$currPos,2);
    if (r6 === "''") {
      peg$currPos += 2;
    } else {
      if (!silence) {peg$fail(peg$c58);}
      r6 = peg$FAILED;
      r3 = peg$FAILED;
      break seq_1;
    }
    for (;;) {
      if (input.charCodeAt(peg$currPos) === 39) {
        r8 = "'";
        peg$currPos += 1;
      } else {
        if (!silence) {peg$fail(peg$c34);}
        r8 = peg$FAILED;
        break;
      }
    }
    // free r8
    r7 = true;
    if (r7===peg$FAILED) {
      peg$currPos = p5;
      r3 = peg$FAILED;
      break seq_1;
    }
    // free r7
    r3 = true;
    } // seq_1
    // quotes <- r3
    if (r3!==peg$FAILED) {
      r3 = input.substring(p4, peg$currPos);
    } else {
      r3 = peg$FAILED;
    }
    // free p5
    // free p4
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a78(r3);
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parseredirect_word(silence) {
    var p1,r2,p3,r4,r5,p6,p7,p8,r9,r10,r11;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 292;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    p1 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    for (;;) {
      r5 = input.charAt(peg$currPos);
      if (/^[ \t\n\r\0\x0B]/.test(r5)) {
        peg$currPos++;
      } else {
        r5 = peg$FAILED;
        if (!silence) {peg$fail(peg$c59);}
        break;
      }
    }
    // free r5
    r4 = true;
    if (r4===peg$FAILED) {
      r2 = peg$FAILED;
      break seq_1;
    }
    // free r4
    p6 = peg$currPos;
    r4 = peg$FAILED;
    for (;;) {
      seq_2: {
      p7 = peg$currPos;
      p8 = peg$currPos;
      r9 = peg$discardspace_or_newline(true);
      if (r9 === peg$FAILED) {
        r9 = void 0;
      } else {
        r9 = peg$FAILED;
        peg$currPos = p8;
        r5 = peg$FAILED;
        break seq_2;
      }
      // free p8
      p8 = peg$currPos;
      r10 = input.charAt(peg$currPos);
      if (/^[:[]/.test(r10)) {
        peg$currPos++;
      } else {
        r10 = peg$FAILED;
      }
      if (r10 === peg$FAILED) {
        r10 = void 0;
      } else {
        r10 = peg$FAILED;
        peg$currPos = p8;
        peg$currPos = p7;
        r5 = peg$FAILED;
        break seq_2;
      }
      // free p8
      if (peg$currPos < input.length) {
        r11 = input.charAt(peg$currPos++);
      } else {
        r11 = peg$FAILED;
        if (!silence) {peg$fail(peg$c11);}
        peg$currPos = p7;
        r5 = peg$FAILED;
        break seq_2;
      }
      r5 = true;
      } // seq_2
      if (r5!==peg$FAILED) {
        r4 = true;
      } else {
        break;
      }
      // free p7
    }
    // rw <- r4
    if (r4!==peg$FAILED) {
      r4 = input.substring(p6, peg$currPos);
    } else {
      r4 = peg$FAILED;
      peg$currPos = p3;
      r2 = peg$FAILED;
      break seq_1;
    }
    // free r5
    // free p6
    peg$savedPos = peg$currPos;
    r5 = peg$a79(r4);
    if (r5) {
      r5 = void 0;
    } else {
      r5 = peg$FAILED;
      peg$currPos = p3;
      r2 = peg$FAILED;
      break seq_1;
    }
    r2 = true;
    } // seq_1
    if (r2!==peg$FAILED) {
      r2 = input.substring(p1, peg$currPos);
    } else {
      r2 = peg$FAILED;
    }
    // free p3
    // free p1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r2,
      };
  
    }
    return r2;
  }
  function peg$parseinclude_limits(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,p4,r5,p6,r7,r8,r9,p10,r11,r12,r13;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [530, boolParams & 0x33af, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p4 = peg$currPos;
    seq_2: {
    p6 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 60) {
      r7 = "<";
      peg$currPos += 1;
    } else {
      r7 = peg$FAILED;
      r5 = peg$FAILED;
      break seq_2;
    }
    if (input.charCodeAt(peg$currPos) === 47) {
      r8 = "/";
      peg$currPos += 1;
    } else {
      r8 = peg$FAILED;
      r8 = null;
    }
    p10 = peg$currPos;
    r9 = peg$FAILED;
    for (;;) {
      r11 = input.charAt(peg$currPos);
      if (/^[oyinclude]/i.test(r11)) {
        peg$currPos++;
        r9 = true;
      } else {
        r11 = peg$FAILED;
        break;
      }
    }
    // n <- r9
    if (r9!==peg$FAILED) {
      r9 = input.substring(p10, peg$currPos);
    } else {
      r9 = peg$FAILED;
      peg$currPos = p6;
      r5 = peg$FAILED;
      break seq_2;
    }
    // free r11
    // free p10
    peg$savedPos = peg$currPos;
    r11 = peg$a80(r9);
    if (r11) {
      r11 = void 0;
    } else {
      r11 = peg$FAILED;
      peg$currPos = p6;
      r5 = peg$FAILED;
      break seq_2;
    }
    r5 = true;
    } // seq_2
    if (r5!==peg$FAILED) {
      r5 = void 0;
      peg$currPos = p4;
    } else {
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p6
    // free p4
    r12 = peg$parsexmlish_tag(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // il <- r12
    if (r12===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    peg$savedPos = peg$currPos;
    r13 = peg$a81(r12, /*sol_il*/(boolParams & 0x2000) !== 0);
    if (r13) {
      r13 = void 0;
    } else {
      r13 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a82(r12, /*sol_il*/(boolParams & 0x2000) !== 0);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parseheading(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,p4,r5,r6,p7,r8,p9,r10,r11,p12,r13,p14,r15,r16,r17,r18,r19;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [320, boolParams & 0x3bfd, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p4 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 61) {
      r5 = "=";
      peg$currPos += 1;
      r5 = void 0;
      peg$currPos = p4;
    } else {
      r5 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p4
    p4 = peg$currPos;
    seq_2: {
    p7 = peg$currPos;
    p9 = peg$currPos;
    r8 = peg$FAILED;
    for (;;) {
      if (input.charCodeAt(peg$currPos) === 61) {
        r10 = "=";
        peg$currPos += 1;
        r8 = true;
      } else {
        if (!silence) {peg$fail(peg$c23);}
        r10 = peg$FAILED;
        break;
      }
    }
    // s <- r8
    if (r8!==peg$FAILED) {
      r8 = input.substring(p9, peg$currPos);
    } else {
      r8 = peg$FAILED;
      r6 = peg$FAILED;
      break seq_2;
    }
    // free r10
    // free p9
    seq_3: {
    p9 = peg$currPos;
    p12 = peg$currPos;
    r13 = peg$parseinlineline(silence, boolParams | 0x2, param_templatedepth, param_preproc, param_th);
    if (r13===peg$FAILED) {
      r13 = null;
    }
    // ill <- r13
    r11 = r13;
    if (r11!==peg$FAILED) {
      peg$savedPos = p12;
      r11 = peg$a83(r8, r13);
    } else {
      r10 = peg$FAILED;
      break seq_3;
    }
    p14 = peg$currPos;
    r15 = peg$FAILED;
    for (;;) {
      if (input.charCodeAt(peg$currPos) === 61) {
        r16 = "=";
        peg$currPos += 1;
        r15 = true;
      } else {
        if (!silence) {peg$fail(peg$c23);}
        r16 = peg$FAILED;
        break;
      }
    }
    if (r15!==peg$FAILED) {
      r15 = input.substring(p14, peg$currPos);
    } else {
      r15 = peg$FAILED;
      peg$currPos = p9;
      r10 = peg$FAILED;
      break seq_3;
    }
    // free r16
    // free p14
    r10 = [r11,r15];
    } // seq_3
    if (r10===peg$FAILED) {
      r10 = null;
    }
    // free p9
    // ce <- r10
    peg$savedPos = peg$currPos;
    r16 = peg$a84(r8, r10);
    if (r16) {
      r16 = void 0;
    } else {
      r16 = peg$FAILED;
      peg$currPos = p7;
      r6 = peg$FAILED;
      break seq_2;
    }
    p9 = peg$currPos;
    r17 = '';
    // endTPos <- r17
    if (r17!==peg$FAILED) {
      peg$savedPos = p9;
      r17 = peg$a85(r8, r10);
    } else {
      peg$currPos = p7;
      r6 = peg$FAILED;
      break seq_2;
    }
    r18 = [];
    for (;;) {
      choice_1: {
      r19 = peg$parsespaces(silence);
      if (r19!==peg$FAILED) {
        break choice_1;
      }
      r19 = peg$parsecomment(silence);
      } // choice_1
      if (r19!==peg$FAILED) {
        r18.push(r19);
      } else {
        break;
      }
    }
    // spc <- r18
    // free r19
    p14 = peg$currPos;
    r19 = peg$discardeolf(true);
    if (r19!==peg$FAILED) {
      r19 = void 0;
      peg$currPos = p14;
    } else {
      peg$currPos = p7;
      r6 = peg$FAILED;
      break seq_2;
    }
    // free p14
    r6 = true;
    } // seq_2
    // r <- r6
    if (r6!==peg$FAILED) {
      peg$savedPos = p4;
      r6 = peg$a86(r8, r10, r17, r18);
    } else {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p7
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a21(r6);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parselist_item(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [448, boolParams & 0x3bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    r1 = peg$parsedtdd(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    r1 = peg$parsehacky_dl_uses(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    r1 = peg$parseli(silence, boolParams, param_templatedepth, param_preproc, param_th);
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsehr(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,p6,r7,p8,p9,r10;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [306, boolParams & 0x13af, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = input.substr(peg$currPos,4);
    if (r4 === "----") {
      peg$currPos += 4;
    } else {
      if (!silence) {peg$fail(peg$c60);}
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    p6 = peg$currPos;
    for (;;) {
      if (input.charCodeAt(peg$currPos) === 45) {
        r7 = "-";
        peg$currPos += 1;
      } else {
        if (!silence) {peg$fail(peg$c57);}
        r7 = peg$FAILED;
        break;
      }
    }
    // free r7
    r5 = true;
    // d <- r5
    if (r5!==peg$FAILED) {
      r5 = input.substring(p6, peg$currPos);
    } else {
      r5 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p6
    choice_1: {
    p6 = peg$currPos;
    seq_2: {
    p8 = peg$currPos;
    p9 = peg$currPos;
    r10 = peg$discardsol(true, boolParams, param_templatedepth, param_preproc, param_th);
    if (r10!==peg$FAILED) {
      r10 = void 0;
      peg$currPos = p9;
    } else {
      r7 = peg$FAILED;
      break seq_2;
    }
    // free p9
    r7 = true;
    } // seq_2
    if (r7!==peg$FAILED) {
      peg$savedPos = p6;
      r7 = peg$a87(r5);
      break choice_1;
    }
    // free p8
    p8 = peg$currPos;
    r7 = '';
    if (r7!==peg$FAILED) {
      peg$savedPos = p8;
      r7 = peg$a88(r5);
    }
    } // choice_1
    // lineContent <- r7
    if (r7===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a89(r5, r7);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsetable_line(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,p5,r6,r7,r8,r9,r10;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [464, boolParams & 0x3bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    choice_1: {
    p5 = peg$currPos;
    r4 = peg$discardinline_breaks(true, boolParams, param_templatedepth, param_preproc, param_th);
    if (r4 === peg$FAILED) {
      r4 = void 0;
      break choice_1;
    } else {
      r4 = peg$FAILED;
      peg$currPos = p5;
    }
    // free p5
    p5 = peg$currPos;
    r4 = input.substr(peg$currPos,5);
    if (r4 === "{{!}}") {
      peg$currPos += 5;
      r4 = void 0;
      peg$currPos = p5;
    } else {
      r4 = peg$FAILED;
    }
    // free p5
    } // choice_1
    if (r4===peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    choice_2: {
    seq_2: {
    p5 = peg$currPos;
    r7 = peg$parsetable_start_tag(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r7===peg$FAILED) {
      r6 = peg$FAILED;
      break seq_2;
    }
    r8 = peg$parseoptionalNewlines(silence);
    if (r8===peg$FAILED) {
      peg$currPos = p5;
      r6 = peg$FAILED;
      break seq_2;
    }
    r6 = [r7,r8];
    } // seq_2
    if (r6!==peg$FAILED) {
      break choice_2;
    }
    // free p5
    seq_3: {
    p5 = peg$currPos;
    r9 = peg$parsetable_content_line(silence, boolParams | 0x10, param_templatedepth, param_preproc, param_th);
    if (r9===peg$FAILED) {
      r6 = peg$FAILED;
      break seq_3;
    }
    r10 = peg$parseoptionalNewlines(silence);
    if (r10===peg$FAILED) {
      peg$currPos = p5;
      r6 = peg$FAILED;
      break seq_3;
    }
    r6 = [r9,r10];
    } // seq_3
    if (r6!==peg$FAILED) {
      break choice_2;
    }
    // free p5
    r6 = peg$parsetable_end_tag(silence);
    } // choice_2
    // tl <- r6
    if (r6===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a90(r6);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsexmlish_tag_opened(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,r6,r7,r8,r9,r10;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [428, boolParams & 0x3faf, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 47) {
      r4 = "/";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c36);}
      r4 = peg$FAILED;
      r4 = null;
    }
    // end <- r4
    r5 = peg$parsetag_name(silence);
    // name <- r5
    if (r5===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    peg$savedPos = peg$currPos;
    r6 = peg$a91(r4, r5, /*extTag*/(boolParams & 0x800) !== 0, /*isBlock*/(boolParams & 0x400) !== 0);
    if (r6) {
      r6 = void 0;
    } else {
      r6 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r7 = peg$parsegeneric_newline_attributes(silence, boolParams & ~0x50, param_templatedepth, param_preproc, param_th);
    // attribs <- r7
    if (r7===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    for (;;) {
      r9 = peg$discardspace_or_newline_or_solidus(silence);
      if (r9===peg$FAILED) {
        break;
      }
    }
    // free r9
    r8 = true;
    if (r8===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free r8
    if (input.charCodeAt(peg$currPos) === 47) {
      r8 = "/";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c36);}
      r8 = peg$FAILED;
      r8 = null;
    }
    // selfclose <- r8
    for (;;) {
      r10 = peg$discardspace(silence);
      if (r10===peg$FAILED) {
        break;
      }
    }
    // free r10
    r9 = true;
    if (r9===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free r9
    if (input.charCodeAt(peg$currPos) === 62) {
      r9 = ">";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c61);}
      r9 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a92(r4, r5, /*extTag*/(boolParams & 0x800) !== 0, /*isBlock*/(boolParams & 0x400) !== 0, r7, r8);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parseempty_line_with_comments(silence) {
    var r1,p2,p3,r4,r5,p6,r7,r8,p9,r10,r11,r12,r13;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 524;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = peg$parsesol_prefix(silence);
    // sp <- r4
    if (r4===peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    p6 = peg$currPos;
    r5 = '';
    // p <- r5
    if (r5!==peg$FAILED) {
      peg$savedPos = p6;
      r5 = peg$a93(r4);
    } else {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r7 = [];
    for (;;) {
      seq_2: {
      p9 = peg$currPos;
      r10 = [];
      for (;;) {
        r11 = peg$parsespace(silence);
        if (r11!==peg$FAILED) {
          r10.push(r11);
        } else {
          break;
        }
      }
      // free r11
      r11 = peg$parsecomment(silence);
      if (r11===peg$FAILED) {
        peg$currPos = p9;
        r8 = peg$FAILED;
        break seq_2;
      }
      r12 = [];
      for (;;) {
        choice_1: {
        r13 = peg$parsespace(silence);
        if (r13!==peg$FAILED) {
          break choice_1;
        }
        r13 = peg$parsecomment(silence);
        } // choice_1
        if (r13!==peg$FAILED) {
          r12.push(r13);
        } else {
          break;
        }
      }
      // free r13
      r13 = peg$parsenewline(silence);
      if (r13===peg$FAILED) {
        peg$currPos = p9;
        r8 = peg$FAILED;
        break seq_2;
      }
      r8 = [r10,r11,r12,r13];
      } // seq_2
      if (r8!==peg$FAILED) {
        r7.push(r8);
      } else {
        break;
      }
      // free p9
    }
    if (r7.length === 0) {
      r7 = peg$FAILED;
    }
    // c <- r7
    if (r7===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free r8
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a94(r4, r5, r7);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parsesol_prefix(silence) {
    var r1,p2;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 522;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    r1 = peg$parsenewlineToken(silence);
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    p2 = peg$currPos;
    peg$savedPos = peg$currPos;
    r1 = peg$a95();
    if (r1) {
      r1 = void 0;
      peg$savedPos = p2;
      r1 = peg$a96();
    } else {
      r1 = peg$FAILED;
    }
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$discardtplarg_preproc(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,p6,r7,r8,r9,p10,p11,r12,r13,p14,p15,r16,p17,r18,r19,p20,p21,r22,r23;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [361, boolParams & 0x3bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = input.substr(peg$currPos,3);
    if (r4 === "{{{") {
      peg$currPos += 3;
    } else {
      if (!silence) {peg$fail(peg$c62);}
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    p6 = peg$currPos;
    r5 = '';
    // p <- r5
    if (r5!==peg$FAILED) {
      peg$savedPos = p6;
      r5 = peg$a15();
    } else {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r7 = peg$parsetemplate_param_value(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r7===peg$FAILED) {
      r7 = null;
    }
    // target <- r7
    r8 = [];
    for (;;) {
      p10 = peg$currPos;
      seq_2: {
      p11 = peg$currPos;
      for (;;) {
        r13 = peg$discardnl_comment_space(silence);
        if (r13===peg$FAILED) {
          break;
        }
      }
      // free r13
      r12 = true;
      if (r12===peg$FAILED) {
        r9 = peg$FAILED;
        break seq_2;
      }
      // free r12
      if (input.charCodeAt(peg$currPos) === 124) {
        r12 = "|";
        peg$currPos += 1;
      } else {
        if (!silence) {peg$fail(peg$c13);}
        r12 = peg$FAILED;
        peg$currPos = p11;
        r9 = peg$FAILED;
        break seq_2;
      }
      choice_1: {
      p14 = peg$currPos;
      seq_3: {
      p15 = peg$currPos;
      p17 = peg$currPos;
      r16 = '';
      // p0 <- r16
      if (r16!==peg$FAILED) {
        peg$savedPos = p17;
        r16 = peg$a97(r5, r7);
      } else {
        r13 = peg$FAILED;
        break seq_3;
      }
      r18 = [];
      for (;;) {
        r19 = peg$parsenl_comment_space(silence);
        if (r19!==peg$FAILED) {
          r18.push(r19);
        } else {
          break;
        }
      }
      // v <- r18
      // free r19
      p20 = peg$currPos;
      r19 = '';
      // p1 <- r19
      if (r19!==peg$FAILED) {
        peg$savedPos = p20;
        r19 = peg$a98(r5, r7, r16, r18);
      } else {
        peg$currPos = p15;
        r13 = peg$FAILED;
        break seq_3;
      }
      p21 = peg$currPos;
      choice_2: {
      if (input.charCodeAt(peg$currPos) === 124) {
        r22 = "|";
        peg$currPos += 1;
        break choice_2;
      } else {
        r22 = peg$FAILED;
      }
      r22 = input.substr(peg$currPos,3);
      if (r22 === "}}}") {
        peg$currPos += 3;
      } else {
        r22 = peg$FAILED;
      }
      } // choice_2
      if (r22!==peg$FAILED) {
        r22 = void 0;
        peg$currPos = p21;
      } else {
        peg$currPos = p15;
        r13 = peg$FAILED;
        break seq_3;
      }
      // free p21
      r13 = true;
      } // seq_3
      if (r13!==peg$FAILED) {
        peg$savedPos = p14;
        r13 = peg$a99(r5, r7, r16, r18, r19);
        break choice_1;
      }
      // free p15
      r13 = peg$parsetemplate_param_value(silence, boolParams, param_templatedepth, param_preproc, param_th);
      } // choice_1
      // r <- r13
      if (r13===peg$FAILED) {
        peg$currPos = p11;
        r9 = peg$FAILED;
        break seq_2;
      }
      r9 = true;
      } // seq_2
      if (r9!==peg$FAILED) {
        peg$savedPos = p10;
        r9 = peg$a100(r5, r7, r13);
        r8.push(r9);
      } else {
        break;
      }
      // free p11
    }
    // params <- r8
    // free r9
    for (;;) {
      r23 = peg$discardnl_comment_space(silence);
      if (r23===peg$FAILED) {
        break;
      }
    }
    // free r23
    r9 = true;
    if (r9===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free r9
    r9 = peg$discardinline_breaks(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r9===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r23 = input.substr(peg$currPos,3);
    if (r23 === "}}}") {
      peg$currPos += 3;
    } else {
      if (!silence) {peg$fail(peg$c63);}
      r23 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a101(r5, r7, r8);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsetemplate_preproc(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,p6,r7,r8,r9,p10,r11,r12,p13,p14,r15,p16,r17,r18,p19,p20,r21,r22,r23,r24,r25,r26;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [356, boolParams & 0x3bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = input.substr(peg$currPos,2);
    if (r4 === "{{") {
      peg$currPos += 2;
    } else {
      if (!silence) {peg$fail(peg$c47);}
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    p6 = peg$currPos;
    for (;;) {
      r7 = peg$discardnl_comment_space(silence);
      if (r7===peg$FAILED) {
        break;
      }
    }
    // free r7
    r5 = true;
    // leadWS <- r5
    if (r5!==peg$FAILED) {
      r5 = input.substring(p6, peg$currPos);
    } else {
      r5 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p6
    r7 = peg$parsetemplate_param_value(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // target <- r7
    if (r7===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r8 = [];
    for (;;) {
      p6 = peg$currPos;
      seq_2: {
      p10 = peg$currPos;
      for (;;) {
        r12 = peg$discardnl_comment_space(silence);
        if (r12===peg$FAILED) {
          break;
        }
      }
      // free r12
      r11 = true;
      if (r11===peg$FAILED) {
        r9 = peg$FAILED;
        break seq_2;
      }
      // free r11
      if (input.charCodeAt(peg$currPos) === 124) {
        r11 = "|";
        peg$currPos += 1;
      } else {
        if (!silence) {peg$fail(peg$c13);}
        r11 = peg$FAILED;
        peg$currPos = p10;
        r9 = peg$FAILED;
        break seq_2;
      }
      choice_2: {
      p13 = peg$currPos;
      seq_3: {
      p14 = peg$currPos;
      p16 = peg$currPos;
      r15 = '';
      // p0 <- r15
      if (r15!==peg$FAILED) {
        peg$savedPos = p16;
        r15 = peg$a102(r5, r7);
      } else {
        r12 = peg$FAILED;
        break seq_3;
      }
      r17 = [];
      for (;;) {
        r18 = peg$parsenl_comment_space(silence);
        if (r18!==peg$FAILED) {
          r17.push(r18);
        } else {
          break;
        }
      }
      // v <- r17
      // free r18
      p19 = peg$currPos;
      r18 = '';
      // p <- r18
      if (r18!==peg$FAILED) {
        peg$savedPos = p19;
        r18 = peg$a103(r5, r7, r15, r17);
      } else {
        peg$currPos = p14;
        r12 = peg$FAILED;
        break seq_3;
      }
      p20 = peg$currPos;
      choice_3: {
      if (input.charCodeAt(peg$currPos) === 124) {
        r21 = "|";
        peg$currPos += 1;
        break choice_3;
      } else {
        r21 = peg$FAILED;
      }
      r21 = input.substr(peg$currPos,2);
      if (r21 === "}}") {
        peg$currPos += 2;
      } else {
        r21 = peg$FAILED;
      }
      } // choice_3
      if (r21!==peg$FAILED) {
        r21 = void 0;
        peg$currPos = p20;
      } else {
        peg$currPos = p14;
        r12 = peg$FAILED;
        break seq_3;
      }
      // free p20
      r12 = true;
      } // seq_3
      if (r12!==peg$FAILED) {
        peg$savedPos = p13;
        r12 = peg$a104(r5, r7, r15, r17, r18);
        break choice_2;
      }
      // free p14
      r12 = peg$parsetemplate_param(silence, boolParams, param_templatedepth, param_preproc, param_th);
      } // choice_2
      // r <- r12
      if (r12===peg$FAILED) {
        peg$currPos = p10;
        r9 = peg$FAILED;
        break seq_2;
      }
      r9 = true;
      } // seq_2
      if (r9!==peg$FAILED) {
        peg$savedPos = p6;
        r9 = peg$a105(r5, r7, r12);
        r8.push(r9);
      } else {
        break;
      }
      // free p10
    }
    // params <- r8
    // free r9
    p10 = peg$currPos;
    for (;;) {
      r22 = peg$discardnl_comment_space(silence);
      if (r22===peg$FAILED) {
        break;
      }
    }
    // free r22
    r9 = true;
    // trailWS <- r9
    if (r9!==peg$FAILED) {
      r9 = input.substring(p10, peg$currPos);
    } else {
      r9 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p10
    r22 = peg$discardinline_breaks(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r22===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r23 = input.substr(peg$currPos,2);
    if (r23 === "}}") {
      peg$currPos += 2;
    } else {
      if (!silence) {peg$fail(peg$c64);}
      r23 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a106(r5, r7, r8, r9);
      break choice_1;
    }
    // free p3
    p3 = peg$currPos;
    seq_4: {
    p10 = peg$currPos;
    r24 = input.substr(peg$currPos,2);
    if (r24 === "{{") {
      peg$currPos += 2;
    } else {
      if (!silence) {peg$fail(peg$c47);}
      r24 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_4;
    }
    for (;;) {
      r26 = peg$discardspace_or_newline(silence);
      if (r26===peg$FAILED) {
        break;
      }
    }
    // free r26
    r25 = true;
    if (r25===peg$FAILED) {
      peg$currPos = p10;
      r1 = peg$FAILED;
      break seq_4;
    }
    // free r25
    r25 = input.substr(peg$currPos,2);
    if (r25 === "}}") {
      peg$currPos += 2;
    } else {
      if (!silence) {peg$fail(peg$c64);}
      r25 = peg$FAILED;
      peg$currPos = p10;
      r1 = peg$FAILED;
      break seq_4;
    }
    r1 = true;
    } // seq_4
    if (r1!==peg$FAILED) {
      r1 = input.substring(p3, peg$currPos);
    } else {
      r1 = peg$FAILED;
    }
    // free p10
    // free p3
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsetplarg_preproc(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,p6,r7,r8,r9,p10,p11,r12,r13,p14,p15,r16,p17,r18,r19,p20,p21,r22,r23;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [360, boolParams & 0x3bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = input.substr(peg$currPos,3);
    if (r4 === "{{{") {
      peg$currPos += 3;
    } else {
      if (!silence) {peg$fail(peg$c62);}
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    p6 = peg$currPos;
    r5 = '';
    // p <- r5
    if (r5!==peg$FAILED) {
      peg$savedPos = p6;
      r5 = peg$a15();
    } else {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r7 = peg$parsetemplate_param_value(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r7===peg$FAILED) {
      r7 = null;
    }
    // target <- r7
    r8 = [];
    for (;;) {
      p10 = peg$currPos;
      seq_2: {
      p11 = peg$currPos;
      for (;;) {
        r13 = peg$discardnl_comment_space(silence);
        if (r13===peg$FAILED) {
          break;
        }
      }
      // free r13
      r12 = true;
      if (r12===peg$FAILED) {
        r9 = peg$FAILED;
        break seq_2;
      }
      // free r12
      if (input.charCodeAt(peg$currPos) === 124) {
        r12 = "|";
        peg$currPos += 1;
      } else {
        if (!silence) {peg$fail(peg$c13);}
        r12 = peg$FAILED;
        peg$currPos = p11;
        r9 = peg$FAILED;
        break seq_2;
      }
      choice_1: {
      p14 = peg$currPos;
      seq_3: {
      p15 = peg$currPos;
      p17 = peg$currPos;
      r16 = '';
      // p0 <- r16
      if (r16!==peg$FAILED) {
        peg$savedPos = p17;
        r16 = peg$a97(r5, r7);
      } else {
        r13 = peg$FAILED;
        break seq_3;
      }
      r18 = [];
      for (;;) {
        r19 = peg$parsenl_comment_space(silence);
        if (r19!==peg$FAILED) {
          r18.push(r19);
        } else {
          break;
        }
      }
      // v <- r18
      // free r19
      p20 = peg$currPos;
      r19 = '';
      // p1 <- r19
      if (r19!==peg$FAILED) {
        peg$savedPos = p20;
        r19 = peg$a98(r5, r7, r16, r18);
      } else {
        peg$currPos = p15;
        r13 = peg$FAILED;
        break seq_3;
      }
      p21 = peg$currPos;
      choice_2: {
      if (input.charCodeAt(peg$currPos) === 124) {
        r22 = "|";
        peg$currPos += 1;
        break choice_2;
      } else {
        r22 = peg$FAILED;
      }
      r22 = input.substr(peg$currPos,3);
      if (r22 === "}}}") {
        peg$currPos += 3;
      } else {
        r22 = peg$FAILED;
      }
      } // choice_2
      if (r22!==peg$FAILED) {
        r22 = void 0;
        peg$currPos = p21;
      } else {
        peg$currPos = p15;
        r13 = peg$FAILED;
        break seq_3;
      }
      // free p21
      r13 = true;
      } // seq_3
      if (r13!==peg$FAILED) {
        peg$savedPos = p14;
        r13 = peg$a99(r5, r7, r16, r18, r19);
        break choice_1;
      }
      // free p15
      r13 = peg$parsetemplate_param_value(silence, boolParams, param_templatedepth, param_preproc, param_th);
      } // choice_1
      // r <- r13
      if (r13===peg$FAILED) {
        peg$currPos = p11;
        r9 = peg$FAILED;
        break seq_2;
      }
      r9 = true;
      } // seq_2
      if (r9!==peg$FAILED) {
        peg$savedPos = p10;
        r9 = peg$a100(r5, r7, r13);
        r8.push(r9);
      } else {
        break;
      }
      // free p11
    }
    // params <- r8
    // free r9
    for (;;) {
      r23 = peg$discardnl_comment_space(silence);
      if (r23===peg$FAILED) {
        break;
      }
    }
    // free r23
    r9 = true;
    if (r9===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free r9
    r9 = peg$discardinline_breaks(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r9===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r23 = input.substr(peg$currPos,3);
    if (r23 === "}}}") {
      peg$currPos += 3;
    } else {
      if (!silence) {peg$fail(peg$c63);}
      r23 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a101(r5, r7, r8);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$discardwikilink_preproc(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,p6,r7,r8,p9,r10,r11,r12;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [407, boolParams & 0x3bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = input.substr(peg$currPos,2);
    if (r4 === "[[") {
      peg$currPos += 2;
    } else {
      if (!silence) {peg$fail(peg$c45);}
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    p6 = peg$currPos;
    r5 = '';
    // spos <- r5
    if (r5!==peg$FAILED) {
      peg$savedPos = p6;
      r5 = peg$a15();
    } else {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r7 = peg$parsewikilink_preprocessor_text(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r7===peg$FAILED) {
      r7 = null;
    }
    // target <- r7
    p9 = peg$currPos;
    r8 = '';
    // tpos <- r8
    if (r8!==peg$FAILED) {
      peg$savedPos = p9;
      r8 = peg$a107(r5, r7);
    } else {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r10 = peg$parsewikilink_content(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // lcs <- r10
    if (r10===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r11 = peg$discardinline_breaks(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r11===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r12 = input.substr(peg$currPos,2);
    if (r12 === "]]") {
      peg$currPos += 2;
    } else {
      if (!silence) {peg$fail(peg$c65);}
      r12 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a108(r5, r7, r8, r10);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$discardbroken_wikilink(silence, boolParams, param_preproc, param_templatedepth, param_th) {
    var r1,p2,p3,p4,r5,r6,r7,r8,r9;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [405, boolParams & 0x3bff, param_preproc.value, param_templatedepth, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p4 = peg$currPos;
    r5 = input.substr(peg$currPos,2);
    if (r5 === "[[") {
      peg$currPos += 2;
      r5 = void 0;
      peg$currPos = p4;
    } else {
      r5 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p4
    peg$savedPos = peg$currPos;
    r6 = peg$a109(param_preproc);
    if (r6) {
      r6 = void 0;
    } else {
      r6 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    seq_2: {
    p4 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 91) {
      r8 = "[";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c19);}
      r8 = peg$FAILED;
      r7 = peg$FAILED;
      break seq_2;
    }
    choice_1: {
    r9 = peg$parseextlink(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r9!==peg$FAILED) {
      break choice_1;
    }
    if (input.charCodeAt(peg$currPos) === 91) {
      r9 = "[";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c19);}
      r9 = peg$FAILED;
    }
    } // choice_1
    if (r9===peg$FAILED) {
      peg$currPos = p4;
      r7 = peg$FAILED;
      break seq_2;
    }
    r7 = [r8,r9];
    } // seq_2
    // a <- r7
    if (r7===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p4
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a110(param_preproc, r7);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parseextension_tag(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,r6;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [414, boolParams & 0x3baf, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    if (!(/*extTag*/(boolParams & 0x800) !== 0)) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    r5 = peg$parsexmlish_tag(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // extToken <- r5
    if (r5===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    peg$savedPos = peg$currPos;
    r6 = peg$a111(r5);
    if (r6) {
      r6 = void 0;
    } else {
      r6 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a112(r5);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parseautourl(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,p4,r5,r6,p7,r8,r9,r10,r11,p12,p13,p14,r15,r16,r17,p18,r19,r20,p21,r22,r23,r24,p25,r26,r27;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [342, boolParams & 0x3bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p4 = peg$currPos;
    r5 = input.substr(peg$currPos,2);
    if (r5 === "//") {
      peg$currPos += 2;
    } else {
      r5 = peg$FAILED;
    }
    if (r5 === peg$FAILED) {
      r5 = void 0;
    } else {
      r5 = peg$FAILED;
      peg$currPos = p4;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p4
    p4 = peg$currPos;
    seq_2: {
    p7 = peg$currPos;
    r8 = peg$parseurl_protocol(silence);
    // proto <- r8
    if (r8===peg$FAILED) {
      r6 = peg$FAILED;
      break seq_2;
    }
    choice_1: {
    r9 = peg$parseurladdr(silence);
    if (r9!==peg$FAILED) {
      break choice_1;
    }
    r9 = '';
    } // choice_1
    // addr <- r9
    if (r9===peg$FAILED) {
      peg$currPos = p7;
      r6 = peg$FAILED;
      break seq_2;
    }
    r10 = [];
    for (;;) {
      choice_2: {
      p12 = peg$currPos;
      seq_3: {
      p13 = peg$currPos;
      p14 = peg$currPos;
      r15 = peg$discardinline_breaks(true, boolParams, param_templatedepth, param_preproc, param_th);
      if (r15 === peg$FAILED) {
        r15 = void 0;
      } else {
        r15 = peg$FAILED;
        peg$currPos = p14;
        r11 = peg$FAILED;
        break seq_3;
      }
      // free p14
      r16 = peg$parseno_punctuation_char(silence);
      // c <- r16
      if (r16===peg$FAILED) {
        peg$currPos = p13;
        r11 = peg$FAILED;
        break seq_3;
      }
      r11 = true;
      } // seq_3
      if (r11!==peg$FAILED) {
        peg$savedPos = p12;
        r11 = peg$a6(r8, r9, r16);
        break choice_2;
      }
      // free p13
      r11 = input.charAt(peg$currPos);
      if (/^[.:,]/.test(r11)) {
        peg$currPos++;
        break choice_2;
      } else {
        r11 = peg$FAILED;
        if (!silence) {peg$fail(peg$c41);}
      }
      p13 = peg$currPos;
      seq_4: {
      p14 = peg$currPos;
      r17 = input.charAt(peg$currPos);
      if (/^[']/.test(r17)) {
        peg$currPos++;
      } else {
        r17 = peg$FAILED;
        if (!silence) {peg$fail(peg$c42);}
        r11 = peg$FAILED;
        break seq_4;
      }
      p18 = peg$currPos;
      r19 = input.charAt(peg$currPos);
      if (/^[']/.test(r19)) {
        peg$currPos++;
      } else {
        r19 = peg$FAILED;
      }
      if (r19 === peg$FAILED) {
        r19 = void 0;
      } else {
        r19 = peg$FAILED;
        peg$currPos = p18;
        peg$currPos = p14;
        r11 = peg$FAILED;
        break seq_4;
      }
      // free p18
      r11 = true;
      } // seq_4
      if (r11!==peg$FAILED) {
        r11 = input.substring(p13, peg$currPos);
        break choice_2;
      } else {
        r11 = peg$FAILED;
      }
      // free p14
      // free p13
      r11 = peg$parsecomment(silence);
      if (r11!==peg$FAILED) {
        break choice_2;
      }
      r11 = peg$parsetplarg_or_template(silence, boolParams, param_templatedepth, param_th, param_preproc);
      if (r11!==peg$FAILED) {
        break choice_2;
      }
      p13 = peg$currPos;
      seq_5: {
      p14 = peg$currPos;
      p18 = peg$currPos;
      seq_6: {
      p21 = peg$currPos;
      r22 = peg$parseraw_htmlentity(true);
      // rhe <- r22
      if (r22===peg$FAILED) {
        r20 = peg$FAILED;
        break seq_6;
      }
      peg$savedPos = peg$currPos;
      r23 = peg$a113(r8, r9, r22);
      if (r23) {
        r23 = void 0;
      } else {
        r23 = peg$FAILED;
        peg$currPos = p21;
        r20 = peg$FAILED;
        break seq_6;
      }
      r20 = true;
      } // seq_6
      // free p21
      if (r20 === peg$FAILED) {
        r20 = void 0;
      } else {
        r20 = peg$FAILED;
        peg$currPos = p18;
        r11 = peg$FAILED;
        break seq_5;
      }
      // free p18
      choice_3: {
      p18 = peg$currPos;
      seq_7: {
      p21 = peg$currPos;
      p25 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 38) {
        r26 = "&";
        peg$currPos += 1;
        r26 = void 0;
        peg$currPos = p25;
      } else {
        r26 = peg$FAILED;
        r24 = peg$FAILED;
        break seq_7;
      }
      // free p25
      r27 = peg$parsehtmlentity(silence);
      // he <- r27
      if (r27===peg$FAILED) {
        peg$currPos = p21;
        r24 = peg$FAILED;
        break seq_7;
      }
      r24 = true;
      } // seq_7
      if (r24!==peg$FAILED) {
        peg$savedPos = p18;
        r24 = peg$a8(r8, r9, r27);
        break choice_3;
      }
      // free p21
      r24 = input.charAt(peg$currPos);
      if (/^[&%{]/.test(r24)) {
        peg$currPos++;
      } else {
        r24 = peg$FAILED;
        if (!silence) {peg$fail(peg$c66);}
      }
      } // choice_3
      // r <- r24
      if (r24===peg$FAILED) {
        peg$currPos = p14;
        r11 = peg$FAILED;
        break seq_5;
      }
      r11 = true;
      } // seq_5
      if (r11!==peg$FAILED) {
        peg$savedPos = p13;
        r11 = peg$a9(r8, r9, r24);
      }
      // free p14
      } // choice_2
      if (r11!==peg$FAILED) {
        r10.push(r11);
      } else {
        break;
      }
    }
    // path <- r10
    // free r11
    r6 = true;
    } // seq_2
    // r <- r6
    if (r6!==peg$FAILED) {
      peg$savedPos = p4;
      r6 = peg$a114(r8, r9, r10);
    } else {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p7
    peg$savedPos = peg$currPos;
    r11 = peg$a115(r6);
    if (r11) {
      r11 = void 0;
    } else {
      r11 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a116(r6);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parseautoref(silence) {
    var r1,p2,p3,r4,r5,r6,p7,r8;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 332;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    choice_1: {
    r4 = input.substr(peg$currPos,3);
    if (r4 === "RFC") {
      peg$currPos += 3;
      break choice_1;
    } else {
      if (!silence) {peg$fail(peg$c67);}
      r4 = peg$FAILED;
    }
    r4 = input.substr(peg$currPos,4);
    if (r4 === "PMID") {
      peg$currPos += 4;
    } else {
      if (!silence) {peg$fail(peg$c68);}
      r4 = peg$FAILED;
    }
    } // choice_1
    // ref <- r4
    if (r4===peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    r5 = [];
    for (;;) {
      r6 = peg$parsespace_or_nbsp(silence);
      if (r6!==peg$FAILED) {
        r5.push(r6);
      } else {
        break;
      }
    }
    if (r5.length === 0) {
      r5 = peg$FAILED;
    }
    // sp <- r5
    if (r5===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free r6
    p7 = peg$currPos;
    r6 = peg$FAILED;
    for (;;) {
      r8 = input.charAt(peg$currPos);
      if (/^[0-9]/.test(r8)) {
        peg$currPos++;
        r6 = true;
      } else {
        r8 = peg$FAILED;
        if (!silence) {peg$fail(peg$c69);}
        break;
      }
    }
    // identifier <- r6
    if (r6!==peg$FAILED) {
      r6 = input.substring(p7, peg$currPos);
    } else {
      r6 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free r8
    // free p7
    r8 = peg$discardend_of_word(silence);
    if (r8===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a117(r4, r5, r6);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parseisbn(silence) {
    var r1,p2,p3,r4,r5,r6,p7,r8,r9,r10,p11,p12,r13,p14,r15,r16,r17,r18,r19;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 334;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = input.substr(peg$currPos,4);
    if (r4 === "ISBN") {
      peg$currPos += 4;
    } else {
      if (!silence) {peg$fail(peg$c70);}
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    r5 = [];
    for (;;) {
      r6 = peg$parsespace_or_nbsp(silence);
      if (r6!==peg$FAILED) {
        r5.push(r6);
      } else {
        break;
      }
    }
    if (r5.length === 0) {
      r5 = peg$FAILED;
    }
    // sp <- r5
    if (r5===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free r6
    seq_2: {
    p7 = peg$currPos;
    r8 = input.charAt(peg$currPos);
    if (/^[0-9]/.test(r8)) {
      peg$currPos++;
    } else {
      r8 = peg$FAILED;
      if (!silence) {peg$fail(peg$c69);}
      r6 = peg$FAILED;
      break seq_2;
    }
    r9 = [];
    for (;;) {
      choice_1: {
      p11 = peg$currPos;
      seq_3: {
      p12 = peg$currPos;
      r13 = peg$parsespace_or_nbsp_or_dash(silence);
      // s <- r13
      if (r13===peg$FAILED) {
        r10 = peg$FAILED;
        break seq_3;
      }
      p14 = peg$currPos;
      r15 = input.charAt(peg$currPos);
      if (/^[0-9]/.test(r15)) {
        peg$currPos++;
        r15 = void 0;
        peg$currPos = p14;
      } else {
        r15 = peg$FAILED;
        peg$currPos = p12;
        r10 = peg$FAILED;
        break seq_3;
      }
      // free p14
      r10 = true;
      } // seq_3
      if (r10!==peg$FAILED) {
        peg$savedPos = p11;
        r10 = peg$a118(r5, r13);
        break choice_1;
      }
      // free p12
      r10 = input.charAt(peg$currPos);
      if (/^[0-9]/.test(r10)) {
        peg$currPos++;
      } else {
        r10 = peg$FAILED;
        if (!silence) {peg$fail(peg$c69);}
      }
      } // choice_1
      if (r10!==peg$FAILED) {
        r9.push(r10);
      } else {
        break;
      }
    }
    if (r9.length === 0) {
      r9 = peg$FAILED;
    }
    if (r9===peg$FAILED) {
      peg$currPos = p7;
      r6 = peg$FAILED;
      break seq_2;
    }
    // free r10
    choice_2: {
    seq_4: {
    p12 = peg$currPos;
    choice_3: {
    r16 = peg$parsespace_or_nbsp_or_dash(silence);
    if (r16!==peg$FAILED) {
      break choice_3;
    }
    r16 = '';
    } // choice_3
    if (r16===peg$FAILED) {
      r10 = peg$FAILED;
      break seq_4;
    }
    r17 = input.charAt(peg$currPos);
    if (/^[xX]/.test(r17)) {
      peg$currPos++;
    } else {
      r17 = peg$FAILED;
      if (!silence) {peg$fail(peg$c71);}
      peg$currPos = p12;
      r10 = peg$FAILED;
      break seq_4;
    }
    r10 = [r16,r17];
    } // seq_4
    if (r10!==peg$FAILED) {
      break choice_2;
    }
    // free p12
    r10 = '';
    } // choice_2
    if (r10===peg$FAILED) {
      peg$currPos = p7;
      r6 = peg$FAILED;
      break seq_2;
    }
    r6 = [r8,r9,r10];
    } // seq_2
    // isbn <- r6
    if (r6===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p7
    p7 = peg$currPos;
    r18 = peg$discardend_of_word(silence);
    // isbncode <- r18
    if (r18!==peg$FAILED) {
      peg$savedPos = p7;
      r18 = peg$a119(r5, r6);
    } else {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    peg$savedPos = peg$currPos;
    r19 = peg$a120(r5, r6, r18);
    if (r19) {
      r19 = void 0;
    } else {
      r19 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a121(r5, r6, r18);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$discardbehavior_text(silence) {
    var p1,r2,r3,p4,p5,r6,r7;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 327;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    p1 = peg$currPos;
    r2 = peg$FAILED;
    for (;;) {
      seq_1: {
      p4 = peg$currPos;
      p5 = peg$currPos;
      r6 = input.substr(peg$currPos,2);
      if (r6 === "__") {
        peg$currPos += 2;
      } else {
        r6 = peg$FAILED;
      }
      if (r6 === peg$FAILED) {
        r6 = void 0;
      } else {
        r6 = peg$FAILED;
        peg$currPos = p5;
        r3 = peg$FAILED;
        break seq_1;
      }
      // free p5
      r7 = input.charAt(peg$currPos);
      if (/^[^'"<~[{\n\r:;\]}|!=]/.test(r7)) {
        peg$currPos++;
      } else {
        r7 = peg$FAILED;
        if (!silence) {peg$fail(peg$c72);}
        peg$currPos = p4;
        r3 = peg$FAILED;
        break seq_1;
      }
      r3 = true;
      } // seq_1
      if (r3!==peg$FAILED) {
        r2 = true;
      } else {
        break;
      }
      // free p4
    }
    if (r2!==peg$FAILED) {
      r2 = input.substring(p1, peg$currPos);
    } else {
      r2 = peg$FAILED;
    }
    // free r3
    // free p1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r2,
      };
  
    }
    return r2;
  }
  function peg$parselang_variant(silence, boolParams, param_templatedepth, param_th, param_preproc) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [374, boolParams & 0x3bff, param_templatedepth, param_th.value, param_preproc.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
        return cached.result;
      }
        var saved_th=param_th.value;
        var saved_preproc=param_preproc.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    r1 = peg$parselang_variant_preproc(silence, boolParams, param_templatedepth, new peg$Reference("}-"), param_th);
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    r1 = peg$parsebroken_lang_variant(silence, param_preproc);
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_th !== param_th.value) cached.$th = param_th.value;
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
    }
    return r1;
  }
  function peg$parsewikilink_preproc(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,p6,r7,r8,p9,r10,r11,r12;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [406, boolParams & 0x3bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = input.substr(peg$currPos,2);
    if (r4 === "[[") {
      peg$currPos += 2;
    } else {
      if (!silence) {peg$fail(peg$c45);}
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    p6 = peg$currPos;
    r5 = '';
    // spos <- r5
    if (r5!==peg$FAILED) {
      peg$savedPos = p6;
      r5 = peg$a15();
    } else {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r7 = peg$parsewikilink_preprocessor_text(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r7===peg$FAILED) {
      r7 = null;
    }
    // target <- r7
    p9 = peg$currPos;
    r8 = '';
    // tpos <- r8
    if (r8!==peg$FAILED) {
      peg$savedPos = p9;
      r8 = peg$a107(r5, r7);
    } else {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r10 = peg$parsewikilink_content(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // lcs <- r10
    if (r10===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r11 = peg$discardinline_breaks(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r11===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r12 = input.substr(peg$currPos,2);
    if (r12 === "]]") {
      peg$currPos += 2;
    } else {
      if (!silence) {peg$fail(peg$c65);}
      r12 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a108(r5, r7, r8, r10);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsebroken_wikilink(silence, boolParams, param_preproc, param_templatedepth, param_th) {
    var r1,p2,p3,p4,r5,r6,r7,r8,r9;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [404, boolParams & 0x3bff, param_preproc.value, param_templatedepth, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p4 = peg$currPos;
    r5 = input.substr(peg$currPos,2);
    if (r5 === "[[") {
      peg$currPos += 2;
      r5 = void 0;
      peg$currPos = p4;
    } else {
      r5 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p4
    peg$savedPos = peg$currPos;
    r6 = peg$a109(param_preproc);
    if (r6) {
      r6 = void 0;
    } else {
      r6 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    seq_2: {
    p4 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 91) {
      r8 = "[";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c19);}
      r8 = peg$FAILED;
      r7 = peg$FAILED;
      break seq_2;
    }
    choice_1: {
    r9 = peg$parseextlink(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r9!==peg$FAILED) {
      break choice_1;
    }
    if (input.charCodeAt(peg$currPos) === 91) {
      r9 = "[";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c19);}
      r9 = peg$FAILED;
    }
    } // choice_1
    if (r9===peg$FAILED) {
      peg$currPos = p4;
      r7 = peg$FAILED;
      break seq_2;
    }
    r7 = [r8,r9];
    } // seq_2
    // a <- r7
    if (r7===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p4
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a110(param_preproc, r7);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsespaces(silence) {
    var p1,r2,r3;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 498;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    p1 = peg$currPos;
    r2 = peg$FAILED;
    for (;;) {
      r3 = input.charAt(peg$currPos);
      if (/^[ \t]/.test(r3)) {
        peg$currPos++;
        r2 = true;
      } else {
        r3 = peg$FAILED;
        if (!silence) {peg$fail(peg$c9);}
        break;
      }
    }
    if (r2!==peg$FAILED) {
      r2 = input.substring(p1, peg$currPos);
    } else {
      r2 = peg$FAILED;
    }
    // free r3
    // free p1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r2,
      };
  
    }
    return r2;
  }
  function peg$parsedtdd(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,p6,p7,p8,r9,p10,r11,p12,r13,r14,r15,r16,r17,r18;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [454, boolParams & 0x3bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = [];
    for (;;) {
      p6 = peg$currPos;
      seq_2: {
      p7 = peg$currPos;
      p8 = peg$currPos;
      seq_3: {
      p10 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 59) {
        r11 = ";";
        peg$currPos += 1;
      } else {
        r11 = peg$FAILED;
        r9 = peg$FAILED;
        break seq_3;
      }
      p12 = peg$currPos;
      r13 = peg$discardlist_char(true);
      if (r13 === peg$FAILED) {
        r13 = void 0;
      } else {
        r13 = peg$FAILED;
        peg$currPos = p12;
        peg$currPos = p10;
        r9 = peg$FAILED;
        break seq_3;
      }
      // free p12
      r9 = true;
      } // seq_3
      // free p10
      if (r9 === peg$FAILED) {
        r9 = void 0;
      } else {
        r9 = peg$FAILED;
        peg$currPos = p8;
        r5 = peg$FAILED;
        break seq_2;
      }
      // free p8
      r14 = peg$parselist_char(silence);
      // lc <- r14
      if (r14===peg$FAILED) {
        peg$currPos = p7;
        r5 = peg$FAILED;
        break seq_2;
      }
      r5 = true;
      } // seq_2
      if (r5!==peg$FAILED) {
        peg$savedPos = p6;
        r5 = peg$a122(r14);
        r4.push(r5);
      } else {
        break;
      }
      // free p7
    }
    // bullets <- r4
    // free r5
    if (input.charCodeAt(peg$currPos) === 59) {
      r5 = ";";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c31);}
      r5 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r15 = peg$parseinlineline_break_on_colon(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r15===peg$FAILED) {
      r15 = null;
    }
    // c <- r15
    p7 = peg$currPos;
    // cpos <- r16
    if (input.charCodeAt(peg$currPos) === 58) {
      r16 = ":";
      peg$currPos += 1;
      peg$savedPos = p7;
      r16 = peg$a123(r4, r15);
    } else {
      if (!silence) {peg$fail(peg$c18);}
      r16 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r17 = peg$parseinlineline(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r17===peg$FAILED) {
      r17 = null;
    }
    // d <- r17
    p8 = peg$currPos;
    r18 = peg$discardeolf(true);
    if (r18!==peg$FAILED) {
      r18 = void 0;
      peg$currPos = p8;
    } else {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p8
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a124(r4, r15, r16, r17);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsehacky_dl_uses(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,p6,r7,r8,r9,p10,r11,r12,r13;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [452, boolParams & 0x3bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = [];
    for (;;) {
      if (input.charCodeAt(peg$currPos) === 58) {
        r5 = ":";
        peg$currPos += 1;
        r4.push(r5);
      } else {
        if (!silence) {peg$fail(peg$c18);}
        r5 = peg$FAILED;
        break;
      }
    }
    if (r4.length === 0) {
      r4 = peg$FAILED;
    }
    // bullets <- r4
    if (r4===peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    // free r5
    seq_2: {
    p6 = peg$currPos;
    r7 = peg$parsetable_line(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r7===peg$FAILED) {
      r5 = peg$FAILED;
      break seq_2;
    }
    r8 = [];
    for (;;) {
      seq_3: {
      p10 = peg$currPos;
      r11 = peg$parsesol(silence, boolParams, param_templatedepth, param_preproc, param_th);
      if (r11===peg$FAILED) {
        r9 = peg$FAILED;
        break seq_3;
      }
      r12 = peg$parsetable_line(silence, boolParams, param_templatedepth, param_preproc, param_th);
      if (r12===peg$FAILED) {
        peg$currPos = p10;
        r9 = peg$FAILED;
        break seq_3;
      }
      r9 = [r11,r12];
      } // seq_3
      if (r9!==peg$FAILED) {
        r8.push(r9);
      } else {
        break;
      }
      // free p10
    }
    // free r9
    r5 = [r7,r8];
    } // seq_2
    // tbl <- r5
    if (r5===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p6
    r9 = peg$parseinlineline(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r9===peg$FAILED) {
      r9 = null;
    }
    // line <- r9
    p6 = peg$currPos;
    r13 = peg$discardcomment_space_eolf(true);
    if (r13!==peg$FAILED) {
      r13 = void 0;
      peg$currPos = p6;
    } else {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p6
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a125(r4, r5, r9);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parseli(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,p6,r7;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [450, boolParams & 0x3bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = [];
    for (;;) {
      r5 = peg$parselist_char(silence);
      if (r5!==peg$FAILED) {
        r4.push(r5);
      } else {
        break;
      }
    }
    if (r4.length === 0) {
      r4 = peg$FAILED;
    }
    // bullets <- r4
    if (r4===peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    // free r5
    r5 = peg$parseinlineline(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r5===peg$FAILED) {
      r5 = null;
    }
    // c <- r5
    p6 = peg$currPos;
    choice_1: {
    r7 = peg$discardeolf(true);
    if (r7!==peg$FAILED) {
      break choice_1;
    }
    r7 = peg$discardinline_breaks(true, boolParams, param_templatedepth, param_preproc, param_th);
    } // choice_1
    if (r7!==peg$FAILED) {
      r7 = void 0;
      peg$currPos = p6;
    } else {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p6
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a126(r4, r5);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$discardsol(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var p1,r2,r3,r4;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [521, boolParams & 0x13af, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    seq_1: {
    p1 = peg$currPos;
    choice_1: {
    r3 = peg$discardempty_line_with_comments(silence);
    if (r3!==peg$FAILED) {
      break choice_1;
    }
    r3 = peg$discardsol_prefix(silence);
    } // choice_1
    if (r3===peg$FAILED) {
      r2 = peg$FAILED;
      break seq_1;
    }
    r4 = peg$discardcomment_or_includes(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r4===peg$FAILED) {
      peg$currPos = p1;
      r2 = peg$FAILED;
      break seq_1;
    }
    r2 = true;
    } // seq_1
    // free r2,p1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r2,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r2;
  }
  function peg$parseoptionalNewlines(silence) {
    var r1,p2,r3,p4,r5,p6,r7,p8,r9;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 516;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    p4 = peg$currPos;
    for (;;) {
      seq_1: {
      p6 = peg$currPos;
      r7 = input.charAt(peg$currPos);
      if (/^[\n\r\t ]/.test(r7)) {
        peg$currPos++;
      } else {
        r7 = peg$FAILED;
        if (!silence) {peg$fail(peg$c73);}
        r5 = peg$FAILED;
        break seq_1;
      }
      p8 = peg$currPos;
      r9 = input.charAt(peg$currPos);
      if (/^[\n\r]/.test(r9)) {
        peg$currPos++;
        r9 = void 0;
        peg$currPos = p8;
      } else {
        r9 = peg$FAILED;
        peg$currPos = p6;
        r5 = peg$FAILED;
        break seq_1;
      }
      // free p8
      r5 = true;
      } // seq_1
      if (r5===peg$FAILED) {
        break;
      }
      // free p6
    }
    // free r5
    r3 = true;
    // spc <- r3
    if (r3!==peg$FAILED) {
      r3 = input.substring(p4, peg$currPos);
    } else {
      r3 = peg$FAILED;
    }
    // free p4
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a127(r3);
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parsetable_content_line(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var p1,r2,r3,r4;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [466, boolParams & 0x3bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    seq_1: {
    p1 = peg$currPos;
    r3 = [];
    for (;;) {
      choice_1: {
      r4 = peg$parsespace(silence);
      if (r4!==peg$FAILED) {
        break choice_1;
      }
      r4 = peg$parsecomment(silence);
      } // choice_1
      if (r4!==peg$FAILED) {
        r3.push(r4);
      } else {
        break;
      }
    }
    // free r4
    choice_2: {
    r4 = peg$parsetable_heading_tags(silence, boolParams, param_templatedepth, param_preproc);
    if (r4!==peg$FAILED) {
      break choice_2;
    }
    r4 = peg$parsetable_row_tag(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r4!==peg$FAILED) {
      break choice_2;
    }
    r4 = peg$parsetable_data_tags(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r4!==peg$FAILED) {
      break choice_2;
    }
    r4 = peg$parsetable_caption_tag(silence, boolParams, param_templatedepth, param_preproc, param_th);
    } // choice_2
    if (r4===peg$FAILED) {
      peg$currPos = p1;
      r2 = peg$FAILED;
      break seq_1;
    }
    r2 = [r3,r4];
    } // seq_1
    // free r2,p1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r2,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r2;
  }
  function peg$parsetable_end_tag(silence) {
    var r1,p2,p3,r4,r5,p6,r7,r8;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 486;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = [];
    for (;;) {
      choice_1: {
      r5 = peg$parsespace(silence);
      if (r5!==peg$FAILED) {
        break choice_1;
      }
      r5 = peg$parsecomment(silence);
      } // choice_1
      if (r5!==peg$FAILED) {
        r4.push(r5);
      } else {
        break;
      }
    }
    // sc <- r4
    // free r5
    p6 = peg$currPos;
    r5 = '';
    // startPos <- r5
    if (r5!==peg$FAILED) {
      peg$savedPos = p6;
      r5 = peg$a2(r4);
    } else {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r7 = peg$parsepipe(silence);
    // p <- r7
    if (r7===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // b <- r8
    if (input.charCodeAt(peg$currPos) === 125) {
      r8 = "}";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c74);}
      r8 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a128(r4, r5, r7, r8);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parsetag_name(silence) {
    var p1,r2,p3,r4,r5,r6;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 422;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    p1 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = input.charAt(peg$currPos);
    if (/^[A-Za-z]/.test(r4)) {
      peg$currPos++;
    } else {
      r4 = peg$FAILED;
      if (!silence) {peg$fail(peg$c16);}
      r2 = peg$FAILED;
      break seq_1;
    }
    for (;;) {
      r6 = peg$discardtag_name_chars(silence);
      if (r6===peg$FAILED) {
        break;
      }
    }
    // free r6
    r5 = true;
    if (r5===peg$FAILED) {
      peg$currPos = p3;
      r2 = peg$FAILED;
      break seq_1;
    }
    // free r5
    r2 = true;
    } // seq_1
    if (r2!==peg$FAILED) {
      r2 = input.substring(p1, peg$currPos);
    } else {
      r2 = peg$FAILED;
    }
    // free p3
    // free p1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r2,
      };
  
    }
    return r2;
  }
  function peg$parsenewline(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 536;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    if (input.charCodeAt(peg$currPos) === 10) {
      r1 = "\n";
      peg$currPos += 1;
      break choice_1;
    } else {
      if (!silence) {peg$fail(peg$c26);}
      r1 = peg$FAILED;
    }
    r1 = input.substr(peg$currPos,2);
    if (r1 === "\r\n") {
      peg$currPos += 2;
    } else {
      if (!silence) {peg$fail(peg$c27);}
      r1 = peg$FAILED;
    }
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parsetemplate_param_value(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,r3;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [366, boolParams & 0x3b83, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    r3 = peg$parsetemplate_param_text(silence, boolParams & ~0x8, param_templatedepth, param_preproc, param_th);
    // tpt <- r3
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a129(r3);
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$discardnl_comment_space(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 529;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    r1 = peg$discardnewlineToken(silence);
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    r1 = peg$discardcomment_space(silence);
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parsenl_comment_space(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 528;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    r1 = peg$parsenewlineToken(silence);
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    r1 = peg$parsecomment_space(silence);
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parsetemplate_param(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,p6,p7,r8,p9,r10,r11,r12,p13,r14,r15;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [362, boolParams & 0x3b83, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = peg$parsetemplate_param_name(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // name <- r4
    if (r4===peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    p6 = peg$currPos;
    seq_2: {
    p7 = peg$currPos;
    p9 = peg$currPos;
    r8 = '';
    // kEndPos <- r8
    if (r8!==peg$FAILED) {
      peg$savedPos = p9;
      r8 = peg$a130(r4);
    } else {
      r5 = peg$FAILED;
      break seq_2;
    }
    r10 = peg$discardoptionalSpaceToken(silence);
    if (r10===peg$FAILED) {
      peg$currPos = p7;
      r5 = peg$FAILED;
      break seq_2;
    }
    if (input.charCodeAt(peg$currPos) === 61) {
      r11 = "=";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c23);}
      r11 = peg$FAILED;
      peg$currPos = p7;
      r5 = peg$FAILED;
      break seq_2;
    }
    p13 = peg$currPos;
    r12 = '';
    // vStartPos <- r12
    if (r12!==peg$FAILED) {
      peg$savedPos = p13;
      r12 = peg$a131(r4, r8);
    } else {
      peg$currPos = p7;
      r5 = peg$FAILED;
      break seq_2;
    }
    r14 = peg$discardoptionalSpaceToken(silence);
    if (r14===peg$FAILED) {
      peg$currPos = p7;
      r5 = peg$FAILED;
      break seq_2;
    }
    r15 = peg$parsetemplate_param_value(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r15===peg$FAILED) {
      r15 = null;
    }
    // tpv <- r15
    r5 = true;
    } // seq_2
    if (r5!==peg$FAILED) {
      peg$savedPos = p6;
      r5 = peg$a132(r4, r8, r12, r15);
    } else {
      r5 = null;
    }
    // free p7
    // val <- r5
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a133(r4, r5);
      break choice_1;
    }
    // free p3
    p3 = peg$currPos;
    p7 = peg$currPos;
    r1 = input.charAt(peg$currPos);
    if (/^[|}]/.test(r1)) {
      peg$currPos++;
      r1 = void 0;
      peg$currPos = p7;
      peg$savedPos = p3;
      r1 = peg$a134();
    } else {
      r1 = peg$FAILED;
    }
    // free p7
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsewikilink_preprocessor_text(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,r3,r4,r5,p6,r7,p8,p9,r10,p11,p12,r13,r14;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [546, boolParams & 0x3bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    r3 = [];
    for (;;) {
      choice_1: {
      p6 = peg$currPos;
      r5 = peg$FAILED;
      for (;;) {
        r7 = input.charAt(peg$currPos);
        if (/^[^<[{\n\r\t|!\]}{ &\-]/.test(r7)) {
          peg$currPos++;
          r5 = true;
        } else {
          r7 = peg$FAILED;
          if (!silence) {peg$fail(peg$c75);}
          break;
        }
      }
      // t <- r5
      if (r5!==peg$FAILED) {
        r5 = input.substring(p6, peg$currPos);
      } else {
        r5 = peg$FAILED;
      }
      // free r7
      // free p6
      r4 = r5;
      if (r4!==peg$FAILED) {
        break choice_1;
      }
      p6 = peg$currPos;
      seq_1: {
      p8 = peg$currPos;
      p9 = peg$currPos;
      r7 = peg$discardinline_breaks(true, boolParams, param_templatedepth, param_preproc, param_th);
      if (r7 === peg$FAILED) {
        r7 = void 0;
      } else {
        r7 = peg$FAILED;
        peg$currPos = p9;
        r4 = peg$FAILED;
        break seq_1;
      }
      // free p9
      choice_2: {
      r10 = peg$parsedirective(silence, boolParams, param_templatedepth, param_preproc, param_th);
      if (r10!==peg$FAILED) {
        break choice_2;
      }
      p9 = peg$currPos;
      seq_2: {
      p11 = peg$currPos;
      p12 = peg$currPos;
      r13 = input.substr(peg$currPos,2);
      if (r13 === "]]") {
        peg$currPos += 2;
      } else {
        r13 = peg$FAILED;
      }
      if (r13 === peg$FAILED) {
        r13 = void 0;
      } else {
        r13 = peg$FAILED;
        peg$currPos = p12;
        r10 = peg$FAILED;
        break seq_2;
      }
      // free p12
      choice_3: {
      r14 = peg$discardtext_char(silence);
      if (r14!==peg$FAILED) {
        break choice_3;
      }
      r14 = input.charAt(peg$currPos);
      if (/^[!<\-}\]\n\r]/.test(r14)) {
        peg$currPos++;
      } else {
        r14 = peg$FAILED;
        if (!silence) {peg$fail(peg$c76);}
      }
      } // choice_3
      if (r14===peg$FAILED) {
        peg$currPos = p11;
        r10 = peg$FAILED;
        break seq_2;
      }
      r10 = true;
      } // seq_2
      if (r10!==peg$FAILED) {
        r10 = input.substring(p9, peg$currPos);
      } else {
        r10 = peg$FAILED;
      }
      // free p11
      // free p9
      } // choice_2
      // wr <- r10
      if (r10===peg$FAILED) {
        peg$currPos = p8;
        r4 = peg$FAILED;
        break seq_1;
      }
      r4 = true;
      } // seq_1
      if (r4!==peg$FAILED) {
        peg$savedPos = p6;
        r4 = peg$a135(r5, r10);
      }
      // free p8
      } // choice_1
      if (r4!==peg$FAILED) {
        r3.push(r4);
      } else {
        break;
      }
    }
    if (r3.length === 0) {
      r3 = peg$FAILED;
    }
    // r <- r3
    // free r4
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a136(r3);
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsewikilink_content(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,r2,p3,p4,r5,r6,p7,r8;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [400, boolParams & 0x39f7, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    r1 = [];
    for (;;) {
      p3 = peg$currPos;
      seq_1: {
      p4 = peg$currPos;
      r5 = peg$discardpipe(silence);
      if (r5===peg$FAILED) {
        r2 = peg$FAILED;
        break seq_1;
      }
      p7 = peg$currPos;
      r6 = '';
      // startPos <- r6
      if (r6!==peg$FAILED) {
        peg$savedPos = p7;
        r6 = peg$a15();
      } else {
        peg$currPos = p4;
        r2 = peg$FAILED;
        break seq_1;
      }
      r8 = peg$parselink_text(silence, boolParams, param_templatedepth, param_preproc, param_th);
      if (r8===peg$FAILED) {
        r8 = null;
      }
      // lt <- r8
      r2 = true;
      } // seq_1
      if (r2!==peg$FAILED) {
        peg$savedPos = p3;
        r2 = peg$a137(r6, r8);
        r1.push(r2);
      } else {
        break;
      }
      // free p4
    }
    // free r2
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsespace_or_nbsp(silence) {
    var r1,p2,p3,r4,r5;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 512;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    r1 = peg$parsespace(silence);
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    r1 = peg$parseunispace(silence);
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = peg$parsehtmlentity(silence);
    // he <- r4
    if (r4===peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    peg$savedPos = peg$currPos;
    r5 = peg$a138(r4);
    if (r5) {
      r5 = void 0;
    } else {
      r5 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a57(r4);
    }
    // free p3
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$discardend_of_word(silence) {
    var r1,p2;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 509;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    r1 = peg$discardeof(silence);
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    p2 = peg$currPos;
    r1 = input.charAt(peg$currPos);
    if (/^[A-Za-z0-9_]/.test(r1)) {
      peg$currPos++;
    } else {
      r1 = peg$FAILED;
    }
    if (r1 === peg$FAILED) {
      r1 = void 0;
    } else {
      r1 = peg$FAILED;
      peg$currPos = p2;
    }
    // free p2
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parsespace_or_nbsp_or_dash(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 514;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    r1 = peg$parsespace_or_nbsp(silence);
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    if (input.charCodeAt(peg$currPos) === 45) {
      r1 = "-";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c57);}
      r1 = peg$FAILED;
    }
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parselang_variant_preproc(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,p5,r6,p7,p8,r9,r10,p11,r12,r13,p14,r15,r16,p17,r18,r19,r20,r21;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [376, boolParams & 0x3bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p5 = peg$currPos;
    r4 = input.substr(peg$currPos,2);
    // lv0 <- r4
    if (r4 === "-{") {
      peg$currPos += 2;
      peg$savedPos = p5;
      r4 = peg$a139();
    } else {
      if (!silence) {peg$fail(peg$c77);}
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    choice_1: {
    p7 = peg$currPos;
    seq_2: {
    p8 = peg$currPos;
    peg$savedPos = peg$currPos;
    r9 = peg$a140(r4);
    if (r9) {
      r9 = void 0;
    } else {
      r9 = peg$FAILED;
      r6 = peg$FAILED;
      break seq_2;
    }
    r10 = peg$parseopt_lang_variant_flags(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // ff <- r10
    if (r10===peg$FAILED) {
      peg$currPos = p8;
      r6 = peg$FAILED;
      break seq_2;
    }
    r6 = true;
    } // seq_2
    if (r6!==peg$FAILED) {
      peg$savedPos = p7;
      r6 = peg$a141(r4, r10);
      break choice_1;
    }
    // free p8
    p8 = peg$currPos;
    seq_3: {
    p11 = peg$currPos;
    peg$savedPos = peg$currPos;
    r12 = peg$a142(r4);
    if (r12) {
      r12 = void 0;
    } else {
      r12 = peg$FAILED;
      r6 = peg$FAILED;
      break seq_3;
    }
    r6 = true;
    } // seq_3
    if (r6!==peg$FAILED) {
      peg$savedPos = p8;
      r6 = peg$a143(r4);
    }
    // free p11
    } // choice_1
    // f <- r6
    if (r6===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    choice_2: {
    p11 = peg$currPos;
    seq_4: {
    p14 = peg$currPos;
    peg$savedPos = peg$currPos;
    r15 = peg$a144(r4, r6);
    if (r15) {
      r15 = void 0;
    } else {
      r15 = peg$FAILED;
      r13 = peg$FAILED;
      break seq_4;
    }
    r16 = peg$parselang_variant_text(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // lv <- r16
    if (r16===peg$FAILED) {
      peg$currPos = p14;
      r13 = peg$FAILED;
      break seq_4;
    }
    r13 = true;
    } // seq_4
    if (r13!==peg$FAILED) {
      peg$savedPos = p11;
      r13 = peg$a145(r4, r6, r16);
      break choice_2;
    }
    // free p14
    p14 = peg$currPos;
    seq_5: {
    p17 = peg$currPos;
    peg$savedPos = peg$currPos;
    r18 = peg$a146(r4, r6);
    if (r18) {
      r18 = void 0;
    } else {
      r18 = peg$FAILED;
      r13 = peg$FAILED;
      break seq_5;
    }
    r19 = peg$parselang_variant_option_list(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // lv <- r19
    if (r19===peg$FAILED) {
      peg$currPos = p17;
      r13 = peg$FAILED;
      break seq_5;
    }
    r13 = true;
    } // seq_5
    if (r13!==peg$FAILED) {
      peg$savedPos = p14;
      r13 = peg$a147(r4, r6, r19);
    }
    // free p17
    } // choice_2
    // ts <- r13
    if (r13===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r20 = peg$discardinline_breaks(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r20===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p17 = peg$currPos;
    r21 = input.substr(peg$currPos,2);
    // lv1 <- r21
    if (r21 === "}-") {
      peg$currPos += 2;
      peg$savedPos = p17;
      r21 = peg$a148(r4, r6, r13);
    } else {
      if (!silence) {peg$fail(peg$c78);}
      r21 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a149(r4, r6, r13, r21);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsebroken_lang_variant(silence, param_preproc) {
    var r1,p2,p3,r4;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [372, param_preproc.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = input.substr(peg$currPos,2);
    // r <- r4
    if (r4 === "-{") {
      peg$currPos += 2;
    } else {
      if (!silence) {peg$fail(peg$c77);}
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a150(r4, param_preproc);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
    }
    return r1;
  }
  function peg$discardlist_char(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 457;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    r1 = input.charAt(peg$currPos);
    if (/^[*#:;]/.test(r1)) {
      peg$currPos++;
    } else {
      r1 = peg$FAILED;
      if (!silence) {peg$fail(peg$c79);}
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parselist_char(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 456;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    r1 = input.charAt(peg$currPos);
    if (/^[*#:;]/.test(r1)) {
      peg$currPos++;
    } else {
      r1 = peg$FAILED;
      if (!silence) {peg$fail(peg$c79);}
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parseinlineline_break_on_colon(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,r3;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [458, boolParams & 0x2bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    r3 = peg$parseinlineline(silence, boolParams | 0x1000, param_templatedepth, param_preproc, param_th);
    // ill <- r3
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a151(r3);
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$discardcomment_space_eolf(silence) {
    var p1,r2,r3,r4,r5;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 543;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    seq_1: {
    p1 = peg$currPos;
    for (;;) {
      choice_1: {
      r4 = peg$FAILED;
      for (;;) {
        r5 = peg$discardspace(silence);
        if (r5!==peg$FAILED) {
          r4 = true;
        } else {
          break;
        }
      }
      if (r4!==peg$FAILED) {
        break choice_1;
      }
      // free r5
      r4 = peg$discardcomment(silence);
      } // choice_1
      if (r4===peg$FAILED) {
        break;
      }
    }
    // free r4
    r3 = true;
    if (r3===peg$FAILED) {
      r2 = peg$FAILED;
      break seq_1;
    }
    // free r3
    r3 = peg$discardeolf(silence);
    if (r3===peg$FAILED) {
      peg$currPos = p1;
      r2 = peg$FAILED;
      break seq_1;
    }
    r2 = true;
    } // seq_1
    // free r2,p1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r2,
      };
  
    }
    return r2;
  }
  function peg$discardempty_line_with_comments(silence) {
    var r1,p2,p3,r4,r5,p6,r7,r8,p9,r10,r11,r12,r13;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 525;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = peg$parsesol_prefix(silence);
    // sp <- r4
    if (r4===peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    p6 = peg$currPos;
    r5 = '';
    // p <- r5
    if (r5!==peg$FAILED) {
      peg$savedPos = p6;
      r5 = peg$a93(r4);
    } else {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r7 = [];
    for (;;) {
      seq_2: {
      p9 = peg$currPos;
      r10 = [];
      for (;;) {
        r11 = peg$parsespace(silence);
        if (r11!==peg$FAILED) {
          r10.push(r11);
        } else {
          break;
        }
      }
      // free r11
      r11 = peg$parsecomment(silence);
      if (r11===peg$FAILED) {
        peg$currPos = p9;
        r8 = peg$FAILED;
        break seq_2;
      }
      r12 = [];
      for (;;) {
        choice_1: {
        r13 = peg$parsespace(silence);
        if (r13!==peg$FAILED) {
          break choice_1;
        }
        r13 = peg$parsecomment(silence);
        } // choice_1
        if (r13!==peg$FAILED) {
          r12.push(r13);
        } else {
          break;
        }
      }
      // free r13
      r13 = peg$parsenewline(silence);
      if (r13===peg$FAILED) {
        peg$currPos = p9;
        r8 = peg$FAILED;
        break seq_2;
      }
      r8 = [r10,r11,r12,r13];
      } // seq_2
      if (r8!==peg$FAILED) {
        r7.push(r8);
      } else {
        break;
      }
      // free p9
    }
    if (r7.length === 0) {
      r7 = peg$FAILED;
    }
    // c <- r7
    if (r7===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free r8
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a94(r4, r5, r7);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$discardsol_prefix(silence) {
    var r1,p2;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 523;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    r1 = peg$discardnewlineToken(silence);
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    p2 = peg$currPos;
    peg$savedPos = peg$currPos;
    r1 = peg$a95();
    if (r1) {
      r1 = void 0;
      peg$savedPos = p2;
      r1 = peg$a96();
    } else {
      r1 = peg$FAILED;
    }
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$discardcomment_or_includes(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,r2;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [519, boolParams & 0x13af, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    for (;;) {
      choice_1: {
      r2 = peg$discardcomment(silence);
      if (r2!==peg$FAILED) {
        break choice_1;
      }
      r2 = peg$discardinclude_limits(silence, boolParams | 0x2000, param_templatedepth, param_preproc, param_th);
      } // choice_1
      if (r2===peg$FAILED) {
        break;
      }
    }
    // free r2
    r1 = true;
    // free r1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsetable_heading_tags(silence, boolParams, param_templatedepth, param_preproc) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [480, boolParams & 0x3bff, param_templatedepth, param_preproc.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    r1 = peg$parsetable_heading_tags_parameterized(silence, boolParams, param_templatedepth, param_preproc, new peg$Reference(true));
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
    }
    return r1;
  }
  function peg$parsetable_row_tag(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,r6,p7,r8,r9;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [472, boolParams & 0x3bef, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    if (!(/*tableDataBlock*/(boolParams & 0x1) !== 0)) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    r5 = peg$parsepipe(silence);
    // p <- r5
    if (r5===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p7 = peg$currPos;
    r6 = peg$FAILED;
    for (;;) {
      if (input.charCodeAt(peg$currPos) === 45) {
        r8 = "-";
        peg$currPos += 1;
        r6 = true;
      } else {
        if (!silence) {peg$fail(peg$c57);}
        r8 = peg$FAILED;
        break;
      }
    }
    // dashes <- r6
    if (r6!==peg$FAILED) {
      r6 = input.substring(p7, peg$currPos);
    } else {
      r6 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free r8
    // free p7
    choice_1: {
    r8 = peg$parsetable_attributes(silence, boolParams & ~0x10, param_templatedepth, param_preproc, param_th);
    if (r8!==peg$FAILED) {
      break choice_1;
    }
    peg$savedPos = peg$currPos;
    r8 = peg$a152(r5, r6);
    if (r8) {
      r8 = void 0;
    } else {
      r8 = peg$FAILED;
    }
    } // choice_1
    // a <- r8
    if (r8===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p7 = peg$currPos;
    r9 = '';
    // tagEndPos <- r9
    if (r9!==peg$FAILED) {
      peg$savedPos = p7;
      r9 = peg$a153(r5, r6, r8);
    } else {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a154(r5, r6, r8, r9);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsetable_data_tags(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,p6,r7,r8,r9,r10;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [476, boolParams & 0x3bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    if (!(/*tableDataBlock*/(boolParams & 0x1) !== 0)) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    r5 = peg$parsepipe(silence);
    // p <- r5
    if (r5===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p6 = peg$currPos;
    r7 = input.charAt(peg$currPos);
    if (/^[+\-]/.test(r7)) {
      peg$currPos++;
    } else {
      r7 = peg$FAILED;
    }
    if (r7 === peg$FAILED) {
      r7 = void 0;
    } else {
      r7 = peg$FAILED;
      peg$currPos = p6;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p6
    r8 = peg$parsetable_data_tag(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // td <- r8
    if (r8===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p6 = peg$currPos;
    r9 = '';
    // tagEndPos <- r9
    if (r9!==peg$FAILED) {
      peg$savedPos = p6;
      r9 = peg$a155(r5, r8);
    } else {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r10 = peg$parsetds(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // tds <- r10
    if (r10===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a156(r5, r8, r9, r10);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsetable_caption_tag(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,r6,r7,r8,p9,r10,r11;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [470, boolParams & 0x3bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    if (!(/*tableDataBlock*/(boolParams & 0x1) !== 0)) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    r5 = peg$parsepipe(silence);
    // p <- r5
    if (r5===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    if (input.charCodeAt(peg$currPos) === 43) {
      r6 = "+";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c80);}
      r6 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r7 = peg$parserow_syntax_table_args(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r7===peg$FAILED) {
      r7 = null;
    }
    // args <- r7
    p9 = peg$currPos;
    r8 = '';
    // tagEndPos <- r8
    if (r8!==peg$FAILED) {
      peg$savedPos = p9;
      r8 = peg$a157(r5, r7);
    } else {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r10 = [];
    for (;;) {
      r11 = peg$parsenested_block_in_table(silence, boolParams, param_templatedepth, param_preproc, param_th);
      if (r11!==peg$FAILED) {
        r10.push(r11);
      } else {
        break;
      }
    }
    // c <- r10
    // free r11
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a158(r5, r7, r8, r10);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$discardtag_name_chars(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 421;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    r1 = input.charAt(peg$currPos);
    if (/^[^\t\n\x0B \/>\0]/.test(r1)) {
      peg$currPos++;
    } else {
      r1 = peg$FAILED;
      if (!silence) {peg$fail(peg$c81);}
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parsetemplate_param_text(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,r3,r4;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [368, boolParams & 0x3b8b, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    r3 = [];
    for (;;) {
      choice_1: {
      r4 = peg$parsenested_block(silence, (boolParams & ~0x54) | 0x20, param_templatedepth, param_preproc, param_th);
      if (r4!==peg$FAILED) {
        break choice_1;
      }
      r4 = peg$parsenewlineToken(silence);
      } // choice_1
      if (r4!==peg$FAILED) {
        r3.push(r4);
      } else {
        break;
      }
    }
    if (r3.length === 0) {
      r3 = peg$FAILED;
    }
    // il <- r3
    // free r4
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a159(r3);
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$discardcomment_space(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 527;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    r1 = peg$discardcomment(silence);
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    r1 = peg$discardspace(silence);
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parsecomment_space(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 526;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    r1 = peg$parsecomment(silence);
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    r1 = peg$parsespace(silence);
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parsetemplate_param_name(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,r3,p4,p5;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [364, boolParams & 0x3b83, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    choice_1: {
    r3 = peg$parsetemplate_param_text(silence, boolParams | 0x8, param_templatedepth, param_preproc, param_th);
    if (r3!==peg$FAILED) {
      break choice_1;
    }
    p4 = peg$currPos;
    p5 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 61) {
      r3 = "=";
      peg$currPos += 1;
      r3 = void 0;
      peg$currPos = p5;
      peg$savedPos = p4;
      r3 = peg$a160();
    } else {
      r3 = peg$FAILED;
    }
    // free p5
    } // choice_1
    // tpt <- r3
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a161(r3);
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$discardtext_char(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 491;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    r1 = input.charAt(peg$currPos);
    if (/^[^\-'<~[{\n\r:;\]}|!=]/.test(r1)) {
      peg$currPos++;
    } else {
      r1 = peg$FAILED;
      if (!silence) {peg$fail(peg$c44);}
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parselink_text(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [408, boolParams & 0x39f7, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    r1 = peg$parselink_text_parameterized(silence, (boolParams & ~0x8) | 0x200, param_templatedepth, param_preproc, param_th);
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parseunispace(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 510;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    r1 = input.charAt(peg$currPos);
    if (/^[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/.test(r1)) {
      peg$currPos++;
    } else {
      r1 = peg$FAILED;
      if (!silence) {peg$fail(peg$c25);}
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parseopt_lang_variant_flags(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,r3,p4,p5,r6,r7;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [378, boolParams & 0x3baf, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    p4 = peg$currPos;
    seq_1: {
    p5 = peg$currPos;
    r6 = peg$parselang_variant_flags(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // ff <- r6
    if (r6===peg$FAILED) {
      r3 = peg$FAILED;
      break seq_1;
    }
    if (input.charCodeAt(peg$currPos) === 124) {
      r7 = "|";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c13);}
      r7 = peg$FAILED;
      peg$currPos = p5;
      r3 = peg$FAILED;
      break seq_1;
    }
    r3 = true;
    } // seq_1
    if (r3!==peg$FAILED) {
      peg$savedPos = p4;
      r3 = peg$a162(r6);
    } else {
      r3 = null;
    }
    // free p5
    // f <- r3
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a163(r3);
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parselang_variant_text(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,r3,r4;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [394, boolParams & 0x3bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    r3 = [];
    for (;;) {
      choice_1: {
      r4 = peg$parseinlineline(silence, boolParams, param_templatedepth, param_preproc, param_th);
      if (r4!==peg$FAILED) {
        break choice_1;
      }
      if (input.charCodeAt(peg$currPos) === 124) {
        r4 = "|";
        peg$currPos += 1;
      } else {
        if (!silence) {peg$fail(peg$c13);}
        r4 = peg$FAILED;
      }
      } // choice_1
      if (r4!==peg$FAILED) {
        r3.push(r4);
      } else {
        break;
      }
    }
    // tokens <- r3
    // free r4
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a164(r3);
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parselang_variant_option_list(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,r6,p7,p8,r9,r10,r11,r12,p13,r14;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [386, boolParams & 0x3bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = peg$parselang_variant_option(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // o <- r4
    if (r4===peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    r5 = [];
    for (;;) {
      p7 = peg$currPos;
      seq_2: {
      p8 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 59) {
        r9 = ";";
        peg$currPos += 1;
      } else {
        if (!silence) {peg$fail(peg$c31);}
        r9 = peg$FAILED;
        r6 = peg$FAILED;
        break seq_2;
      }
      r10 = peg$parselang_variant_option(silence, boolParams, param_templatedepth, param_preproc, param_th);
      // oo <- r10
      if (r10===peg$FAILED) {
        peg$currPos = p8;
        r6 = peg$FAILED;
        break seq_2;
      }
      r6 = true;
      } // seq_2
      if (r6!==peg$FAILED) {
        peg$savedPos = p7;
        r6 = peg$a165(r4, r10);
        r5.push(r6);
      } else {
        break;
      }
      // free p8
    }
    // rest <- r5
    // free r6
    r6 = [];
    for (;;) {
      seq_3: {
      p8 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 59) {
        r12 = ";";
        peg$currPos += 1;
      } else {
        if (!silence) {peg$fail(peg$c31);}
        r12 = peg$FAILED;
        r11 = peg$FAILED;
        break seq_3;
      }
      p13 = peg$currPos;
      r14 = peg$discardbogus_lang_variant_option(silence, boolParams, param_templatedepth, param_preproc, param_th);
      if (r14!==peg$FAILED) {
        r14 = input.substring(p13, peg$currPos);
      } else {
        r14 = peg$FAILED;
        peg$currPos = p8;
        r11 = peg$FAILED;
        break seq_3;
      }
      // free p13
      r11 = [r12,r14];
      } // seq_3
      if (r11!==peg$FAILED) {
        r6.push(r11);
      } else {
        break;
      }
      // free p8
    }
    // tr <- r6
    // free r11
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a166(r4, r5, r6);
      break choice_1;
    }
    // free p3
    p3 = peg$currPos;
    r11 = peg$parselang_variant_text(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // lvtext <- r11
    r1 = r11;
    if (r1!==peg$FAILED) {
      peg$savedPos = p3;
      r1 = peg$a167(r11);
    }
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$discardcomment(silence) {
    var r1,p2,p3,r4,r5,p6,r7,p8,p9,r10,r11;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 323;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = input.substr(peg$currPos,4);
    if (r4 === "<!--") {
      peg$currPos += 4;
    } else {
      if (!silence) {peg$fail(peg$c10);}
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    p6 = peg$currPos;
    for (;;) {
      seq_2: {
      p8 = peg$currPos;
      p9 = peg$currPos;
      r10 = input.substr(peg$currPos,3);
      if (r10 === "-->") {
        peg$currPos += 3;
      } else {
        r10 = peg$FAILED;
      }
      if (r10 === peg$FAILED) {
        r10 = void 0;
      } else {
        r10 = peg$FAILED;
        peg$currPos = p9;
        r7 = peg$FAILED;
        break seq_2;
      }
      // free p9
      if (peg$currPos < input.length) {
        r11 = input.charAt(peg$currPos++);
      } else {
        r11 = peg$FAILED;
        if (!silence) {peg$fail(peg$c11);}
        peg$currPos = p8;
        r7 = peg$FAILED;
        break seq_2;
      }
      r7 = true;
      } // seq_2
      if (r7===peg$FAILED) {
        break;
      }
      // free p8
    }
    // free r7
    r5 = true;
    // c <- r5
    if (r5!==peg$FAILED) {
      r5 = input.substring(p6, peg$currPos);
    } else {
      r5 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p6
    choice_1: {
    r7 = input.substr(peg$currPos,3);
    if (r7 === "-->") {
      peg$currPos += 3;
      break choice_1;
    } else {
      if (!silence) {peg$fail(peg$c12);}
      r7 = peg$FAILED;
    }
    r7 = peg$discardeof(silence);
    } // choice_1
    if (r7===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a24(r5);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$discardinclude_limits(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,p4,r5,p6,r7,r8,r9,p10,r11,r12,r13;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [531, boolParams & 0x33af, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p4 = peg$currPos;
    seq_2: {
    p6 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 60) {
      r7 = "<";
      peg$currPos += 1;
    } else {
      r7 = peg$FAILED;
      r5 = peg$FAILED;
      break seq_2;
    }
    if (input.charCodeAt(peg$currPos) === 47) {
      r8 = "/";
      peg$currPos += 1;
    } else {
      r8 = peg$FAILED;
      r8 = null;
    }
    p10 = peg$currPos;
    r9 = peg$FAILED;
    for (;;) {
      r11 = input.charAt(peg$currPos);
      if (/^[oyinclude]/i.test(r11)) {
        peg$currPos++;
        r9 = true;
      } else {
        r11 = peg$FAILED;
        break;
      }
    }
    // n <- r9
    if (r9!==peg$FAILED) {
      r9 = input.substring(p10, peg$currPos);
    } else {
      r9 = peg$FAILED;
      peg$currPos = p6;
      r5 = peg$FAILED;
      break seq_2;
    }
    // free r11
    // free p10
    peg$savedPos = peg$currPos;
    r11 = peg$a80(r9);
    if (r11) {
      r11 = void 0;
    } else {
      r11 = peg$FAILED;
      peg$currPos = p6;
      r5 = peg$FAILED;
      break seq_2;
    }
    r5 = true;
    } // seq_2
    if (r5!==peg$FAILED) {
      r5 = void 0;
      peg$currPos = p4;
    } else {
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p6
    // free p4
    r12 = peg$parsexmlish_tag(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // il <- r12
    if (r12===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    peg$savedPos = peg$currPos;
    r13 = peg$a81(r12, /*sol_il*/(boolParams & 0x2000) !== 0);
    if (r13) {
      r13 = void 0;
    } else {
      r13 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a82(r12, /*sol_il*/(boolParams & 0x2000) !== 0);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsetable_heading_tags_parameterized(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,r6,r7,p8,p9,r10,r11;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [482, boolParams & 0x3bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 33) {
      r4 = "!";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c82);}
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    r5 = peg$parsetable_heading_tag(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // thTag <- r5
    if (r5===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r6 = [];
    for (;;) {
      p8 = peg$currPos;
      seq_2: {
      p9 = peg$currPos;
      choice_1: {
      r10 = input.substr(peg$currPos,2);
      if (r10 === "!!") {
        peg$currPos += 2;
        break choice_1;
      } else {
        if (!silence) {peg$fail(peg$c83);}
        r10 = peg$FAILED;
      }
      r10 = peg$parsepipe_pipe(silence);
      } // choice_1
      // pp <- r10
      if (r10===peg$FAILED) {
        r7 = peg$FAILED;
        break seq_2;
      }
      r11 = peg$parsetable_heading_tag(silence, boolParams, param_templatedepth, param_preproc, param_th);
      // tht <- r11
      if (r11===peg$FAILED) {
        peg$currPos = p9;
        r7 = peg$FAILED;
        break seq_2;
      }
      r7 = true;
      } // seq_2
      if (r7!==peg$FAILED) {
        peg$savedPos = p8;
        r7 = peg$a168(r5, r10, r11);
        r6.push(r7);
      } else {
        break;
      }
      // free p9
    }
    // thTags <- r6
    // free r7
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a169(r5, r6);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsetable_data_tag(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,p4,r5,r6,r7,r8,r9;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [478, boolParams & 0x3bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p4 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 125) {
      r5 = "}";
      peg$currPos += 1;
    } else {
      r5 = peg$FAILED;
    }
    if (r5 === peg$FAILED) {
      r5 = void 0;
    } else {
      r5 = peg$FAILED;
      peg$currPos = p4;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p4
    r6 = peg$parserow_syntax_table_args(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r6===peg$FAILED) {
      r6 = null;
    }
    // arg <- r6
    p4 = peg$currPos;
    r7 = '';
    // tagEndPos <- r7
    if (r7!==peg$FAILED) {
      peg$savedPos = p4;
      r7 = peg$a170(r6);
    } else {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r8 = [];
    for (;;) {
      r9 = peg$parsenested_block_in_table(silence, boolParams, param_templatedepth, param_preproc, param_th);
      if (r9!==peg$FAILED) {
        r8.push(r9);
      } else {
        break;
      }
    }
    // td <- r8
    // free r9
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a171(r6, r7, r8);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsetds(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,r2,p3,p4,r5,p6,p7,r8,p9,r10,r11;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [474, boolParams & 0x3bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    r1 = [];
    for (;;) {
      p3 = peg$currPos;
      seq_1: {
      p4 = peg$currPos;
      choice_1: {
      r5 = peg$parsepipe_pipe(silence);
      if (r5!==peg$FAILED) {
        break choice_1;
      }
      p6 = peg$currPos;
      seq_2: {
      p7 = peg$currPos;
      r8 = peg$parsepipe(silence);
      // p <- r8
      if (r8===peg$FAILED) {
        r5 = peg$FAILED;
        break seq_2;
      }
      p9 = peg$currPos;
      r10 = peg$discardrow_syntax_table_args(true, boolParams, param_templatedepth, param_preproc, param_th);
      if (r10!==peg$FAILED) {
        r10 = void 0;
        peg$currPos = p9;
      } else {
        peg$currPos = p7;
        r5 = peg$FAILED;
        break seq_2;
      }
      // free p9
      r5 = true;
      } // seq_2
      if (r5!==peg$FAILED) {
        peg$savedPos = p6;
        r5 = peg$a26(r8);
      }
      // free p7
      } // choice_1
      // pp <- r5
      if (r5===peg$FAILED) {
        r2 = peg$FAILED;
        break seq_1;
      }
      r11 = peg$parsetable_data_tag(silence, boolParams, param_templatedepth, param_preproc, param_th);
      // tdt <- r11
      if (r11===peg$FAILED) {
        peg$currPos = p4;
        r2 = peg$FAILED;
        break seq_1;
      }
      r2 = true;
      } // seq_1
      if (r2!==peg$FAILED) {
        peg$savedPos = p3;
        r2 = peg$a172(r5, r11);
        r1.push(r2);
      } else {
        break;
      }
      // free p4
    }
    // free r2
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsenested_block_in_table(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,p4,r5,p6,r7,r8,p9,r10,r11,r12;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [302, boolParams & 0x3bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p4 = peg$currPos;
    seq_2: {
    p6 = peg$currPos;
    r7 = peg$discardsol(true, boolParams, param_templatedepth, param_preproc, param_th);
    if (r7===peg$FAILED) {
      r5 = peg$FAILED;
      break seq_2;
    }
    seq_3: {
    p9 = peg$currPos;
    for (;;) {
      r11 = peg$discardspace(true);
      if (r11===peg$FAILED) {
        break;
      }
    }
    // free r11
    r10 = true;
    if (r10===peg$FAILED) {
      r8 = peg$FAILED;
      break seq_3;
    }
    // free r10
    r10 = peg$discardsol(true, boolParams, param_templatedepth, param_preproc, param_th);
    if (r10===peg$FAILED) {
      peg$currPos = p9;
      r8 = peg$FAILED;
      break seq_3;
    }
    r8 = true;
    } // seq_3
    if (r8===peg$FAILED) {
      r8 = null;
    }
    // free p9
    for (;;) {
      r12 = peg$discardspace(true);
      if (r12===peg$FAILED) {
        break;
      }
    }
    // free r12
    r11 = true;
    if (r11===peg$FAILED) {
      peg$currPos = p6;
      r5 = peg$FAILED;
      break seq_2;
    }
    // free r11
    choice_1: {
    r11 = peg$discardpipe(true);
    if (r11!==peg$FAILED) {
      break choice_1;
    }
    if (input.charCodeAt(peg$currPos) === 33) {
      r11 = "!";
      peg$currPos += 1;
    } else {
      r11 = peg$FAILED;
    }
    } // choice_1
    if (r11===peg$FAILED) {
      peg$currPos = p6;
      r5 = peg$FAILED;
      break seq_2;
    }
    r5 = true;
    } // seq_2
    // free p6
    if (r5 === peg$FAILED) {
      r5 = void 0;
    } else {
      r5 = peg$FAILED;
      peg$currPos = p4;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p4
    r12 = peg$parsenested_block(silence, boolParams | 0x1, param_templatedepth, param_preproc, param_th);
    // b <- r12
    if (r12===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a173(r12);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsenested_block(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,p4,r5,r6;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [300, boolParams & 0x3bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p4 = peg$currPos;
    r5 = peg$discardinline_breaks(true, boolParams, param_templatedepth, param_preproc, param_th);
    if (r5 === peg$FAILED) {
      r5 = void 0;
    } else {
      r5 = peg$FAILED;
      peg$currPos = p4;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p4
    r6 = peg$parseblock(silence, boolParams, param_templatedepth, param_th, param_preproc);
    // b <- r6
    if (r6===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a13(r6);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parselink_text_parameterized(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,r3,r4,p5,r6,r7,p8,p9,r10,r11,r12,r13,r14,p15,r16,p17,p18;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [410, boolParams & 0x3bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    r3 = [];
    for (;;) {
      choice_1: {
      seq_1: {
      p5 = peg$currPos;
      r6 = peg$parsesol(silence, boolParams, param_templatedepth, param_preproc, param_th);
      if (r6===peg$FAILED) {
        r4 = peg$FAILED;
        break seq_1;
      }
      choice_2: {
      r7 = peg$parseheading(silence, boolParams, param_templatedepth, param_preproc, param_th);
      if (r7!==peg$FAILED) {
        break choice_2;
      }
      r7 = peg$parsehr(silence, boolParams, param_templatedepth, param_preproc, param_th);
      if (r7!==peg$FAILED) {
        break choice_2;
      }
      r7 = peg$parsefull_table_in_link_caption(silence, boolParams, param_templatedepth, param_preproc, param_th);
      } // choice_2
      if (r7===peg$FAILED) {
        peg$currPos = p5;
        r4 = peg$FAILED;
        break seq_1;
      }
      r4 = [r6,r7];
      } // seq_1
      if (r4!==peg$FAILED) {
        break choice_1;
      }
      // free p5
      r4 = peg$parseurltext(silence, boolParams, param_templatedepth, param_preproc, param_th);
      if (r4!==peg$FAILED) {
        break choice_1;
      }
      p5 = peg$currPos;
      seq_2: {
      p8 = peg$currPos;
      p9 = peg$currPos;
      r10 = peg$discardinline_breaks(true, boolParams, param_templatedepth, param_preproc, param_th);
      if (r10 === peg$FAILED) {
        r10 = void 0;
      } else {
        r10 = peg$FAILED;
        peg$currPos = p9;
        r4 = peg$FAILED;
        break seq_2;
      }
      // free p9
      choice_3: {
      r11 = peg$parseinline_element(silence, boolParams, param_templatedepth, param_preproc, param_th);
      if (r11!==peg$FAILED) {
        break choice_3;
      }
      seq_3: {
      p9 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 91) {
        r12 = "[";
        peg$currPos += 1;
      } else {
        if (!silence) {peg$fail(peg$c19);}
        r12 = peg$FAILED;
        r11 = peg$FAILED;
        break seq_3;
      }
      r13 = [];
      for (;;) {
        r14 = peg$parsetext_char(silence);
        if (r14!==peg$FAILED) {
          r13.push(r14);
        } else {
          break;
        }
      }
      if (r13.length === 0) {
        r13 = peg$FAILED;
      }
      if (r13===peg$FAILED) {
        peg$currPos = p9;
        r11 = peg$FAILED;
        break seq_3;
      }
      // free r14
      if (input.charCodeAt(peg$currPos) === 93) {
        r14 = "]";
        peg$currPos += 1;
      } else {
        if (!silence) {peg$fail(peg$c21);}
        r14 = peg$FAILED;
        peg$currPos = p9;
        r11 = peg$FAILED;
        break seq_3;
      }
      p15 = peg$currPos;
      p17 = peg$currPos;
      choice_4: {
      p18 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 93) {
        r16 = "]";
        peg$currPos += 1;
      } else {
        r16 = peg$FAILED;
      }
      if (r16 === peg$FAILED) {
        r16 = void 0;
        break choice_4;
      } else {
        r16 = peg$FAILED;
        peg$currPos = p18;
      }
      // free p18
      r16 = input.substr(peg$currPos,2);
      if (r16 === "]]") {
        peg$currPos += 2;
      } else {
        r16 = peg$FAILED;
      }
      } // choice_4
      if (r16!==peg$FAILED) {
        r16 = void 0;
        peg$currPos = p17;
        r16 = input.substring(p15, peg$currPos);
      } else {
        r16 = peg$FAILED;
        peg$currPos = p9;
        r11 = peg$FAILED;
        break seq_3;
      }
      // free p17
      // free p15
      r11 = [r12,r13,r14,r16];
      } // seq_3
      if (r11!==peg$FAILED) {
        break choice_3;
      }
      // free p9
      if (peg$currPos < input.length) {
        r11 = input.charAt(peg$currPos++);
      } else {
        r11 = peg$FAILED;
        if (!silence) {peg$fail(peg$c11);}
      }
      } // choice_3
      // r <- r11
      if (r11===peg$FAILED) {
        peg$currPos = p8;
        r4 = peg$FAILED;
        break seq_2;
      }
      r4 = true;
      } // seq_2
      if (r4!==peg$FAILED) {
        peg$savedPos = p5;
        r4 = peg$a21(r11);
      }
      // free p8
      } // choice_1
      if (r4!==peg$FAILED) {
        r3.push(r4);
      } else {
        break;
      }
    }
    if (r3.length === 0) {
      r3 = peg$FAILED;
    }
    // c <- r3
    // free r4
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a174(r3);
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parselang_variant_flags(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,p5,r6,r7,r8,r9,r10,r11,r12;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [380, boolParams & 0x3baf, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p5 = peg$currPos;
    for (;;) {
      r6 = peg$discardspace_or_newline(silence);
      if (r6===peg$FAILED) {
        break;
      }
    }
    // free r6
    r4 = true;
    // sp1 <- r4
    if (r4!==peg$FAILED) {
      r4 = input.substring(p5, peg$currPos);
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p5
    r6 = peg$parselang_variant_flag(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // f <- r6
    if (r6===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p5 = peg$currPos;
    for (;;) {
      r8 = peg$discardspace_or_newline(silence);
      if (r8===peg$FAILED) {
        break;
      }
    }
    // free r8
    r7 = true;
    // sp2 <- r7
    if (r7!==peg$FAILED) {
      r7 = input.substring(p5, peg$currPos);
    } else {
      r7 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p5
    seq_2: {
    p5 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 59) {
      r9 = ";";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c31);}
      r9 = peg$FAILED;
      r8 = peg$FAILED;
      break seq_2;
    }
    r10 = peg$parselang_variant_flags(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r10===peg$FAILED) {
      r10 = null;
    }
    r8 = [r9,r10];
    } // seq_2
    if (r8===peg$FAILED) {
      r8 = null;
    }
    // free p5
    // more <- r8
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a175(r4, r6, r7, r8);
      break choice_1;
    }
    // free p3
    p3 = peg$currPos;
    p5 = peg$currPos;
    for (;;) {
      r12 = peg$discardspace_or_newline(silence);
      if (r12===peg$FAILED) {
        break;
      }
    }
    // free r12
    r11 = true;
    // sp <- r11
    if (r11!==peg$FAILED) {
      r11 = input.substring(p5, peg$currPos);
    } else {
      r11 = peg$FAILED;
    }
    // free p5
    r1 = r11;
    if (r1!==peg$FAILED) {
      peg$savedPos = p3;
      r1 = peg$a176(r11);
    }
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parselang_variant_option(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,p5,r6,r7,r8,r9,r10,r11,p12,r13,r14,r15,r16,r17,r18,r19,r20;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [390, boolParams & 0x3bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p5 = peg$currPos;
    for (;;) {
      r6 = peg$discardspace_or_newline(silence);
      if (r6===peg$FAILED) {
        break;
      }
    }
    // free r6
    r4 = true;
    // sp1 <- r4
    if (r4!==peg$FAILED) {
      r4 = input.substring(p5, peg$currPos);
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p5
    r6 = peg$parselang_variant_name(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // lang <- r6
    if (r6===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p5 = peg$currPos;
    for (;;) {
      r8 = peg$discardspace_or_newline(silence);
      if (r8===peg$FAILED) {
        break;
      }
    }
    // free r8
    r7 = true;
    // sp2 <- r7
    if (r7!==peg$FAILED) {
      r7 = input.substring(p5, peg$currPos);
    } else {
      r7 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p5
    if (input.charCodeAt(peg$currPos) === 58) {
      r8 = ":";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c18);}
      r8 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p5 = peg$currPos;
    for (;;) {
      r10 = peg$discardspace_or_newline(silence);
      if (r10===peg$FAILED) {
        break;
      }
    }
    // free r10
    r9 = true;
    // sp3 <- r9
    if (r9!==peg$FAILED) {
      r9 = input.substring(p5, peg$currPos);
    } else {
      r9 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p5
    choice_2: {
    r10 = peg$parselang_variant_nowiki(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r10!==peg$FAILED) {
      break choice_2;
    }
    r10 = peg$parselang_variant_text_no_semi(silence, boolParams, param_templatedepth, param_preproc, param_th);
    } // choice_2
    // lvtext <- r10
    if (r10===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a177(r4, r6, r7, r9, r10);
      break choice_1;
    }
    // free p3
    p3 = peg$currPos;
    seq_2: {
    p5 = peg$currPos;
    p12 = peg$currPos;
    for (;;) {
      r13 = peg$discardspace_or_newline(silence);
      if (r13===peg$FAILED) {
        break;
      }
    }
    // free r13
    r11 = true;
    // sp1 <- r11
    if (r11!==peg$FAILED) {
      r11 = input.substring(p12, peg$currPos);
    } else {
      r11 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_2;
    }
    // free p12
    choice_3: {
    r13 = peg$parselang_variant_nowiki(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r13!==peg$FAILED) {
      break choice_3;
    }
    r13 = peg$parselang_variant_text_no_semi_or_arrow(silence, boolParams, param_templatedepth, param_preproc, param_th);
    } // choice_3
    // from <- r13
    if (r13===peg$FAILED) {
      peg$currPos = p5;
      r1 = peg$FAILED;
      break seq_2;
    }
    r14 = input.substr(peg$currPos,2);
    if (r14 === "=>") {
      peg$currPos += 2;
    } else {
      if (!silence) {peg$fail(peg$c84);}
      r14 = peg$FAILED;
      peg$currPos = p5;
      r1 = peg$FAILED;
      break seq_2;
    }
    p12 = peg$currPos;
    for (;;) {
      r16 = peg$discardspace_or_newline(silence);
      if (r16===peg$FAILED) {
        break;
      }
    }
    // free r16
    r15 = true;
    // sp2 <- r15
    if (r15!==peg$FAILED) {
      r15 = input.substring(p12, peg$currPos);
    } else {
      r15 = peg$FAILED;
      peg$currPos = p5;
      r1 = peg$FAILED;
      break seq_2;
    }
    // free p12
    r16 = peg$parselang_variant_name(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // lang <- r16
    if (r16===peg$FAILED) {
      peg$currPos = p5;
      r1 = peg$FAILED;
      break seq_2;
    }
    p12 = peg$currPos;
    for (;;) {
      r18 = peg$discardspace_or_newline(silence);
      if (r18===peg$FAILED) {
        break;
      }
    }
    // free r18
    r17 = true;
    // sp3 <- r17
    if (r17!==peg$FAILED) {
      r17 = input.substring(p12, peg$currPos);
    } else {
      r17 = peg$FAILED;
      peg$currPos = p5;
      r1 = peg$FAILED;
      break seq_2;
    }
    // free p12
    if (input.charCodeAt(peg$currPos) === 58) {
      r18 = ":";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c18);}
      r18 = peg$FAILED;
      peg$currPos = p5;
      r1 = peg$FAILED;
      break seq_2;
    }
    p12 = peg$currPos;
    for (;;) {
      r20 = peg$discardspace_or_newline(silence);
      if (r20===peg$FAILED) {
        break;
      }
    }
    // free r20
    r19 = true;
    // sp4 <- r19
    if (r19!==peg$FAILED) {
      r19 = input.substring(p12, peg$currPos);
    } else {
      r19 = peg$FAILED;
      peg$currPos = p5;
      r1 = peg$FAILED;
      break seq_2;
    }
    // free p12
    choice_4: {
    r20 = peg$parselang_variant_nowiki(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r20!==peg$FAILED) {
      break choice_4;
    }
    r20 = peg$parselang_variant_text_no_semi(silence, boolParams, param_templatedepth, param_preproc, param_th);
    } // choice_4
    // to <- r20
    if (r20===peg$FAILED) {
      peg$currPos = p5;
      r1 = peg$FAILED;
      break seq_2;
    }
    r1 = true;
    } // seq_2
    if (r1!==peg$FAILED) {
      peg$savedPos = p3;
      r1 = peg$a178(r11, r13, r15, r16, r17, r19, r20);
    }
    // free p5
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$discardbogus_lang_variant_option(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [389, boolParams & 0x3bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    r1 = peg$discardlang_variant_text(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r1===peg$FAILED) {
      r1 = null;
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsetable_heading_tag(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,p6,r7,r8,p9,p10,r11;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [484, boolParams & 0x3bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = peg$parserow_syntax_table_args(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r4===peg$FAILED) {
      r4 = null;
    }
    // arg <- r4
    p6 = peg$currPos;
    r5 = '';
    // tagEndPos <- r5
    if (r5!==peg$FAILED) {
      peg$savedPos = p6;
      r5 = peg$a170(r4);
    } else {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r7 = [];
    for (;;) {
      p9 = peg$currPos;
      seq_2: {
      p10 = peg$currPos;
      r11 = peg$parsenested_block_in_table(silence, boolParams, param_templatedepth, param_preproc, param_th);
      // d <- r11
      if (r11===peg$FAILED) {
        peg$currPos = p10;
        r8 = peg$FAILED;
        break seq_2;
      }
      r8 = true;
      } // seq_2
      if (r8!==peg$FAILED) {
        peg$savedPos = p9;
        r8 = peg$a179(r4, r5, param_th, r11);
        r7.push(r8);
      } else {
        break;
      }
      // free p10
    }
    // c <- r7
    // free r8
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a180(r4, r5, r7);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsepipe_pipe(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 566;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    r1 = input.substr(peg$currPos,2);
    if (r1 === "||") {
      peg$currPos += 2;
      break choice_1;
    } else {
      if (!silence) {peg$fail(peg$c85);}
      r1 = peg$FAILED;
    }
    r1 = input.substr(peg$currPos,10);
    if (r1 === "{{!}}{{!}}") {
      peg$currPos += 10;
    } else {
      if (!silence) {peg$fail(peg$c86);}
      r1 = peg$FAILED;
    }
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$discardrow_syntax_table_args(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,r6,p7,r8;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [489, boolParams & 0x3bbf, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = peg$parsetable_attributes(silence, boolParams | 0x40, param_templatedepth, param_preproc, param_th);
    // as <- r4
    if (r4===peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    r5 = peg$parseoptional_spaces(silence);
    // s <- r5
    if (r5===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r6 = peg$parsepipe(silence);
    // p <- r6
    if (r6===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p7 = peg$currPos;
    r8 = peg$discardpipe(true);
    if (r8 === peg$FAILED) {
      r8 = void 0;
    } else {
      r8 = peg$FAILED;
      peg$currPos = p7;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p7
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a12(r4, r5, r6);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsefull_table_in_link_caption(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,p5,r6;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [460, boolParams & 0x3bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    choice_1: {
    p5 = peg$currPos;
    r4 = peg$discardinline_breaks(true, boolParams, param_templatedepth, param_preproc, param_th);
    if (r4 === peg$FAILED) {
      r4 = void 0;
      break choice_1;
    } else {
      r4 = peg$FAILED;
      peg$currPos = p5;
    }
    // free p5
    p5 = peg$currPos;
    r4 = input.substr(peg$currPos,5);
    if (r4 === "{{!}}") {
      peg$currPos += 5;
      r4 = void 0;
      peg$currPos = p5;
    } else {
      r4 = peg$FAILED;
    }
    // free p5
    } // choice_1
    if (r4===peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    r6 = peg$parsefull_table_in_link_caption_parameterized(silence, (boolParams & ~0x200) | 0x10, param_templatedepth, param_preproc, param_th);
    // r <- r6
    if (r6===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a181(r6);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsetext_char(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 490;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
  
        return cached.result;
      }
  
    } else {
      visitCounts[peg$currPos]++;
    }
    r1 = input.charAt(peg$currPos);
    if (/^[^\-'<~[{\n\r:;\]}|!=]/.test(r1)) {
      peg$currPos++;
    } else {
      r1 = peg$FAILED;
      if (!silence) {peg$fail(peg$c44);}
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parselang_variant_flag(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,r3,p4,r5,p6,r7,p8,r9,p10,p11,r12,r13,r14;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [382, boolParams & 0x3baf, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    p2 = peg$currPos;
    r3 = input.charAt(peg$currPos);
    // f <- r3
    if (/^[\-+A-Z]/.test(r3)) {
      peg$currPos++;
    } else {
      r3 = peg$FAILED;
      if (!silence) {peg$fail(peg$c87);}
    }
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a182(r3);
      break choice_1;
    }
    p4 = peg$currPos;
    r5 = peg$parselang_variant_name(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // v <- r5
    r1 = r5;
    if (r1!==peg$FAILED) {
      peg$savedPos = p4;
      r1 = peg$a183(r5);
      break choice_1;
    }
    p6 = peg$currPos;
    p8 = peg$currPos;
    r7 = peg$FAILED;
    for (;;) {
      seq_1: {
      p10 = peg$currPos;
      p11 = peg$currPos;
      r12 = peg$discardspace_or_newline(true);
      if (r12 === peg$FAILED) {
        r12 = void 0;
      } else {
        r12 = peg$FAILED;
        peg$currPos = p11;
        r9 = peg$FAILED;
        break seq_1;
      }
      // free p11
      p11 = peg$currPos;
      r13 = peg$discardnowiki(true, boolParams, param_templatedepth, param_preproc, param_th);
      if (r13 === peg$FAILED) {
        r13 = void 0;
      } else {
        r13 = peg$FAILED;
        peg$currPos = p11;
        peg$currPos = p10;
        r9 = peg$FAILED;
        break seq_1;
      }
      // free p11
      r14 = input.charAt(peg$currPos);
      if (/^[^{}|;]/.test(r14)) {
        peg$currPos++;
      } else {
        r14 = peg$FAILED;
        if (!silence) {peg$fail(peg$c88);}
        peg$currPos = p10;
        r9 = peg$FAILED;
        break seq_1;
      }
      r9 = true;
      } // seq_1
      if (r9!==peg$FAILED) {
        r7 = true;
      } else {
        break;
      }
      // free p10
    }
    // b <- r7
    if (r7!==peg$FAILED) {
      r7 = input.substring(p8, peg$currPos);
    } else {
      r7 = peg$FAILED;
    }
    // free r9
    // free p8
    r1 = r7;
    if (r1!==peg$FAILED) {
      peg$savedPos = p6;
      r1 = peg$a184(r7);
    }
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parselang_variant_name(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,r6;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [384, boolParams & 0x3baf, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = input.charAt(peg$currPos);
    if (/^[a-z]/.test(r4)) {
      peg$currPos++;
    } else {
      r4 = peg$FAILED;
      if (!silence) {peg$fail(peg$c89);}
      r1 = peg$FAILED;
      break seq_1;
    }
    r5 = peg$FAILED;
    for (;;) {
      r6 = input.charAt(peg$currPos);
      if (/^[\-a-zA-Z]/.test(r6)) {
        peg$currPos++;
        r5 = true;
      } else {
        r6 = peg$FAILED;
        if (!silence) {peg$fail(peg$c90);}
        break;
      }
    }
    if (r5===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free r6
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      r1 = input.substring(p2, peg$currPos);
      break choice_1;
    } else {
      r1 = peg$FAILED;
    }
    // free p3
    // free p2
    r1 = peg$parsenowiki_text(silence, boolParams, param_templatedepth, param_preproc, param_th);
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parselang_variant_nowiki(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,p6,r7;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [392, boolParams & 0x3baf, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = peg$parsenowiki_text(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // n <- r4
    if (r4===peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    p6 = peg$currPos;
    for (;;) {
      r7 = peg$discardspace_or_newline(silence);
      if (r7===peg$FAILED) {
        break;
      }
    }
    // free r7
    r5 = true;
    // sp <- r5
    if (r5!==peg$FAILED) {
      r5 = input.substring(p6, peg$currPos);
    } else {
      r5 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p6
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a185(r4, r5);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parselang_variant_text_no_semi(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [396, boolParams & 0x3b7f, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    r1 = peg$parselang_variant_text(silence, boolParams | 0x80, param_templatedepth, param_preproc, param_th);
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parselang_variant_text_no_semi_or_arrow(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [398, boolParams & 0x3a7f, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    r1 = peg$parselang_variant_text_no_semi(silence, boolParams | 0x100, param_templatedepth, param_preproc, param_th);
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$discardlang_variant_text(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,r3,r4;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [395, boolParams & 0x3bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    r3 = [];
    for (;;) {
      choice_1: {
      r4 = peg$parseinlineline(silence, boolParams, param_templatedepth, param_preproc, param_th);
      if (r4!==peg$FAILED) {
        break choice_1;
      }
      if (input.charCodeAt(peg$currPos) === 124) {
        r4 = "|";
        peg$currPos += 1;
      } else {
        if (!silence) {peg$fail(peg$c13);}
        r4 = peg$FAILED;
      }
      } // choice_1
      if (r4!==peg$FAILED) {
        r3.push(r4);
      } else {
        break;
      }
    }
    // tokens <- r3
    // free r4
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a164(r3);
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsefull_table_in_link_caption_parameterized(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,r3,p4,r5,r6,r7,r8,p9,r10,r11,p12,r13,r14,r15,r16;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [462, boolParams & 0x3bff, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p4 = peg$currPos;
    r5 = peg$parsetable_start_tag(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r5===peg$FAILED) {
      r3 = peg$FAILED;
      break seq_1;
    }
    r6 = peg$parseoptionalNewlines(silence);
    if (r6===peg$FAILED) {
      peg$currPos = p4;
      r3 = peg$FAILED;
      break seq_1;
    }
    r7 = [];
    for (;;) {
      seq_2: {
      p9 = peg$currPos;
      r10 = [];
      for (;;) {
        seq_3: {
        p12 = peg$currPos;
        r13 = peg$parsesol(silence, boolParams, param_templatedepth, param_preproc, param_th);
        if (r13===peg$FAILED) {
          r11 = peg$FAILED;
          break seq_3;
        }
        choice_1: {
        r14 = peg$parsetable_content_line(silence, boolParams, param_templatedepth, param_preproc, param_th);
        if (r14!==peg$FAILED) {
          break choice_1;
        }
        r14 = peg$parsetplarg_or_template(silence, boolParams, param_templatedepth, param_th, param_preproc);
        } // choice_1
        if (r14===peg$FAILED) {
          peg$currPos = p12;
          r11 = peg$FAILED;
          break seq_3;
        }
        r15 = peg$parseoptionalNewlines(silence);
        if (r15===peg$FAILED) {
          peg$currPos = p12;
          r11 = peg$FAILED;
          break seq_3;
        }
        r11 = [r13,r14,r15];
        } // seq_3
        if (r11!==peg$FAILED) {
          r10.push(r11);
        } else {
          break;
        }
        // free p12
      }
      // free r11
      r11 = peg$parsesol(silence, boolParams, param_templatedepth, param_preproc, param_th);
      if (r11===peg$FAILED) {
        peg$currPos = p9;
        r8 = peg$FAILED;
        break seq_2;
      }
      r16 = peg$parsetable_end_tag(silence);
      if (r16===peg$FAILED) {
        peg$currPos = p9;
        r8 = peg$FAILED;
        break seq_2;
      }
      r8 = [r10,r11,r16];
      } // seq_2
      if (r8!==peg$FAILED) {
        r7.push(r8);
      } else {
        break;
      }
      // free p9
    }
    if (r7.length === 0) {
      r7 = peg$FAILED;
    }
    if (r7===peg$FAILED) {
      peg$currPos = p4;
      r3 = peg$FAILED;
      break seq_1;
    }
    // free r8
    r3 = [r5,r6,r7];
    } // seq_1
    // tbl <- r3
    // free p4
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a186(r3);
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$discardnowiki(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [417, boolParams & 0x3baf, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = peg$parseextension_tag(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // extToken <- r4
    if (r4===peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    peg$savedPos = peg$currPos;
    r5 = peg$a187(r4);
    if (r5) {
      r5 = void 0;
    } else {
      r5 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a188(r4);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsenowiki_text(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,r3;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [418, boolParams & 0x3baf, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    r3 = peg$parsenowiki(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // extToken <- r3
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a189(r3);
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsenowiki(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [416, boolParams & 0x3baf, param_templatedepth, param_preproc.value, param_th.value].map(String).join(":");
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) { peg$cache[bucket] = {}; }
      cached = peg$cache[bucket][key];
      if (cached) {
        peg$currPos = cached.nextPos;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
        return cached.result;
      }
        var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = peg$parseextension_tag(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // extToken <- r4
    if (r4===peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    peg$savedPos = peg$currPos;
    r5 = peg$a187(r4);
    if (r5) {
      r5 = void 0;
    } else {
      r5 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a188(r4);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }

  // start

  if (options.stream) {
    switch (peg$startRule) {
      case '(DEFAULT)':
      case "start_async":
        return peg$streamstart_async(false, new peg$Reference(null));
        break;
      default:
        throw new Error(`Can't stream rule "${peg$startRule}".`);
    }
  } else {
    switch (peg$startRule) {
      case '(DEFAULT)':
      case "start":
        peg$result = peg$parsestart(false, new peg$Reference(null));
        break;
      
      case "table_start_tag":
        peg$result = peg$parsetable_start_tag(false, 0, 0, new peg$Reference(null), new peg$Reference(null));
        break;
      
      case "url":
        peg$result = peg$parseurl(false, new peg$Reference(null));
        break;
      
      case "row_syntax_table_args":
        peg$result = peg$parserow_syntax_table_args(false, 0, 0, new peg$Reference(null), new peg$Reference(null));
        break;
      
      case "table_attributes":
        peg$result = peg$parsetable_attributes(false, 0, 0, new peg$Reference(null), new peg$Reference(null));
        break;
      
      case "generic_newline_attributes":
        peg$result = peg$parsegeneric_newline_attributes(false, 0, 0, new peg$Reference(null), new peg$Reference(null));
        break;
      
      case "tplarg_or_template_or_bust":
        peg$result = peg$parsetplarg_or_template_or_bust(false, new peg$Reference(null));
        break;
      
      case "extlink":
        peg$result = peg$parseextlink(false, 0, 0, new peg$Reference(null), new peg$Reference(null));
        break;
      default:
        throw new Error(`Can't start parsing from rule "${peg$startRule}".`);
    }
  }

  if (peg$result !== peg$FAILED && peg$currPos === input.length) {
    return peg$result;
  } else {
    if (peg$result !== peg$FAILED && peg$currPos < input.length) {
      peg$fail(peg$c0);
    }
    throw peg$buildParseException();
  }
}

return {
  SyntaxError:   peg$SyntaxError,
  DefaultTracer: peg$DefaultTracer,
  parse: peg$parse
};

})();
